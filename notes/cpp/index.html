<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="C++ is the best programming language!">
<meta property="og:type" content="website">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://imzlp.com/notes/cpp/index.html">
<meta property="og:site_name" content="循迹研究室">
<meta property="og:description" content="C++ is the best programming language!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/20230710170920.png">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/20230324200815.png">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-new-data-breakpoint.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-debug-watch-window.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-new-data-breakpoint-specify-address.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-tragger-data-breakpoint.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/disable-optimization.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-environment-var-options.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-set-project-runtime-library-type.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/brace-equal-initializer-diff-mem-initializer.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-customize-file-bar-menu.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-add-file-bar-advanced-save-options.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-file-base-advanced-save-options.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/lambda-expressions-syntex.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/cpp-declara-syntax.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/x32dbg-NoInitCharArray.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/IDA-NoInitCharArray.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/IDA-0xCC-Debug.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/GoogleCppStyleGuide.webp">
<meta property="article:published_time" content="2020-09-30T05:50:33.000Z">
<meta property="article:modified_time" content="2020-09-30T05:50:33.000Z">
<meta property="article:author" content="查利鹏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/20230710170920.png">

<link rel="canonical" href="https://imzlp.com/notes/cpp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ | 循迹研究室
</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="循迹研究室" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">循迹研究室</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>笔记</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>随笔</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>资源</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>友链</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>展示柜</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>站点日志</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>开源项目</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>虚幻知识库</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>站内搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='aW16bHAuY29t';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  

      

        
        <ul id="sub-menu" class="sub-menu menu">
          
            
          
          
              
  <li class="menu-item menu-item-ue5">

    <a href="/notes/ue5/" rel="section"><i class="fas fa-cubes fa-fw"></i>UE5</a>

  </li>


          
          
              
  <li class="menu-item menu-item-gamedev">

    <a href="/notes/gamedev/" rel="section"><i class="fab fa-steam-square fa-fw"></i>GameDev</a>

  </li>


          
          
              
  <li class="menu-item menu-item-cpp">

    <a href="/notes/cpp/" rel="section"><i class="fas fa-keyboard fa-fw"></i>C++</a>

  </li>


          
          
              
  <li class="menu-item menu-item-rust">

    <a href="/notes/rust/" rel="section"><i class="fab fa-rust fa-fw"></i>Rust</a>

  </li>


          
          
              
  <li class="menu-item menu-item-graphics">

    <a href="/notes/graphics/" rel="section"><i class="fas fa-magic fa-fw"></i>Graphics</a>

  </li>


          
          
              
  <li class="menu-item menu-item-vr">

    <a href="/notes/vr/" rel="section"><i class="fas fa-vr-cardboard fa-fw"></i>VR</a>

  </li>


          
          
              
  <li class="menu-item menu-item-computerscience">

    <a href="/notes/computerscience/" rel="section"><i class="fas fa-satellite fa-fw"></i>Computer Science</a>

  </li>


          
          
              
  <li class="menu-item menu-item-linux">

    <a href="/notes/linux/" rel="section"><i class="fab fa-brands fa-linux fa-fw"></i>Linux</a>

  </li>


          
          
              
  <li class="menu-item menu-item-tools">

    <a href="/notes/tools/" rel="section"><i class="fa fa-solid fa-hammer fa-fw"></i>Tools</a>

  </li>


          
          
              
  <li class="menu-item menu-item-tips">

    <a href="/notes/tips/" rel="section"><i class="fa fa-rocket fa-fw"></i>Tips</a>

  </li>


          
        </ul>
        

        

                
                
        
      

      
      

      
      

      
      
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">
	<h1 class="post-title" itemprop="name headline">C++<a href="https://github.com/imzlp/blog-md/blob/master/notes/cpp/index.md" class="post-edit-link" title="编辑" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
	</h1>
	<div class="post-meta">
	    <div class="post-description">C++ is the best programming language!</div>
	  
  <ul class="breadcrumb">
          
            <li><a href="/notes/">NOTES</a></li>
          <li>CPP</li>
        
  </ul>

	</div>


</header>

      
      
      
      <div class="post-body">
          <ul>
<li><a href="https://imzlp.com/posts/19242/">C/C++标准的一些摘录</a></li>
<li><a href="https://imzlp.com/posts/1756/">C/C++中的编程技巧及其概念</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/isocpp/CppCoreGuidelines">Cpp Core Guidelines</a></li>
<li><a target="_blank" rel="noopener" href="https://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">In-depth: Functional programming in C++</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Cpp-Club/Cxx_HOPL4_zh">在拥挤和变化的世界中茁壮成长：C++ 2006–2020</a></li>
</ul>
<hr>
<script src="https://gist.github.com/imzlp/5a69422269b62ccd89b05d5682c95bf8.js"></script>

<h2 id="Clang编译C-为WebAssembly"><a href="#Clang编译C-为WebAssembly" class="headerlink" title="Clang编译C++为WebAssembly"></a>Clang编译C++为WebAssembly</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">llc --version | grep wasm</span><br><span class="line">clang --target=wasm32 -Wl,--export-all -o hello.easm hello.c</span><br></pre></td></tr></table></figure>

<h2 id="LLVM自带IR解释器"><a href="#LLVM自带IR解释器" class="headerlink" title="LLVM自带IR解释器"></a>LLVM自带IR解释器</h2><p><code>lli</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lli test.ll</span><br><span class="line"><span class="comment"># 禁用JIT执行</span></span><br><span class="line">lli --jit-kind=mcjit --force-interpreter</span><br></pre></td></tr></table></figure>

<h2 id="C-23-The-Next-C-Standard"><a href="#C-23-The-Next-C-Standard" class="headerlink" title="C++23:The Next C++ Standard"></a>C++23:The Next C++ Standard</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.modernescpp.com/index.php/c-23-the-next-c-standard">C++23:The Next C++ Standard</a></li>
</ul>
<p><img data-src="https://img.imzlp.com/imgs/zlp/picgo/2023/20230710170920.png"></p>
<h2 id="MinGW-w64的Win独立构建"><a href="#MinGW-w64的Win独立构建" class="headerlink" title="MinGW-w64的Win独立构建"></a>MinGW-w64的Win独立构建</h2><p>可以在这里下载，并且直接包含了Clang：<a target="_blank" rel="noopener" href="https://winlibs.com/">WinLibs standalone build of GCC and MinGW-w64 for Windows</a></p>
<h2 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[[nodiscard]]"></a>[[nodiscard]]</h2><p><code>[[nodiscard]]</code> 是 C++17 引入的属性（attribute），用于告诉编译器一个函数的返回值应该被使用，如果返回值被忽略了，编译器会产生警告。</p>
<p>在使用 <code>[[nodiscard]]</code> 属性声明的函数中，如果函数的返回值没有被用到，编译器会发出警告，以提醒开发者检查代码逻辑。这样可以帮助开发者发现潜在的错误和漏洞，并改善代码的可维护性。</p>
<p>使用 <code>[[nodiscard]]</code> 属性可以帮助开发者避免一些常见的错误，例如：</p>
<ul>
<li>  漏掉错误检查</li>
<li>  错误使用返回值</li>
<li>  未处理函数的返回值</li>
</ul>
<p>下面是一个使用 <code>[[nodiscard]]</code> 属性的示例：</p>
<p><code>[[nodiscard]] int myFunction();</code></p>
<p>在这个示例中，<code>myFunction()</code> 函数使用 <code>[[nodiscard]]</code> 属性声明其返回值应该被使用。如果开发者没有使用该函数的返回值，编译器会发出警告，以提醒开发者检查代码是否正确。</p>
<p>需要注意的是，<code>[[nodiscard]]</code> 属性只适用于函数的返回值，不能用于变量或其他类型的表达式。</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/picgo/2023/20230324200815.png"></p>
<h2 id="C99-VAL-are-turing-complete"><a href="#C99-VAL-are-turing-complete" class="headerlink" title="C99 VAL are turing complete"></a>C99 VAL are turing complete</h2><ul>
<li><a target="_blank" rel="noopener" href="https://lemon.rip/w/c99-vla-tricks/">C99 doesn’t need function bodies, or ‘VLAs are Turing complete’</a></li>
</ul>
<h2 id="禁用特定编号的警告"><a href="#禁用特定编号的警告" class="headerlink" title="禁用特定编号的警告"></a>禁用特定编号的警告</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4701)</span></span><br><span class="line"> <span class="comment">// warning code</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数为什么不能取地址？"><a href="#构造函数为什么不能取地址？" class="headerlink" title="构造函数为什么不能取地址？"></a>构造函数为什么不能取地址？</h2><p>C++中有指向成员指针的操作，可以用来获取指向数据成员或者成员函数的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(A::*func)() = &amp;A::func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是C++标准中有说，不能对构造函数取地址，这是为什么呢？</p>
<p>因为构造函数没有返回值所以不能用函数指针的写法吗?其实不是的，编译器在编译时会给构造函数生成一个函数，以LLVM-IR为例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define linkonce_odr <span class="type">void</span> @_ZN1AC2Ev(%<span class="keyword">struct</span>.A* %<span class="keyword">this</span>) unnamed_addr #<span class="number">4</span> comdat align <span class="number">2</span> &#123;</span><br><span class="line">entry:</span><br><span class="line">  %<span class="keyword">this</span>.addr = alloca %<span class="keyword">struct</span>.A*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">struct</span>.A* %<span class="keyword">this</span>, %<span class="keyword">struct</span>.A** %<span class="keyword">this</span>.addr, align <span class="number">8</span></span><br><span class="line">  %this1 = load %<span class="keyword">struct</span>.A*, %<span class="keyword">struct</span>.A** %<span class="keyword">this</span>.addr</span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和普通的函数是一样的。</p>
<p>但是，构造函数有一些特殊的性质：</p>
<ol>
<li>语法层面无返回值</li>
<li>对象在执行构造函数之前处于一种不完备状态</li>
</ol>
<p>我猜测是，因为执行构造之前对象只是一段混沌的内存，所以它需要初始化关键的信息：构造基类子对象/多态实现等。</p>
<h2 id="模板特化的类型萃取"><a href="#模板特化的类型萃取" class="headerlink" title="模板特化的类型萃取"></a>模板特化的类型萃取</h2><p>在UE中的<code>TStructOpsTypeTraits</code>模板就是通过这种方式来萃取每个类型的标记。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">TYPE_NAME</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraitsBase</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span>&#123;</span><br><span class="line">		WithOne = <span class="literal">false</span>,</span><br><span class="line">		WithTwo = <span class="literal">false</span>,</span><br><span class="line">		WithThree = <span class="literal">false</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">TYPE_NAME</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>:<span class="keyword">public</span> TStructOpsTypeTraitsBase&lt;TYPE_NAME&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;A&gt;:<span class="keyword">public</span> TStructOpsTypeTraitsBase&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span>&#123;</span><br><span class="line">		WithThree = <span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TStructOpsTypeTraits&lt;A&gt;::WithOne ? <span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TStructOpsTypeTraits&lt;A&gt;::WithTwo ? <span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TStructOpsTypeTraits&lt;A&gt;::WithThree ? <span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元关系不能被继承"><a href="#友元关系不能被继承" class="headerlink" title="友元关系不能被继承"></a>友元关系不能被继承</h2><p>在[ISO/IEC 14882:2014]中标准有描述，友元关系不能被继承也不能被传递：</p>
<blockquote>
<p>Friendship is neither inherited nor transitive.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">		p-&gt;a++; <span class="comment">// error: C is not a friend of A</span></span><br><span class="line">		<span class="comment">// despite being a friend of a friend</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">		p-&gt;a++; <span class="comment">// error: D is not a friend of A</span></span><br><span class="line">		<span class="comment">// despite being derived from a friend</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Scoped-enum"><a href="#Scoped-enum" class="headerlink" title="Scoped enum"></a>Scoped enum</h2><p>C++11引入了<code>scoped enum</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EClassEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么要引入这么语法呢？因为C++11之前的enum，其枚举值得定义是位于整个所属名字空间的。C++标准中的描述：</p>
<blockquote>
<p>[IOS/IEC 14882:2014 §7.2]The enumeration type declared with an enum-key of only enum is an unscoped enumeration, and its enumerators are unscoped enumerators.</p>
</blockquote>
<p>下面代码就会出现重定义错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ENormalEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EOtherEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以在一般写代码时会加上namespace来区分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ENamespaceEnum</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">  &#123;</span><br><span class="line">    A = <span class="number">0</span>,</span><br><span class="line">    B,</span><br><span class="line">    C</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为上面<code>Type</code>的枚举值是位于当前namespace的，所以就可以以下面这种形式来使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENamespaceEnum::A;</span><br><span class="line">ENamespaceEnum::B;</span><br><span class="line">ENamespaceEnum::C;</span><br></pre></td></tr></table></figure>
<p>这其实是一种弱类型枚举，枚举本身并不是一个类型。所以C++11引入了<code>Scoped Enum</code>，可以理解为强类型枚举：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EScopedEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用它可以具有与上面<code>namespace</code>形式一样的效果。</p>
<p>Scoped Enumeration的值也是可以显式转换为数值类型的：</p>
<blockquote>
<p>[IOS/IEC 14882:2014 §5.2.9]A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. </p>
</blockquote>
<p>而且，如果scoped enum的基础类型没有被显式指定的话，它的默认基础类型是int:</p>
<blockquote>
<p>[IOS/IEC 14882:2014 §7.2]Each enumeration also has an underlying type. The underlying type can be explicitly speciﬁed using enum-base; if not explicitly speciﬁed, the underlying type of a scoped enumeration type is int.</p>
</blockquote>
<p>在LLVM中，对Scoped enum的处理是在编译器前端做的，下列代码生成的IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ENormalEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EScopedEnum</span>&#123;</span><br><span class="line">	A = <span class="number">0</span>,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A:%d,B:%d,C:%d\n&quot;</span>,A,B,C);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A:%d,B:%d,C:%d\n&quot;</span>,EScopedEnum::A,EScopedEnum::B,EScopedEnum::C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数的LLVM-IR：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: uwtable</span><br><span class="line">define i32 @main() #3 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %call = call i32 (i8*, ...) @_Z6printfPKcz(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i32 0, i32 0), i32 0, i32 1, i32 2)</span><br><span class="line">  %call1 = call i32 (i8*, ...) @_Z6printfPKcz(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i32 0, i32 0), i32 0, i32 1, i32 2)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生成IR时就没有符号信息，只剩常量了。</p>
<h2 id="LoadLibrary-faild"><a href="#LoadLibrary-faild" class="headerlink" title="LoadLibrary faild"></a>LoadLibrary faild</h2><p><code>GetLastError</code>获取错误代码：</p>
<ul>
<li>126：依赖的DLL找不到。</li>
<li>127 ：DLL找到了，但是DLL里需要的符号找不到，通常就是版本有问题。</li>
<li>193：无效的DLL文件，请检查DLL文件是否正常以及x86/x64是否匹配。</li>
</ul>
<h2 id="预处理使用-时需要注意编译器的不统一"><a href="#预处理使用-时需要注意编译器的不统一" class="headerlink" title="预处理使用##时需要注意编译器的不统一"></a>预处理使用##时需要注意编译器的不统一</h2><p>下列代码在MSVC中编译的过：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY(ReturnType,InGetFuncName) \</span></span><br><span class="line"><span class="meta">	bool GetGameExtension##ReturnType##ValueByKey(const FString&amp; InKey,##ReturnType##&amp; OutValue)\</span></span><br><span class="line"><span class="meta">	&#123;\</span></span><br><span class="line"><span class="meta">		bool bLoadIniValueStatus = GConfig-&gt;##InGetFuncName##(\</span></span><br><span class="line"><span class="meta">			GAME_EXTENSION_SETTINGS_SECTION,\</span></span><br><span class="line"><span class="meta">			*InKey,\</span></span><br><span class="line"><span class="meta">			OutValue,\</span></span><br><span class="line"><span class="meta">			GAME_EXTENSION_SETTINGS_INI_FILE\</span></span><br><span class="line"><span class="meta">		);\</span></span><br><span class="line"><span class="meta">		return bLoadIniValueStatus;\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY</span>(FString,GetString);</span><br></pre></td></tr></table></figure>

<p>但是在GCC/Clang中会又如下错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Preprocess.cpp:<span class="number">16</span>:<span class="number">1</span>: error: pasting formed <span class="string">&#x27;,FString&#x27;</span>, <span class="function">an invalid preprocessing token</span></span><br><span class="line"><span class="function"><span class="title">DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY</span><span class="params">(FString,GetString)</span></span>;</span><br><span class="line">^</span><br><span class="line">Preprocess.cpp:<span class="number">5</span>:<span class="number">69</span>: note: expanded from macro <span class="string">&#x27;DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY&#x27;</span></span><br><span class="line">        <span class="type">bool</span> GetGameExtension##ReturnType##<span class="built_in">ValueByKey</span>(<span class="type">const</span> FString&amp; InKey,##ReturnType##&amp; OutValue)\</span><br><span class="line">                                                                           ^</span><br><span class="line">Preprocess.cpp:<span class="number">16</span>:<span class="number">1</span>: error: pasting formed <span class="string">&#x27;FString&amp;&#x27;</span>, an invalid preprocessing token</span><br><span class="line">Preprocess.cpp:<span class="number">5</span>:<span class="number">81</span>: note: expanded from macro <span class="string">&#x27;DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY&#x27;</span></span><br><span class="line">        <span class="type">bool</span> GetGameExtension##ReturnType##<span class="built_in">ValueByKey</span>(<span class="type">const</span> FString&amp; InKey,##ReturnType##&amp; OutValue)\</span><br><span class="line">                                                                                       ^</span><br><span class="line">Preprocess.cpp:<span class="number">16</span>:<span class="number">1</span>: error: pasting formed <span class="string">&#x27;-&gt;GetString&#x27;</span>, an invalid preprocessing token</span><br><span class="line">Preprocess.cpp:<span class="number">7</span>:<span class="number">39</span>: note: expanded from macro <span class="string">&#x27;DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY&#x27;</span></span><br><span class="line">                <span class="type">bool</span> bLoadIniValueStatus = GConfig-&gt;##InGetFuncName##(\</span><br><span class="line">                                                    ^</span><br><span class="line">Preprocess.cpp:<span class="number">16</span>:<span class="number">1</span>: error: pasting formed <span class="string">&#x27;GetString(&#x27;</span>, an invalid preprocessing token</span><br><span class="line">Preprocess.cpp:<span class="number">7</span>:<span class="number">54</span>: note: expanded from macro <span class="string">&#x27;DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY&#x27;</span></span><br><span class="line">                <span class="type">bool</span> bLoadIniValueStatus = GConfig-&gt;##InGetFuncName##(\</span><br><span class="line">                                                                   ^</span><br><span class="line"><span class="number">4</span> errors generated.</span><br></pre></td></tr></table></figure>

<p>这是由于GCC/Clang要求预处理之后的的结果必须是一个<strong>已定义的符号</strong>，MSVC在这方面和它们不一样，解决办法为在非拼接顺序字符的地方删掉<code>##</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_GAME_EXTENSION_TYPE_VALUE_BY_KEY(ReturnType,InGetFuncName) \</span></span><br><span class="line"><span class="meta">	bool GetGameExtension##ReturnType##ValueByKey(const FString&amp; InKey, ReturnType&amp; OutValue)\</span></span><br><span class="line"><span class="meta">	&#123;\</span></span><br><span class="line"><span class="meta">		OutValue = ReturnType&#123;&#125;;\</span></span><br><span class="line"><span class="meta">		bool bLoadIniValueStatus = GConfig-&gt;InGetFuncName(\</span></span><br><span class="line"><span class="meta">			GAME_EXTENSION_SETTINGS_SECTION,\</span></span><br><span class="line"><span class="meta">			*InKey,\</span></span><br><span class="line"><span class="meta">			OutValue,\</span></span><br><span class="line"><span class="meta">			GAME_EXTENSION_SETTINGS_INI_FILE\</span></span><br><span class="line"><span class="meta">		);\</span></span><br><span class="line"><span class="meta">		return bLoadIniValueStatus;\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure>

<p>相关文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46356185/pasting-formed-an-invalid-processing-token">Pasting formed an invalid processing token ‘.’</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50114062/error-pasting-formed-with-invalid-preprocessing-token">Error: Pasting formed with invalid preprocessing token</a></li>
</ul>
<h2 id="C-中delete-的实现"><a href="#C-中delete-的实现" class="headerlink" title="C++中delete[]的实现"></a>C++中delete[]的实现</h2><blockquote>
<p>注意：不同的编译器实现可能不一样，我使用的是Clang 7.0.0 x86_64-w64-windows-gnu</p>
</blockquote>
<p>在C++中我们可以通过<code>new</code>和<code>new[]</code>在堆上分配内存，但是有没有考虑过下面这样的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	~<span class="built_in">IntClass</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntClass *i = <span class="keyword">new</span> IntClass[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>i</code>就只是一个普通的指针，所以它没有任何的类型信息，那么<code>delete[]</code>的时候怎么知道要回收多少内存呢？</p>
<p>所以肯定是哪里存储了<code>i</code>的长度信息！祭出我们的IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: noinline norecurse optnone uwtable</span><br><span class="line">define dso_local i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.IntClass*, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">3</span> = call i8* @_Znay(i64 <span class="number">48</span>) #<span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = bitcast i8* %<span class="number">3</span> to i64*</span><br><span class="line">  store i64 <span class="number">10</span>, i64* %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">5</span> = getelementptr inbounds i8, i8* %<span class="number">3</span>, i64 <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = bitcast i8* %<span class="number">5</span> to %<span class="keyword">class</span>.IntClass*</span><br><span class="line">  store %<span class="keyword">class</span>.IntClass* %<span class="number">6</span>, %<span class="keyword">class</span>.IntClass** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">7</span> = load %<span class="keyword">class</span>.IntClass*, %<span class="keyword">class</span>.IntClass** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">8</span> = icmp eq %<span class="keyword">class</span>.IntClass* %<span class="number">7</span>, null</span><br><span class="line">  br i1 %<span class="number">8</span>, label %<span class="number">21</span>, label %<span class="number">9</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">9</span>:                                      ; preds = %<span class="number">0</span></span><br><span class="line">  %<span class="number">10</span> = bitcast %<span class="keyword">class</span>.IntClass* %<span class="number">7</span> to i8*</span><br><span class="line">  %<span class="number">11</span> = getelementptr inbounds i8, i8* %<span class="number">10</span>, i64 <span class="number">-8</span></span><br><span class="line">  %<span class="number">12</span> = bitcast i8* %<span class="number">11</span> to i64*</span><br><span class="line">  %<span class="number">13</span> = load i64, i64* %<span class="number">12</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">14</span> = getelementptr inbounds %<span class="keyword">class</span>.IntClass, %<span class="keyword">class</span>.IntClass* %<span class="number">7</span>, i64 %<span class="number">13</span></span><br><span class="line">  %<span class="number">15</span> = icmp eq %<span class="keyword">class</span>.IntClass* %<span class="number">7</span>, %<span class="number">14</span></span><br><span class="line">  br i1 %<span class="number">15</span>, label %<span class="number">20</span>, label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">16</span>:                                     ; preds = %<span class="number">16</span>, %<span class="number">9</span></span><br><span class="line">  %<span class="number">17</span> = phi %<span class="keyword">class</span>.IntClass* [ %<span class="number">14</span>, %<span class="number">9</span> ], [ %<span class="number">18</span>, %<span class="number">16</span> ]</span><br><span class="line">  %<span class="number">18</span> = getelementptr inbounds %<span class="keyword">class</span>.IntClass, %<span class="keyword">class</span>.IntClass* %<span class="number">17</span>, i64 <span class="number">-1</span></span><br><span class="line">  call <span class="type">void</span> @_ZN8IntClassD2Ev(%<span class="keyword">class</span>.IntClass* %<span class="number">18</span>) #<span class="number">3</span></span><br><span class="line">  %<span class="number">19</span> = icmp eq %<span class="keyword">class</span>.IntClass* %<span class="number">18</span>, %<span class="number">7</span></span><br><span class="line">  br i1 %<span class="number">19</span>, label %<span class="number">20</span>, label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">20</span>:                                     ; preds = %<span class="number">16</span>, %<span class="number">9</span></span><br><span class="line">  call <span class="type">void</span> @_ZdaPv(i8* %<span class="number">11</span>) #<span class="number">9</span></span><br><span class="line">  br label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">21</span>:                                     ; preds = %<span class="number">20</span>, %<span class="number">0</span></span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到编译器给我们的<code>new IntClass[10]</code>通过<code>@_Znay(i64 48)</code>来分配了48个字节的内存！</p>
<p>但是按照<code>sizeof(IntClass)*10</code>来算其实之应该有40个字节的内存，多余的8个字节用来存储了数组的长度信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = call i8* @_Znay(i64 <span class="number">48</span>) #<span class="number">8</span></span><br><span class="line">%<span class="number">4</span> = bitcast i8* %<span class="number">3</span> to i64*</span><br><span class="line">store i64 <span class="number">10</span>, i64* %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">5</span> = getelementptr inbounds i8, i8* %<span class="number">3</span>, i64 <span class="number">8</span></span><br><span class="line">%<span class="number">6</span> = bitcast i8* %<span class="number">5</span> to %<span class="keyword">class</span>.IntClass*</span><br></pre></td></tr></table></figure>

<p>可以看到，它把数组的长度写入到了分配内存的前8个字节，在八个字节之后才可以分配真正的对象。</p>
<p>我们真正得到的<code>i</code>的地址就是偏移之后的，数组的长度写在第一个元素之前的64位内存中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个x代表一个byte，new IntClass[10]产生的内存布局</span></span><br><span class="line">|xxxxxxxx|xxxx|xxxx|xxxx|xxxx|xxxx|xxxx|xxxx|xxxx|xxxx|xxxx|</span><br></pre></td></tr></table></figure>

<p>既然知道了它存在哪里，所以我们可以修改它（在修改之前我们<code>delete[] i;</code>会调用10次析构函数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntClass *i = <span class="keyword">new</span> IntClass[<span class="number">10</span>];</span><br><span class="line"><span class="type">int64_t</span> *ArrayLength = (<span class="type">int64_t</span>*)((<span class="type">char</span>*)(i)<span class="number">-8</span>);</span><br><span class="line">*ArrayLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span>[] i;</span><br></pre></td></tr></table></figure>

<p>这样修改之后<code>delete[] i;</code>只会调用1次析构函数，也印证了我们猜想。</p>
<h2 id="VS内存断点"><a href="#VS内存断点" class="headerlink" title="VS内存断点"></a>VS内存断点</h2><p>在使用VS调试的时候有在有些情况下需要知道一些对象在什么时候被修改了，如果按照单步一点一点来调试的话很不方便，这时候就可以使用VS的<code>Data Breakpoint</code>来进行断点调试：</p>
<p>添加<code>Data Breakpoint</code>的操作为<code>Debug</code>-<code>New BreakPoint</code>-<code>Data Breakpoint</code>（或者在<code>Breakpoint</code>窗口下）：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-new-data-breakpoint.webp"></p>
<p>需要在<code>Address</code>处输入要断点的内存地址，可以输入对象名字使用取地址表达式(<code>&amp;Test</code>)，如果想要断点的对象不是全局对象可以通过直接输入内存地址。</p>
<p>获取一个对象的内存地址的方法为在<code>Watch</code>下添加一条该对象的取地址表达式（可以使用<code>&amp;ival</code>或者<code>&amp;this-&gt;ival</code>）：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-debug-watch-window.webp"></p>
<p>其中<code>Value</code>的就得到了该对象的内存地址。</p>
<p>拿到内存地址之后就可以填到<code>Data Breakpoint</code>的<code>Address</code>中了，然后指定它的数据大小（可选1/2/4/8）：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-new-data-breakpoint-specify-address.webp"></p>
<p>当该地址的数据被修改时会提示触发了内存断点：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-tragger-data-breakpoint.webp"></p>
<h2 id="move和forward的区别"><a href="#move和forward的区别" class="headerlink" title="move和forward的区别"></a>move和forward的区别</h2><p><code>std::move</code>和<code>std::forward</code>均是定义在<code>&lt;utility&gt;</code>中的函数。</p>
<table>
<thead>
<tr>
<th>function</th>
<th>describle</th>
</tr>
</thead>
<tbody><tr>
<td>x2=forward(x)</td>
<td>x2是一个右值，x不能是左值；不抛出异常</td>
</tr>
<tr>
<td>x2=move(x)</td>
<td>x2是一个右值；不抛出异常</td>
</tr>
<tr>
<td>x2=move_if_noecept(x)</td>
<td>若x2可移动，x2=move(x)；否则x2=x；不抛出异常</td>
</tr>
</tbody></table>
<p><code>std::move</code>进行简单的右值转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">remove_reference&lt;T&gt;&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;remove_reference&lt;T&gt;&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实<code>move</code>应该命名为<code>rvalue</code>才对，它没有移动任何东西，而是从实参生成一个rvalue，从而所指向的对象可以移动。</p>
<p>我们用<code>move</code>告知编译器，此对象在上下文中不再被使用，因此其值可以被移动，留下一个空对象。最简单的就是<code>swap</code>的实现。</p>
<p><code>std::forward</code>从右值生成一个右值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(remove_reference&lt;T&gt;&amp; t)</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(remove_reference&lt;T&gt;&amp;&amp; t)</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_asset</span>(!is_lvalue_reference&lt;T&gt;,<span class="string">&quot;forward of value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这对forward函数总是会一直提供，两者间的选择是通过重载解析实现的。任何左值都会由第一个版本处理，任何右值都会有第二个版本处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">7</span>;</span><br><span class="line">forward(i); <span class="comment">// 调用第一个版本</span></span><br><span class="line">forward(<span class="number">7</span>); <span class="comment">// 调用第二个版本</span></span><br></pre></td></tr></table></figure>

<p>第二个版本的断言是为了防止用显示模板实参和一个左值调用第二个版本。</p>
<p><code>forward</code>的典型用法是将一个实参完美转发到另一个函数。</p>
<p>当系统用移动操作窃取一个对象的表示形式时，使用<code>move</code>；当希望转发一个对象时，使用<code>forward</code>。因此<code>forward</code>总是安全的，而<code>move</code>标记x将被销毁，因此使用时要小心。调用<code>std::move(x)</code>之后x唯一的用法就是析构或者赋值目的。</p>
<h2 id="rvalue和lvalue的重载规则"><a href="#rvalue和lvalue的重载规则" class="headerlink" title="rvalue和lvalue的重载规则"></a>rvalue和lvalue的重载规则</h2><h3 id="实现non-const-lvalue版本"><a href="#实现non-const-lvalue版本" class="headerlink" title="实现non-const lvalue版本"></a>实现non-const lvalue版本</h3><p>如果一个类只实现了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(A&amp;)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>则该类只能被<code>lvalue</code>调用，但不能被<code>rvalue</code>调用。如下列代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;A();\n&quot;</span>);&#125;</span><br><span class="line">	<span class="built_in">A</span>(A&amp; In)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(A&amp; In);\n&quot;</span>);&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;~A();\n&quot;</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A tmpA;</span><br><span class="line">	A tmpB = std::<span class="built_in">move</span>(tmpA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会有下列错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\visionsmile\Desktop\cpp\rvalue.cpp:31:4: error: no matching constructor <span class="keyword">for</span> initialization of <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        A tmpB = std::move(tmpA);</span><br><span class="line">          ^      ~~~~~~~~~~~~~~~</span><br><span class="line">C:\Users\visionsmile\Desktop\cpp\rvalue.cpp:15:2: note: candidate constructor not viable: expects an l-value <span class="keyword">for</span> 1st argument</span><br><span class="line">        A(A&amp; In)</span><br><span class="line">        ^</span><br><span class="line">C:\Users\visionsmile\Desktop\cpp\rvalue.cpp:12:2: note: candidate constructor not viable: requires 0 arguments, but 1 was provided</span><br><span class="line">        <span class="function"><span class="title">A</span></span>()&#123;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<h3 id="实现const-lvalue版本"><a href="#实现const-lvalue版本" class="headerlink" title="实现const lvalue版本"></a>实现const lvalue版本</h3><p>如果实现了const版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; In)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(const A&amp; In);\n&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>则既可以被rvalue也可以被lvalue调用。</p>
<h3 id="只实现rvalue版本"><a href="#只实现rvalue版本" class="headerlink" title="只实现rvalue版本"></a>只实现rvalue版本</h3><p>如果类中只有rvalue的函数版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(A&amp;&amp; rIn)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(A&amp;&amp; rIn);\n&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>则只能被rvalue调用，不能被lvalue调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;A();\n&quot;</span>);&#125;</span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; rIn)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(A&amp;&amp; In);\n&quot;</span>);&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;~A();\n&quot;</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A tmpA;</span><br><span class="line">	A tmpB = tmpA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或有下列编译错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\visionsmile\Desktop\cpp\rvalue.cpp:31:4: error: call to implicitly-deleted copy constructor of <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        A tmpB = tmpA;</span><br><span class="line">          ^      ~~~~</span><br><span class="line">C:\Users\visionsmile\Desktop\cpp\rvalue.cpp:19:2: note: copy constructor is implicitly deleted because <span class="string">&#x27;A&#x27;</span> has a user-declared move constructor</span><br><span class="line">        A(A&amp;&amp; rIn)</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<h3 id="既有rvalue也有lvalue版本"><a href="#既有rvalue也有lvalue版本" class="headerlink" title="既有rvalue也有lvalue版本"></a>既有rvalue也有lvalue版本</h3><p>如果既提供了rvalue也提供了lvalue版本，则可以区分<code>为rvalue</code>服务和<code>为lvalue</code>服务的能力</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;A();\n&quot;</span>);&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; In)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(const A&amp; In);\n&quot;</span>);&#125;</span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; rIn)&#123;<span class="built_in">printf</span>(<span class="string">&quot;A(A&amp;&amp; In);\n&quot;</span>);&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;~A();\n&quot;</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A tmpA;</span><br><span class="line">	A tmpB = tmpA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如果类未提供move语义，只提供常规的copy构造函数和copy assignment操作符，rvalue引用可以调用他们。</p>
<p>因此<code>std::move</code>意味着：调用move语义，否则调用cop语义。</p>
<h2 id="rvalue和lvalue"><a href="#rvalue和lvalue" class="headerlink" title="rvalue和lvalue"></a>rvalue和lvalue</h2><p>rvalue(左值)是指对象的一条表达式，左值的字面意思是能再赋值运算符左侧的东西。但其实不是所有的左值都能用在赋值运算符的左侧，左值也有可能指示某个常量。</p>
<p>待补充。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://thbecker.net/articles/rvalue_references/section_01.html">C++ Rvalue References Explained</a></li>
</ul>
<h2 id="C-局部对象的销毁顺序"><a href="#C-局部对象的销毁顺序" class="headerlink" title="C++局部对象的销毁顺序"></a>C++局部对象的销毁顺序</h2><p>C++标准规定按照构造的逆序执行销毁。</p>
<blockquote>
<p>[ISO/IEC 14882:2014 § 6.6]On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been constructed in that scope are destroyed in the reverse order of their construction.</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14688285/c-local-variable-destruction-order">C++ local variable destruction order</a></li>
</ul>
<h2 id="C-函数的后置-amp-与-amp-amp-修饰符"><a href="#C-函数的后置-amp-与-amp-amp-修饰符" class="headerlink" title="C++函数的后置&amp;与&amp;&amp;修饰符"></a>C++函数的后置&amp;与&amp;&amp;修饰符</h2><p>考虑下面例子代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T&amp; <span class="title">Get</span><span class="params">()</span> &amp;</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T&amp;&amp; <span class="title">Get</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">move</span>(value);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个<code>A::Get</code>函数后面的<code>&amp;</code>与<code>&amp;&amp;</code>修饰符是什么作用呢？</p>
<p>其实主要是因为这两个函数的原型只有返回值类型不同，但是，类成员函数的签名不包含返回值类型，所以他们会又重定义错误，而加这两个修饰的目的是让他们的签名不同。</p>
<p>C++类成员函数的签名组成：</p>
<ul>
<li>name</li>
<li>parameter type list</li>
<li>class of witch the function is a member</li>
<li>cv-qualifiers(if any)</li>
<li>ref-qualifer(if any)</li>
</ul>
<p>声明部分的语法描述在**[IOS/IEC 14882:2014 § 8 Declarators]**</p>
<h2 id="static的链接问题"><a href="#static的链接问题" class="headerlink" title="static的链接问题"></a>static的链接问题</h2><p>在<code>global</code>/<code>namespace</code> scope的static函数/变量，仅在定义它的**翻译单元(translation unit)**可用，在其他的翻译单元不可用。</p>
<p>如有三个文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下列命令编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意此处有两个翻译单元 main.cpp/file.cpp</span></span><br><span class="line">$ clang++ main.cpp file.cpp -o main.exe</span><br></pre></td></tr></table></figure>

<p>会产生链接错误：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In file included from main.cpp:2:</span><br><span class="line">./file.h:3:13: warning: function &#x27;func&#x27; has internal linkage but is not defined [-Wundefined-internal]</span><br><span class="line">static void func();</span><br><span class="line">            ^</span><br><span class="line">main.cpp:6:5: note: used here</span><br><span class="line">    func();</span><br><span class="line">    ^</span><br><span class="line">1 warning generated.</span><br><span class="line">C:\Users\imzlp\AppData\Local\Temp\main-70cbfd.o:(.text+0x10): undefined reference to `func()&#x27;</span><br><span class="line">clang++.exe: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>这是因为<code>func</code>是个<code>static</code>函数，而且定义在<code>file.cpp</code>的翻译单元，因为<code>static</code>对象的<code>internal linkage</code>性质，而<code>main.cpp</code>的翻译单元不包含<code>func</code>的定义，所以会产生上面的链接错误。</p>
<p>知道了原因，那么解决办法有两个：</p>
<ol>
<li>去掉<code>func</code>的static；</li>
<li>在所有用到<code>func</code>的翻译单元中包含<code>func</code>的定义。</li>
</ol>
<h2 id="placement-new编译时的错误"><a href="#placement-new编译时的错误" class="headerlink" title="placement-new编译时的错误"></a>placement-new编译时的错误</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;operator new&#x27; : function does not take 2 arguments</span><br></pre></td></tr></table></figure>

<p>这个错误是因为没有包含<code>new.h</code>/<code>new</code>.</p>
<h2 id="The-Next-Big-Thing-C-20"><a href="#The-Next-Big-Thing-C-20" class="headerlink" title="The Next Big Thing:C++20"></a>The Next Big Thing:C++20</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/next-big-thing-c20-rainer-grimm">The Next Big Thing: C++20</a></li>
</ul>
<p>这篇文章简单介绍了C++标准的历史和新标准的动向。</p>
<h2 id="变量已被优化，因而不可用"><a href="#变量已被优化，因而不可用" class="headerlink" title="变量已被优化，因而不可用"></a>变量已被优化，因而不可用</h2><p>在VS调试中，有时候会在<code>Debug</code>窗口看到<code>变量已被优化，因而不可用</code>，导致看不到对象值。可以在VS的项目设置中关闭优化。<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/disable-optimization.webp"></p>
<h2 id="C5083错误"><a href="#C5083错误" class="headerlink" title="C5083错误"></a>C5083错误</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error C5038: data member &#x27;UTcpNetPeer::ConnectionState&#x27; will be initialized after data member &#x27;UTcpNetPeer::OpenedTime&#x27;</span><br><span class="line">error C5038: data member &#x27;UTcpNetPeer::bReceivedHeader&#x27; will be initialized after data member &#x27;UTcpNetPeer::Thread&#x27;</span><br><span class="line">error C5038: data member &#x27;UTcpNetPeer::TotalBytesSent&#x27; will be initialized after data member &#x27;UTcpNetPeer::bRun&#x27;</span><br><span class="line">error C5038: data member &#x27;UTcpNetPeer::RecvMessageDataRemaining&#x27; will be initialized after data member &#x27;UTcpNetPeer::ConnectionRetryTimes&#x27;</span><br><span class="line">error C5038: data member &#x27;UTcpNetPeer::ConnectionRetryTimes&#x27; will be initialized after data member &#x27;UTcpNetPeer::ConnectingTime&#x27;</span><br></pre></td></tr></table></figure>
<p>其实这个应该不算做错误，只是UE 4.22的警告等级比较高。<br>这个报错的意思是，在构造函数的定义里对数据成员的初始化的顺序与在声明中不一样，建议还是改掉，但是如果改动量太多，可以禁用掉<code>C5083</code>这个警告。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable:5038)</span></span><br></pre></td></tr></table></figure>


<h2 id="VS中的属性宏"><a href="#VS中的属性宏" class="headerlink" title="VS中的属性宏"></a>VS中的属性宏</h2><p>在VS中配置include或者链接lib的时候需要指定路径，但是绝对路径很方便，可以使用VS的属性宏来设置。<br>比较常用的有以下几个：</p>
<ul>
<li><code>SolutionDir</code>：解决方案的路径。</li>
<li><code>ProjectDir</code>：项目的路径。</li>
<li><code>ProjectName</code>：项目名。</li>
<li><code>Platform</code>：平台（x86/x64等）</li>
<li><code>Configuration</code>：配置(Debug/Release)</li>
<li><code>RuntimeLibrary</code>：运行时的类型<code>MT</code>/<code>MD</code></li>
<li>也可以包含用户自己在系统中的创建的环境变量，如<code>$(BOOST)</code>等。</li>
</ul>
<p>用法皆是<code>$(VAR_NAME)</code>，如<code>$(SolutionDir)</code>。<br>微软有个页面列出了VS中可用的属性宏：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/common-macros-for-build-commands-and-properties?view=vs-2019">Common macros for MSBuild commands and properties</a><br>在VS中也可以通过<code>Project Properties</code>-<code>Configuration Properties</code>-<code>C/C++</code>-<code>General</code>-Edit<code>Additional Include Direcories</code>-<code>Macro</code>中找到支持的宏列表:<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-environment-var-options.webp"></p>
<h2 id="使用Win库但没有添加链接库的链接错误"><a href="#使用Win库但没有添加链接库的链接错误" class="headerlink" title="使用Win库但没有添加链接库的链接错误"></a>使用Win库但没有添加链接库的链接错误</h2><p>在代码中使用了<code>MessageBoxA</code>，但是在链接时却产生了一个链接错误：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&gt;------ Build started: Project: ELogging, Configuration: Debug x64 ------</span><br><span class="line">1&gt;   Creating library ..\..\Bin\x64\Debug\ELogging.lib and object ..\..\Bin\x64\Debug\ELogging.exp</span><br><span class="line">1&gt;Logging.obj : error LNK2019: unresolved external symbol __imp_MessageBoxA referenced in function &quot;public: void __cdecl Logging::WriteMsgs(enum LoggingEnum,char *,int,char *)&quot; (?WriteMsgs@Logging@@QEAAXW4LoggingEnum@@PEADH1@Z)</span><br><span class="line">1&gt;..\..\Bin\x64\Debug\ELogging.dll : fatal error LNK1120: 1 unresolved externals</span><br><span class="line">1&gt;Done building project &quot;ELogging.vcxproj&quot; -- FAILED.</span><br><span class="line">========== Build: 0 succeeded, 1 failed, 1 up-to-date, 0 skipped ==========</span><br></pre></td></tr></table></figure>
<p>说的是在<code>WriteMsgs</code>中使用到的符号<code>__imp_MessageBoxA</code>没有定义。<br>这个符号是定义在<code>user32.lib</code>中的，在项目中添加上即可，原本以为win库的lib都是默认链接的，坑。</p>
<p>相关问题：<a target="_blank" rel="noopener" href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/ef029daa-8ef9-46ee-90bd-b9e9516ab53b/junkobj-error-lnk2019-unresolved-external-symbol-impmessageboxa-referenced-in-function-main?forum=vclanguage">junk.obj : error LNK2019: unresolved external symbol __imp_MessageBoxA referenced in function main</a></p>
<h2 id="引入外部Lib时的LINK1112链接错误"><a href="#引入外部Lib时的LINK1112链接错误" class="headerlink" title="引入外部Lib时的LINK1112链接错误"></a>引入外部Lib时的LINK1112链接错误</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libboost_thread-vc140-mt-gd-1_62.lib(thread.obj) : fatal error LNK1112: module machine type &#x27;x86&#x27; conflicts with target machine type &#x27;x64&#x27;</span><br></pre></td></tr></table></figure>

<p>该错误表示，当前编译的项目的目标机器是x64，但是项目中引用的<code>libboost_thread-vc140-mt-gd-1_62.lib</code>却是x86的，所以才会报这个错误。</p>
<h2 id="引入外部Lib时的LINK2038链接错误"><a href="#引入外部Lib时的LINK2038链接错误" class="headerlink" title="引入外部Lib时的LINK2038链接错误"></a>引入外部Lib时的LINK2038链接错误</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>&gt;Generating Code...</span><br><span class="line"><span class="number">2</span>&gt;libboost_system-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(error_code.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_date_time-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(greg_month.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_filesystem-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(path_traits.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_filesystem-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(path.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_filesystem-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(operations.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_filesystem-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(codecvt_error_category.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_filesystem-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(windows_file_codecvt.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_thread-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(thread.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;libboost_thread-vc140-mt-gd<span class="number">-1</span>_62.<span class="built_in">lib</span>(tss_pe.obj) : error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br><span class="line"><span class="number">2</span>&gt;LINK : fatal error LNK1104: cannot open file <span class="string">&#x27;libboost_date_time-vc140-mt-sgd-1_62.lib&#x27;</span></span><br><span class="line"><span class="number">2</span>&gt;Done building project <span class="string">&quot;ELogging.vcxproj&quot;</span> -- FAILED.</span><br><span class="line">========== Build: <span class="number">1</span> succeeded, <span class="number">1</span> failed, <span class="number">0</span> up-to-date, <span class="number">0</span> skipped ==========</span><br></pre></td></tr></table></figure>

<p>这个错误的关键点在于，当前的项目编译的<code>Runtime Library</code>的类型是<code>MTd_StaticDebug</code>而依赖的链接库<code>libboost_thread-vc140-mt-gd-1_62.lib</code>是<code>MDd_DynamicDebug</code>，所以造成了链接时的不匹配:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error LNK2038: mismatch detected <span class="keyword">for</span> <span class="string">&#x27;RuntimeLibrary&#x27;</span>: value <span class="string">&#x27;MDd_DynamicDebug&#x27;</span> doesn<span class="number">&#x27;</span>t match value <span class="string">&#x27;MTd_StaticDebug&#x27;</span> in ELogging.obj</span><br></pre></td></tr></table></figure>

<p>知道了问题，那么解决这个问题的办法就是，<strong>使当前编译的项目的RuntimeLibrary类型和所有依赖的lib的RuntimeLibrary类型保持一致</strong>。</p>
<p>修改方法为：<code>Project Properties</code>-<code>Configuration</code>-<code>C/C++</code>-<code>Code Generation</code>-<code>Runtime Library</code>:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-set-project-runtime-library-type.webp"></p>
<blockquote>
<p>这是个坑点，在引入外部的Lib的时候一定要看清楚项目所依赖的类型。</p>
</blockquote>
<h2 id="预编译的C1010错误"><a href="#预编译的C1010错误" class="headerlink" title="预编译的C1010错误"></a>预编译的C1010错误</h2><p>编译代码时在一个全部代码全部被注释的<code>.cpp</code>文件中报了下面一个错误：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add &#x27;#include &quot;stdafx.h&quot;&#x27; to your source?</span><br></pre></td></tr></table></figure>

<p>提示没有添加预编译头<code>stdafx.h</code>到文件，可以报错的文件包含即可，但是这里我又不需要让它包含。</p>
<p>那么可以进入<code>Project Properties</code>-<code>C/C++</code>-<code>Precompiled Header</code>，将<code>Precompiled Header</code>改为<code>Not Using Precompiled Headers</code>，重新编译即可，缺点就是不能使用预编译的加速了。</p>
<blockquote>
<p>所谓头文件预编译，就是把一个工程(Project)中使用的一些标准头文件(如Windows.h、Afxwin.h)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。<br>预编译头文件通过编译<code>stdafx.cpp</code>生成，以工程名命名，由于预编译的头文件的后缀是<code>pch</code>，所以编译结果文件是<code>ProjectName.pch</code>。<br>编译器通过一个头文件<code>stdafx.h</code>来使用预编译头文件。<code>stdafx.h</code>这个头文件名是可以在project的编译设置里指定的（<code>Project Properties</code>-<code>C/C++</code>-<code>Precompiled Header</code>-<code>Precompiled Header File</code>）。<br>编译器认为，所有在指令<code>#include &quot;stdafx.h&quot;</code>前的代码都是预编译的，它跳过<code>#include &quot;stdafx.h&quot;</code>指令，使用<code>ProjectName.pch</code>编译这条指令之后的所有代码。 因此，所有的CPP实现文件第一条语句都是<code>#include &quot;stdafx.h&quot;</code>。  </p>
</blockquote>
<h2 id="类内默认值与构造函数初始化的顺序"><a href="#类内默认值与构造函数初始化的顺序" class="headerlink" title="类内默认值与构造函数初始化的顺序"></a>类内默认值与构造函数初始化的顺序</h2><p>在C++11中，引入了类内初始化机制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// initialized as 10</span></span><br><span class="line">  <span class="comment">// or int ival&#123;10&#125;;</span></span><br><span class="line">  <span class="type">int</span> ival=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这又会引入一个问题：如果我同时使用类内初始化和构造函数初始化两种方式，那么真正使用的又是什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">ival</span>(<span class="number">11</span>)&#123;&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// initialized as 10</span></span><br><span class="line">  <span class="type">int</span> ival=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码ival的值应该是多少呢？<br>这一点在C++标准中给了明确的解答：</p>
<blockquote>
<p>[IOS/IEC 14882:2014 §12.6.2.9]If a given non-static data member has both a brace-or-equal-initializer and a mem-initializer, the initialization specified by the mem-initializer is performed, and the non-static data member’s brace-or-equal-initializer is ignored. </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = /∗ some integer expression with side eﬀects ∗/ ;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> arg) : <span class="built_in">i</span>(arg) &#123; &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>the A(int) constructor will simply initialize i to the value of arg, and the side effects in i’s brace-or-equal-initializer will not take place. </p>
</blockquote>
<p>但是我仍想自己分析一下编译器的实际处理，在之前的文章和笔记中，已经知道了编译器会将类内初始化的操作合并到构造函数中，其执行是在基类的构造之后，自己的构造函数体之前。依然使用LLVM-IR代码分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// initialized as 10</span></span><br><span class="line">  <span class="type">int</span> ival=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其构造函数的IR代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: noinline optnone uwtable</span><br><span class="line">define linkonce_odr dso_local <span class="type">void</span> @_ZN1AC2Ev(%<span class="keyword">class</span>.A*) unnamed_addr #<span class="number">5</span> comdat align <span class="number">2</span> &#123;</span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.A*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">class</span>.A* %<span class="number">0</span>, %<span class="keyword">class</span>.A** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">3</span> = load %<span class="keyword">class</span>.A*, %<span class="keyword">class</span>.A** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = getelementptr inbounds %<span class="keyword">class</span>.A, %<span class="keyword">class</span>.A* %<span class="number">3</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  store i32 <span class="number">10</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = call <span class="built_in">i32</span> (i8*, ...) @_ZL6printfPKcz(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">1</span> x i8], [<span class="number">1</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，是先初始化了this指针，然后根据this指针获取到成员<code>ival</code>，然后对其进行初始化(IR里的store操作)。<br>如果我们使用构造函数初始化的写法呢?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// initialized as 11</span></span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">ival</span>(<span class="number">11</span>)&#123;&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// initialized as 10</span></span><br><span class="line">  <span class="type">int</span> ival=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>真正的行为为：ival被初始化为11。</p>
<p>其IR代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: noinline optnone uwtable</span><br><span class="line">define linkonce_odr dso_local <span class="type">void</span> @_ZN1AC2Ev(%<span class="keyword">class</span>.A*) unnamed_addr #<span class="number">5</span> comdat align <span class="number">2</span> &#123;</span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.A*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">class</span>.A* %<span class="number">0</span>, %<span class="keyword">class</span>.A** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">3</span> = load %<span class="keyword">class</span>.A*, %<span class="keyword">class</span>.A** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = getelementptr inbounds %<span class="keyword">class</span>.A, %<span class="keyword">class</span>.A* %<span class="number">3</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  store i32 <span class="number">10</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = call <span class="built_in">i32</span> (i8*, ...) @_ZL6printfPKcz(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">1</span> x i8], [<span class="number">1</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过diff发现，两个版本的IR代码唯一区别就是初始数值不一样，其他的逻辑都是一模一样的：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/brace-equal-initializer-diff-mem-initializer.webp"></p>
<h2 id="变量模板的特化"><a href="#变量模板的特化" class="headerlink" title="变量模板的特化"></a>变量模板的特化</h2><p>求和:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> EndPoint&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> NUM = NUM&lt;EndPoint<span class="number">-1</span>&gt; + EndPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> NUM&lt;<span class="number">0</span>&gt; = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;NUM&lt;<span class="number">100</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>斐波那契第N项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> EndPoint&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Fibonacci = Fibonacci&lt;EndPoint<span class="number">-1</span>&gt; + Fibonacci&lt;EndPoint<span class="number">-2</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Fibonacci&lt;<span class="number">1</span>&gt; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Fibonacci&lt;<span class="number">2</span>&gt; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;Fibonacci&lt;<span class="number">7</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大支持的参数取决于编译器的最大递归深度，Clang可以通过<code>-ftemplate-depth=N</code>来指定。</p>
<blockquote>
<p>note: use -ftemplate-depth=N to increase recursive template instantiation depth</p>
</blockquote>
<h2 id="What-is-the-Object-in-C-C"><a href="#What-is-the-Object-in-C-C" class="headerlink" title="What is the Object in C/C++?"></a>What is the Object in C/C++?</h2><p>首先先说C++中的**对象(object)**：<br>在一些教材中，会刻意渲染C++中的对象就是面向对象(object-oriented)，这里的对象是类对象(class Object)，但是C++标准规定的Object并不是这么狭隘的概念，C++里占用存储空间即对象(函数除外。</p>
<blockquote>
<p>**[ISO/IEC 14882:2014 §1.8]**An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do.——end note ] An object is created by a definition (3.1), by a new-expression (5.3.4) or by the implementation (12.2) when needed.</p>
</blockquote>
<p>有些人说C++里只有class object是对象，这是很狭隘的观点，如果只有class object才能叫对象，那么该怎么描述built-in type的实例？而且class本身也就是要提供和built-in type相同的操作方式，类型的实体统一叫做**对象(Object)**才是恰当的。</p>
<blockquote>
<p>**[ISO/IEC 14882:2014 §1.8]**An object can have a name (Clause 3). An object has a storage duration (3.7) which influences its lifetime (3.8). An object has a type (3.9). The term object type refers to the type with which the object is created.</p>
</blockquote>
<p>如果从面向对象(object-oriented)理论的<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>这个角度来说，确实只有class object是这个语境下的对象，不过C++标准的对象模型是存储及对象(An object is a region of storage)。</p>
<p>C语言中的<strong>对象(object)**概念与C++中类似，也是</strong>存储即对象**：</p>
<blockquote>
<p>[ISO/IEC 9899:1999 §3.14]region of data storage in the execution environment, the contents of which can represent values</p>
</blockquote>
<h2 id="C-模板必须提供声明和定义的原因"><a href="#C-模板必须提供声明和定义的原因" class="headerlink" title="C++模板必须提供声明和定义的原因"></a>C++模板必须提供声明和定义的原因</h2><p>因为在C++中使用模板会产生新的类型，而只有在当前使用模板的翻译单元会产生(因为编译器只会推导当前翻译单元的模板)。如果模板和声明和定义分离，使用模板时产生了一个符号(类型)，则编译器就会去查找该符号的定义，那么问题来了，如果模板的定义在其他的翻译单元，编译器的手伸不到，怎么在一个翻译单元产生一个符号的声明，而让另一个翻译单元也同样产生一个相同符号的定义呢？是因为编译器直到使用模板的确切地点才能<br>知道用哪些模板实参来实例化它。结果就是会产生链接错误。<br>所以，模板必须要同时提供声明和定义，才会使模板推导出的符号声明和定义会一致生成(把模板当成内联代码更容易理解)。</p>
<p>C++历史上(C++03)曾经允许过模板的分离编译(使用<code>export</code>)，但是这个特性在C++11之后就废除掉了，一是其局限性太大(并不像普通的提供声明-定义的分离式编译那样，编译时仍需要提供代码的实现)，二是其太难实现了(只有一个编译器Comeau实现过)。</p>
<h2 id="VS修改文件编码"><a href="#VS修改文件编码" class="headerlink" title="VS修改文件编码"></a>VS修改文件编码</h2><p>选择<code>Tools</code>-<code>Customize</code>-<code>Commands</code>:<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-customize-file-bar-menu.webp"><br>在<code>File</code>下添加<code>Advanced Save Options</code>选项：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-add-file-bar-advanced-save-options.webp"><br>然后打开文本文件时就可以在VS的菜单<code>File</code>下看到<code>Advanced Save Options</code>选项了:<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/vs-file-base-advanced-save-options.webp"><br>或者安装插件<a target="_blank" rel="noopener" href="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/VS/ForceUTF8(NoBOM).vsix">ForceUTF8(NoBOM)</a></p>
<blockquote>
<p>PS:最好代码都使用Unicode编码，避免编码问题造成奇奇怪怪的编译错误。</p>
</blockquote>
<h2 id="C-模板特化实例的static成员"><a href="#C-模板特化实例的static成员" class="headerlink" title="C++模板特化实例的static成员"></a>C++模板特化实例的static成员</h2><p>每个从模板类特化出的<strong>类模板特化实例</strong>都具有自己单独的static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="type">static</span> T StaticMem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T A&lt;T&gt;::StaticMem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A&lt;<span class="type">int</span>&gt;::StaticMem=<span class="number">123</span>;</span><br><span class="line">  A&lt;<span class="type">float</span>&gt;::StaticMem=<span class="number">4.56</span>;</span><br><span class="line">  A&lt;<span class="type">char</span>&gt;::StaticMem=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[ISO/IEC 14882:2014 § 14.7]Each class template specialization instantiated from a template has its own copy of any static members.</p>
</blockquote>
<h2 id="this不能用在函数默认参数的原因"><a href="#this不能用在函数默认参数的原因" class="headerlink" title="this不能用在函数默认参数的原因"></a>this不能用在函数默认参数的原因</h2><p><strong>注意：成员函数(this传递)实现是Implementation-define的。</strong><br>在我之前的文章中写道过，C++的成员函数与普通的函数之间的区别是具有隐式的this指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他们的区别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ::func</span><br><span class="line">// name mangling as void @_Z4funcv()</span><br><span class="line">void func()&#123;&#125;</span><br><span class="line">// A::func</span><br><span class="line">// name mangling as void @_ZN1A4funcEv(%class.A* %6)</span><br><span class="line">void func(A*)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>本质上来说，成员函数的调用就是将<strong>当前对象的地址</strong>作为实参传递给<strong>函数形参this</strong>。<br>之所以不能够在成员函数的默认实参使用this则因为，在C++中函数参数的求值顺序是不一定的:</p>
<blockquote>
<p>[<strong>ISO/IEC 14882:2014 §8.3.6.9</strong>]A default argument is evaluated each time the function is called with no argument for the corresponding parameter. The order of evaluation of function arguments is unspeciﬁed. Consequently, parameters of a function shall not be used in a default argument, even if they are not evaluated. Parameters of a function declared before a default argument are in scope and can hide namespace and class member names.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = a)</span></span>; <span class="comment">// error: parameter a used as default argument</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> I;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">float</span> I, <span class="type">int</span> b = I(<span class="number">2</span>))</span></span>; <span class="comment">// error: parameter I found</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="keyword">sizeof</span>(a))</span></span>; <span class="comment">// error, parameter a used in default argument</span></span><br></pre></td></tr></table></figure>
<p>因为上面的分析我们已经知道了，this指针实际就是函数的形参，所以如果允许this作为函数形参的默认参数，则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A* this_copy=<span class="keyword">this</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现上等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A_func</span><span class="params">(A* <span class="keyword">this</span>,A* this_copy=<span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样的写法就是一个形参的默认实参依赖于另一个形参，因为函数形参的传递是没有顺序的，所以不能在默认参数中使用this.<br>标准的规则是相通的，一个规则适用在这里，必然也会在另一个地方也会受到限制。</p>
<h2 id="萃取数组的元素个数"><a href="#萃取数组的元素个数" class="headerlink" title="萃取数组的元素个数"></a>萃取数组的元素个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABSL_ARRAYSIZE(array) (sizeof(ArraySizeHelper(array)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ArraySizeHelper</span><span class="params">(<span class="type">const</span> T (&amp;array)[N])</span>-&gt;<span class="title">char</span> <span class="params">(&amp;)</span>[N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> array[<span class="number">123</span>];</span><br><span class="line">  std::cout&lt;&lt;<span class="built_in">ABSL_ARRAYSIZE</span>(array)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 123</span></span><br></pre></td></tr></table></figure>

<h2 id="Bin2Hex"><a href="#Bin2Hex" class="headerlink" title="Bin2Hex"></a>Bin2Hex</h2><p>我写了一个小工具，把二进制文件转换为hex数据的，思路就是对二进制文件逐字节地读取然后写入一个字符串中：</p>
<script src="//gist.github.com/9019a284ae9b6cfa1436414e04145d59.js"></script>

<p><a target="_blank" rel="noopener" href="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/bin2hex.7z">下载bin2hex</a>，用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin2hex.exe FileName</span></span><br><span class="line">$ ./bin2hex.exe Icon.ico</span><br></pre></td></tr></table></figure>
<p>会在当前目录下产生一个<code>Icon_ico.h</code>文件，记录着<code>Icon.ico</code>的二进制数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Icon_ico.h</span></span><br><span class="line"><span class="comment">// origin file: Icon.ico</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">  Icon_ico_data[]=</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0a</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x28</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xa6</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x05</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xce</span>,<span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x36</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0xe8</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x9e</span>,<span class="number">0x0b</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xa8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x86</span>,<span class="number">0x0e</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0xa8</span>,<span class="number">0x10</span>,</span><br><span class="line">    <span class="comment">// something...</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在使用的时候，将这个字符数组内的数据以二进制模式写入文件即可恢复源文件(逐字节地写入文件)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hex2bin.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Icon_ico.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE* loadFP=<span class="built_in">fopen</span>(<span class="string">&quot;Icon.ico&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="built_in">fwrite</span>(Icon_ico_data,<span class="built_in">sizeof</span>(Icon_ico_data),<span class="number">1</span>,loadFP);</span><br><span class="line">  <span class="built_in">fclose</span>(loadFP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在写Console程序时，编译进去一些资源很有用。</p>
<h2 id="C读写二进制文件"><a href="#C读写二进制文件" class="headerlink" title="C读写二进制文件"></a>C读写二进制文件</h2><p>读：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=<span class="built_in">fopen</span>(rFileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> FileItem=<span class="number">0</span>;(fileItem=<span class="built_in">getc</span>(fp))!=EOF;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>,fileItem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure>

<p>写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">  Data[]=</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">0x89</span>,<span class="number">0x50</span>,<span class="number">0x4e</span>,<span class="number">0x47</span>,<span class="number">0x0d</span>,<span class="number">0x0a</span>,<span class="number">0x1a</span>,<span class="number">0x0a</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0d</span>,</span><br><span class="line">    <span class="number">0x49</span>,<span class="number">0x48</span>,<span class="number">0x44</span>,<span class="number">0x52</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">FILE* loadFP=<span class="built_in">fopen</span>(wFileName,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(Data,<span class="built_in">sizeof</span>(Data),<span class="number">1</span>,loadFP);</span><br><span class="line"><span class="built_in">fclose</span>(loadFP);</span><br></pre></td></tr></table></figure>

<h2 id="GNU扩展：struct初始化-first-…-last"><a href="#GNU扩展：struct初始化-first-…-last" class="headerlink" title="GNU扩展：struct初始化[first … last]"></a>GNU扩展：struct初始化[first … last]</h2><p>GNU的扩展支持以下这样一种结构初始化的写法(<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html#Designated-Inits">Designated-Inits</a>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NUM 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> ival;<span class="type">double</span> dval; &#125; DataList[ARRAY_NUM] =&#123; [<span class="number">0</span> ... ARRAY_NUM<span class="number">-1</span>].ival = <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是对DataList内的所有元素的ival成员初始化为2.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NUM 5</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> &#123; <span class="type">int</span> ival;<span class="type">double</span> dval; &#125; DataList[ARRAY_NUM] =&#123; [<span class="number">0</span> ... ARRAY_NUM<span class="number">-1</span>].ival = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> index=<span class="number">0</span>;index&lt;ARRAY_NUM;++index)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,DataList[index].ival);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2</span>       <span class="number">2</span>       <span class="number">2</span>       <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>虽然说也可以使用一个循环赋值来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NUM 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> ival;<span class="type">double</span> dval; &#125; DataList[ARRAY_NUM];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> index=<span class="number">0</span>;index&lt;ARRAY_NUM;++index)</span><br><span class="line">    DataList[index].ival=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是比较二者的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">###############################</span><br><span class="line">##define ARRAY_NUM 5</span><br><span class="line">#int main(void)</span><br><span class="line">#&#123;</span><br><span class="line">#  struct &#123; int ival;double dval; &#125; DataList[ARRAY_NUM];</span><br><span class="line">#</span><br><span class="line">#  for(int index=0;index&lt;ARRAY_NUM;++index)</span><br><span class="line">#    DataList[index].ival=2;</span><br><span class="line">#&#125;</span><br><span class="line">###############################</span><br><span class="line">  .text</span><br><span class="line">  .def   main;</span><br><span class="line">  .scl  2;</span><br><span class="line">  .type 32;</span><br><span class="line">  .endef</span><br><span class="line">  .globl  main                    # -- Begin function main</span><br><span class="line">  .p2align  4, 0x90</span><br><span class="line">main:                                   # @main</span><br><span class="line">.seh_proc main</span><br><span class="line"># %bb.0:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  .seh_pushreg 5</span><br><span class="line">  subq  $144, %rsp</span><br><span class="line">  .seh_stackalloc 144</span><br><span class="line">  leaq  128(%rsp), %rbp</span><br><span class="line">  .seh_setframe 5, 128</span><br><span class="line">  .seh_endprologue</span><br><span class="line">  callq __main</span><br><span class="line">  movl  $0, 12(%rbp)</span><br><span class="line">  movl  $0, -84(%rbp)</span><br><span class="line">.LBB0_1:                                # =&gt;This Inner Loop Header: Depth=1</span><br><span class="line">  cmpl  $5, -84(%rbp)</span><br><span class="line">  jge .LBB0_4</span><br><span class="line"># %bb.2:                                #   in Loop: Header=BB0_1 Depth=1</span><br><span class="line">  movslq  -84(%rbp), %rax</span><br><span class="line">  shlq  $4, %rax</span><br><span class="line">  leaq  -80(%rbp), %rcx</span><br><span class="line">  addq  %rax, %rcx</span><br><span class="line">  movl  $2, (%rcx)</span><br><span class="line"># %bb.3:                                #   in Loop: Header=BB0_1 Depth=1</span><br><span class="line">  movl  -84(%rbp), %eax</span><br><span class="line">  addl  $1, %eax</span><br><span class="line">  movl  %eax, -84(%rbp)</span><br><span class="line">  jmp .LBB0_1</span><br><span class="line">.LBB0_4:</span><br><span class="line">  xorl  %eax, %eax</span><br><span class="line">  addq  $144, %rsp</span><br><span class="line">  popq  %rbp</span><br><span class="line">  retq</span><br><span class="line">  .seh_handlerdata</span><br><span class="line">  .text</span><br><span class="line">  .seh_endproc</span><br><span class="line">                                        # -- End function</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">###############################</span><br><span class="line">##define ARRAY_NUM 5</span><br><span class="line">#int main(int argc,char* argv[])</span><br><span class="line">#&#123;</span><br><span class="line">#  struct &#123; int ival;double dval; &#125; DataList[ARRAY_NUM] =&#123; [0 ... ARRAY_NUM-1].ival = 2 &#125;;</span><br><span class="line">#&#125;</span><br><span class="line">###############################</span><br><span class="line">  .text</span><br><span class="line">  .def   main;</span><br><span class="line">  .scl  2;</span><br><span class="line">  .type 32;</span><br><span class="line">  .endef</span><br><span class="line">  .globl  main                    # -- Begin function main</span><br><span class="line">  .p2align  4, 0x90</span><br><span class="line">main:                                   # @main</span><br><span class="line">.seh_proc main</span><br><span class="line"># %bb.0:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  .seh_pushreg 5</span><br><span class="line">  subq  $128, %rsp</span><br><span class="line">  .seh_stackalloc 128</span><br><span class="line">  leaq  128(%rsp), %rbp</span><br><span class="line">  .seh_setframe 5, 128</span><br><span class="line">  .seh_endprologue</span><br><span class="line">  callq __main</span><br><span class="line">  xorl  %eax, %eax</span><br><span class="line">  movl  $80, %ecx</span><br><span class="line">  movl  %ecx, %r8d</span><br><span class="line">  leaq  -80(%rbp), %rdx</span><br><span class="line">  movq  %rdx, %rcx</span><br><span class="line">  movl  %eax, %edx</span><br><span class="line">  movl  %eax, -84(%rbp)         # 4-byte Spill</span><br><span class="line">  callq memset</span><br><span class="line">  movl  $2, -80(%rbp)</span><br><span class="line">  movl  $2, -64(%rbp)</span><br><span class="line">  movl  $2, -48(%rbp)</span><br><span class="line">  movl  $2, -32(%rbp)</span><br><span class="line">  movl  $2, -16(%rbp)</span><br><span class="line">  movl  -84(%rbp), %eax         # 4-byte Reload</span><br><span class="line">  addq  $128, %rsp</span><br><span class="line">  popq  %rbp</span><br><span class="line">  retq</span><br><span class="line">  .seh_handlerdata</span><br><span class="line">  .text</span><br><span class="line">  .seh_endproc</span><br><span class="line">                                        # -- End function</span><br></pre></td></tr></table></figure>
<p>可以看到，直接初始化的效率更高，不过从“可读性”(毕竟它不是标准C)和“可移植”的角度看，还是写个循环赋值靠谱一点。</p>
<h2 id="static成员初始化可以访问private成员"><a href="#static成员初始化可以访问private成员" class="headerlink" title="static成员初始化可以访问private成员"></a>static成员初始化可以访问private成员</h2><p>C++的static成员初始化是可以访问类的私有成员的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">process</span> &#123;</span><br><span class="line">  <span class="type">static</span> process* run_chain;</span><br><span class="line">  <span class="type">static</span> process* running;</span><br><span class="line">&#125;;</span><br><span class="line">process* process::running = <span class="built_in">get_main</span>();</span><br><span class="line">process* process::run_chain = running;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[ISO/IEC 14882:2014 §9.4.2]The static data member run_chain of class process is defined in global scope; the notation process ::run_chain specifies that the member run_chain is a member of class process and <strong>in the scope of class process</strong>. In the static data member definition, the initializer expression refers to the static data member running of class process. — end example ]</p>
</blockquote>
<h2 id="的用法"><a href="#的用法" class="headerlink" title="!!的用法"></a>!!的用法</h2><p>看到<code>!</code>的这样一个用法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ival=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,!!ival);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用是如果<code>ival</code>是0，则<code>!!ival</code>的值是0，<code>ival</code>非0，则结果为1.</p>
<p>以下是两份代码的IR对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line">	<span class="type">bool</span> a = (<span class="type">bool</span>)ival;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IR</span></span><br><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">0</span> &#123;</span><br><span class="line">entry:</span><br><span class="line">  %ival = alloca i32, align <span class="number">4</span></span><br><span class="line">  %a = alloca i8, align <span class="number">1</span></span><br><span class="line">  store i32 <span class="number">11</span>, i32* %ival, align <span class="number">4</span></span><br><span class="line">  %<span class="number">0</span> = load i32, i32* %ival, align <span class="number">4</span></span><br><span class="line">  %tobool = icmp ne i32 %<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  %frombool = zext i1 %tobool to i8</span><br><span class="line">  store i8 %frombool, i8* %a, align <span class="number">1</span></span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>!!</code>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line">	<span class="type">bool</span> a = !!ival;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IR</span></span><br><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">0</span> &#123;</span><br><span class="line">entry:</span><br><span class="line">  %ival = alloca i32, align <span class="number">4</span></span><br><span class="line">  %a = alloca i8, align <span class="number">1</span></span><br><span class="line">  store i32 <span class="number">11</span>, i32* %ival, align <span class="number">4</span></span><br><span class="line">  %<span class="number">0</span> = load i32, i32* %ival, align <span class="number">4</span></span><br><span class="line">  %tobool = icmp ne i32 %<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  %lnot = <span class="keyword">xor</span> i1 %tobool, <span class="literal">true</span></span><br><span class="line">  %lnot1 = <span class="keyword">xor</span> i1 %lnot, <span class="literal">true</span></span><br><span class="line">  %frombool = zext i1 %lnot1 to i8</span><br><span class="line">  store i8 %frombool, i8* %a, align <span class="number">1</span></span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言中的枚举就是整型"><a href="#C语言中的枚举就是整型" class="headerlink" title="C语言中的枚举就是整型"></a>C语言中的枚举就是整型</h2><blockquote>
<p>**[ISO/IEC 9899:1999 §6.4.4.4.2]**An identifier declared as an enumeration constant has type int.</p>
</blockquote>
<blockquote>
<p>**[ISO/IEC 9899:1999 §6.7.2.2.3]**The identifiers in an enumerator list are declared as constants that have type int and may appear wherever such are permitted.</p>
</blockquote>
<p>注：C++与C不同，C++的枚举是单独的类型，详见[ISO/IEC 14882:2014 C.16 Clause7]。</p>
<h2 id="C-中纯虚函数不能够提供定义"><a href="#C-中纯虚函数不能够提供定义" class="headerlink" title="C++中纯虚函数不能够提供定义"></a>C++中纯虚函数不能够提供定义</h2><blockquote>
<p>**[ISO/IEC 14882:2014 §10.4]**A function declaration cannot provide both a pure-specifier and a definition.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span> &#123; &#125;; <span class="comment">// ill-formed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="正则匹配C函数声明"><a href="#正则匹配C函数声明" class="headerlink" title="正则匹配C函数声明"></a>正则匹配C函数声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([\w\*]+( )*?)&#123;2,&#125;\(([^!@#$+%^;]+?)\)(?!\s*;)</span><br></pre></td></tr></table></figure>
<p>来源：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/476173/regex-to-pull-out-c-function-prototype-declarations/45866339#45866339">Regex to pull out C function prototype declarations?</a></p>
<h2 id="C语言中聚合结构的初始化"><a href="#C语言中聚合结构的初始化" class="headerlink" title="C语言中聚合结构的初始化"></a>C语言中聚合结构的初始化</h2><p>C语言的聚合结构还有这种方式的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> a;<span class="type">float</span> b; &#125; x =&#123; .a = <span class="number">2</span>,.b = <span class="number">2.2</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> a[<span class="number">3</span>], b; &#125; w[] =&#123; [<span class="number">1</span>].a[<span class="number">0</span>] = <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>这是因为inielizer的designator可以是<code>[constant-expression]</code>和<code>.identifier</code>.<br>PS:<code>sizeof(w) == ?</code>是个有趣的问题。<br>详情请看**[ISO/IEC 9899:1999 §6.7.8]**.</p>
<h2 id="通过函数指针进行函数调用不可以使用默认参数"><a href="#通过函数指针进行函数调用不可以使用默认参数" class="headerlink" title="通过函数指针进行函数调用不可以使用默认参数"></a>通过函数指针进行函数调用不可以使用默认参数</h2><p>如题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">123</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">void</span>(*fp)(<span class="type">int</span>)=func;</span><br><span class="line">  <span class="built_in">fp</span>(); <span class="comment">// error: too few arguments to function call, expected 1, have 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看一下函数的默认参数是在何时被填充上去的，老样子还是看LLVM-IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">123</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ival);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其main函数的LLVM-IR代码为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @<span class="built_in">main</span>() #<span class="number">6</span> &#123;</span><br><span class="line">  call <span class="type">void</span> @_Z4funci(i32 <span class="number">123</span>)</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在编译时通过代码分析直接把省略掉的参数用默认值给补上了。<br>函数指针只具有函数的地址值，不包含任何的实参信息，也就不能在函数指针的访问里使用默认参数咯。<br>注：成员函数指针也同理。</p>
<h2 id="unspecified-behavior"><a href="#unspecified-behavior" class="headerlink" title="unspecified behavior"></a>unspecified behavior</h2><blockquote>
<p>behavior, for a well-formed program construct and correct data, that depends on the implementation.[ Note: The implementation is not required to document which behavior occurs. The range of possible behaviors is usually delineated by this International Standard. — end note ]</p>
</blockquote>
<h2 id="well-formed-program"><a href="#well-formed-program" class="headerlink" title="well-formed program"></a>well-formed program</h2><blockquote>
<p>[<strong>ISO/IEC 14882:2014 §1.3.26</strong>]C++ program constructed according to the syntax rules, diagnosable semantic rules, and the One Definition<br>Rule (3.2).</p>
</blockquote>
<h2 id="Implementation-Define-实现定义行为"><a href="#Implementation-Define-实现定义行为" class="headerlink" title="Implementation-Define(实现定义行为)"></a>Implementation-Define(实现定义行为)</h2><blockquote>
<p>[<strong>ISO/IEC 14882:2014</strong>]behavior, for a well-formed program construct and correct data, that depends on the implementation and that each implementation documents</p>
</blockquote>
<h2 id="UB-未定义行为"><a href="#UB-未定义行为" class="headerlink" title="UB(未定义行为)"></a>UB(未定义行为)</h2><blockquote>
<p>[<strong>ISO/IEC 14882:2014 §1.9.4</strong>]This International Standard imposes no requirements on the behavior of programs that contain undefined behavior.<br>[<strong>ISO/IEC 14882:2014 §1.3.24</strong>]behavior for which this International Standard imposes no requirements [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior or when a program uses an erroneous construct or erroneous data. Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed. — end note ]</p>
</blockquote>
<p>这意味着具有UB的程序的行为不可预测，什么情况都有可能发生。</p>
<h2 id="关于注入类名字-injected-class-name-的问题"><a href="#关于注入类名字-injected-class-name-的问题" class="headerlink" title="关于注入类名字(injected-class-name)的问题"></a>关于注入类名字(injected-class-name)的问题</h2><p>首先要先了解一下什么叫做<code>注入类名字(injected-class-name)</code>:</p>
<blockquote>
<p>[<strong>ISO/IEC 14882:2014(E) §9.0.2</strong>]The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name. For purposes of access checking, the injected-class-name is treated as if it were a public member name.</p>
</blockquote>
<p>意思就是类的名字被嵌入到类的作用域中，<strong>为了访问检查的目的，注入类名称被视为public成员</strong>(注意这一句)。<br>其实对注入类名字的声明类似于下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 模仿注入类名字</span></span><br><span class="line">  <span class="keyword">using</span> AType=A;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="comment">// A::AType aobj;</span></span><br><span class="line">  AType* aobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类内的名字查找是先从当前作用域开始的，注入类名字被在继承层次中看的更明显一些：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="comment">// 等价于A aobj;</span></span><br><span class="line">  <span class="comment">// 但与::A aobj;有区别</span></span><br><span class="line">  B::A aobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上面的代码所示，可以使用<code>B::A</code>来限定B继承层次的类型<code>A</code>.<br>上面描述的内容中写到，注入类名字被视为public成员，但是如果我们在继承层次中把基类标记为了<code>private</code>，会怎样？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">  A* p0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一下代码看一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">injected-class-name.cpp:4:3: error: <span class="string">&#x27;A&#x27;</span> is a private member of <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  A* p0;</span><br><span class="line">  ^</span><br><span class="line">injected-class-name.cpp:2:11: note: constrained by private inheritance here</span><br><span class="line">class B : private A &#123; &#125;;</span><br><span class="line">          ^~~~~~~~~</span><br><span class="line">injected-class-name.cpp:1:7: note: member is declared here</span><br><span class="line">class A &#123; &#125;;</span><br><span class="line">      ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<p>那我们使用<code>B::A</code>或者<code>C::A</code>呢？同样也会具有一样的错误。</p>
<p>因为在派生类中对基类名字的名字查找(name lookup)找到的是注入类名字(injected-class-name)：</p>
<blockquote>
<p>**[ISO/IEC 14882:2014(E) §11.1.5]**In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of the base class in the scope in which it was declared.</p>
</blockquote>
<p>要解决这样的问题，要限定名字空间(上面的例子要改为<code>::A</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">  ::A* p0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在namespace的scope内一定要注意默认的名字查找(name-lookup)是有namespace限定的。</p>
</blockquote>
<h2 id="一个要抠字眼的C-问题"><a href="#一个要抠字眼的C-问题" class="headerlink" title="一个要抠字眼的C++问题"></a>一个要抠字眼的C++问题</h2><p>问：<strong>派生类的对象</strong>对他的基类成员中()是可以访问的？<br>A) 公有继承的公有成员<br>B) 公有继承的私有成员<br>C) 公有继承的保护成员<br>D) 私有继承的公有成员</p>
<p>乍一看，继承层次下的派生类使用<code>public</code>/<code>protected</code>/<code>private</code>都可以访问基类的<code>public</code>/<code>private</code>成员啊，貌似ACD都对。<br>但是，注意问题里写的是<strong>对象</strong>，对象只能够访问类的public成员，所以我在问题里加粗了:)。</p>
<h2 id="reintrtpret-cast的转换-位模式的转换"><a href="#reintrtpret-cast的转换-位模式的转换" class="headerlink" title="reintrtpret_cast的转换(位模式的转换)"></a>reintrtpret_cast的转换(位模式的转换)</h2><h3 id="指针到整型的转换"><a href="#指针到整型的转换" class="headerlink" title="指针到整型的转换"></a>指针到整型的转换</h3><p>指针能够显式转换为任何足够容纳它的整型，但是映射函数是<strong>实现定义(implementation-define)**的。<br>类型<code>std::nullptr_t</code>的值能够转换到整型，该转换与转换<code>(void*)0</code>到整型具有相同的意义与合法性。<br>**注</strong>：<code>reinterpret_cast</code>不能用在转换任何类型的值到<code>std::nullptr_t</code>.</p>
<blockquote>
<p>*<em>[ISO/IEC 14882:2014 §5.2.10.4]**A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined. [ Note: It is intended to be unsurprising to those who know the addressing structure of the underlying machine. — end note ] A value of type std::nullptr_t can be converted to an integral type; the conversion has the same meaning and validity as a conversion of (void</em>)0 to the integral type. [ Note: A reinterpret_cast cannot be used to convert a value of any type to the type std::nullptr_t. — end note ]</p>
</blockquote>
<h3 id="整型到指针的转换"><a href="#整型到指针的转换" class="headerlink" title="整型到指针的转换"></a>整型到指针的转换</h3><p>整型或枚举类型能够显式转换到指针。指针转换到足够大小的整型并且再转换会相同的指针类型，它将会具有源指针值。<br>这意味着该转换不具有未定义行为(指针与整型之间映射在其他方面是实现定义的)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用c++编译器编译</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> ival=<span class="number">123</span>;</span><br><span class="line">  <span class="type">uint64_t</span> *pval=&amp;ival;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ival address is %x.\n&quot;</span>,&amp;ival);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pval contain address is %x.\n&quot;</span>,pval);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> ui64val=(<span class="type">uint64_t</span>)pval;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cast uint64_t* to uint64_t resault is %x.\n&quot;</span>,ui64val);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> *origVal=(<span class="type">uint64_t</span>*)ui64val;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cast uint64_t to uint64_t* resault is %x.\n&quot;</span>,origVal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">ival address is <span class="number">61f</span>e38.</span><br><span class="line">pval contain address is <span class="number">61f</span>e38.</span><br><span class="line">cast <span class="type">uint64_t</span>* to <span class="type">uint64_t</span> resault is <span class="number">61f</span>e38.</span><br><span class="line">cast <span class="type">uint64_t</span> to <span class="type">uint64_t</span>* resault is <span class="number">61f</span>e38.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**[ISO/IEC 14882:2014 §5.2.10.5]**A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation-defined. [ Note: Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer value. — end note ]</p>
</blockquote>
<h3 id="函数指针的转换"><a href="#函数指针的转换" class="headerlink" title="函数指针的转换"></a>函数指针的转换</h3><p>函数指针能够显示转换到不同类型的函数指针，调用转换后的函数类型的效果与函数定义中的函数不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call func,the ival param is %d\n&quot;</span>,ival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">void</span>(*func_i)(<span class="type">int</span>)=func;</span><br><span class="line">  <span class="built_in">void</span>(*func_i_d)(<span class="type">int</span>,<span class="type">double</span>)=<span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">double</span>)&gt;(func_i);</span><br><span class="line">  <span class="built_in">func_i_d</span>(<span class="number">123</span>,<span class="number">45.6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非转换类型<code>pointer to T1</code>到<code>pointer to T2</code>(T1和T2是函数类型)，并且转换回它的源类型产生源指针值，这样的指针转换的结果是未指定的(<code>unspecified</code>).</p>
<blockquote>
<p>**[ISO/IEC 14882:2014 §5.2.10.6]**A function pointer can be explicitly converted to a function pointer of a diﬀerent type. The eﬀect of calling a function through a pointer to a function type (8.3.5) that is not the same as the type used in the definition of the function is undefined. Except that converting a prvalue of type “pointer to T1” to the type “pointer to T2” (where T1 and T2 are function types) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified. [ Note: see also 4.10 for more details of pointer conversions. — end note ]</p>
</blockquote>
<h2 id="offsetof不能用在非POD类型-Standard-Layout"><a href="#offsetof不能用在非POD类型-Standard-Layout" class="headerlink" title="offsetof不能用在非POD类型(Standard Layout)"></a>offsetof不能用在非POD类型(Standard Layout)</h2><p><code>offsetof</code>是定义在<code>stddef.h</code>/<code>cstddef</code>中的一个宏，其作用是获取结构成员在结构上的偏移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> pad7[<span class="number">7</span>];</span><br><span class="line">  <span class="type">int</span> ival;</span><br><span class="line">  <span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A::ival offset is %d\n&quot;</span>,<span class="built_in">offsetof</span>(A, ival));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A::dval offset is %d\n&quot;</span>,<span class="built_in">offsetof</span>(A, dval));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">A::ival offset is <span class="number">8</span></span><br><span class="line">A::dval offset is <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>但是它不能够用在非<strong>Standard Layout Class</strong>的类型上，否则是undefine behavior的：</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014 §18.2.4]</strong>:The macro offsetof(type, member-designator) accepts a restricted set of type arguments in this International Standard. **If type is not a standard-layout class (Clause 9), the results are undefined.**The expression offsetof(type, member-designator) is never type-dependent (14.6.2.2) and it is value-dependent (14.6.2.3) if and only if type is dependent. The result of applying the offsetof macro to a field that is a static data member or a function member is undefined. No operation invoked by the offsetof macro shall throw an exception and noexcept(offsetof(type, member-designator)) shall be true.<br><em>Note that offsetof is required to work as specified even if unary operator&amp; is overloaded for any of the types involved.</em></p>
</blockquote>
<p>顺便再来复习一下什么叫<code>Standard Layout types</code>：</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014 §3.9.9]</strong>:<strong>Scalar types</strong>, <strong>standard-layout class types</strong> (Clause 9), <strong>arrays</strong> of such types and cv-qualified versions of these types (3.9.3) are collectively called <strong>standard-layout types</strong>.</p>
</blockquote>
<p>而<code>Standard Layout Class</code>则又是：<br>A <strong>standard-layout class</strong> is a class that:</p>
<ul>
<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>
<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>
<li>has the same access control (Clause 11) for all non-static data members,</li>
<li>has no non-standard-layout base classes,</li>
<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>
<li>has no base classes of the same type as the first non-static data member.</li>
</ul>
<p>即，在类中有这些的都是非标准布局类，offsetof不能用在他们上面。</p>
<h2 id="C-中的Standard-Layout-types"><a href="#C-中的Standard-Layout-types" class="headerlink" title="C++中的Standard Layout types"></a>C++中的Standard Layout types</h2><p>顺便再来复习一下什么叫<code>Standard Layout types</code>：</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014 §3.9.9]</strong>:<strong>Scalar types</strong>, <strong>standard-layout class types</strong> (Clause 9), <strong>arrays</strong> of such types and cv-qualified versions of these types (3.9.3) are collectively called <strong>standard-layout types</strong>.</p>
</blockquote>
<p>而<code>Standard Layout Class</code>则又是：<br>A <strong>standard-layout class</strong> is a class that:</p>
<ul>
<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>
<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>
<li>has the same access control (Clause 11) for all non-static data members,</li>
<li>has no non-standard-layout base classes,</li>
<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>
<li>has no base classes of the same type as the first non-static data member.</li>
</ul>
<h2 id="在基类子对象内对this指针做放置new操作"><a href="#在基类子对象内对this指针做放置new操作" class="headerlink" title="在基类子对象内对this指针做放置new操作"></a>在基类子对象内对this指针做放置new操作</h2><p>这么做是UB的，直接看标准里的代码吧(<code>[ISO/IEC 14882:2014 §3.8.5]</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mutate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">B</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::mutate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="keyword">this</span>) D2; <span class="comment">// reuses storage — ends the lifetime of *this</span></span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// undefined behavior</span></span><br><span class="line">  ... = <span class="keyword">this</span>; <span class="comment">// OK, this points to valid memory</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(D1) + <span class="built_in">sizeof</span>(D2));</span><br><span class="line">  B* pb = <span class="built_in">new</span> (p) D1;</span><br><span class="line">  pb-&gt;<span class="built_in">mutate</span>();</span><br><span class="line">  &amp;pb; <span class="comment">// OK: pb points to valid memory</span></span><br><span class="line">  <span class="type">void</span>* q = pb; <span class="comment">// OK: pb points to valid memory</span></span><br><span class="line">  pb-&gt;<span class="built_in">f</span>(); <span class="comment">// undefined behavior, lifetime of *pb has ended</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this的生命周期的终结时机为调用析构函数之后，调用析构函数则意味着该类内的所有数据均变成了无意义的存在，对无意义的东西做操作是UB行为。</p>
<h2 id="MinGW-W64编译32位程序"><a href="#MinGW-W64编译32位程序" class="headerlink" title="MinGW-W64编译32位程序"></a>MinGW-W64编译32位程序</h2><p><code>GCC</code>支持<code>-m32</code>参数来将代码编译到32位程序。但是如果你的MinGW是SEH或者DWARF的异常模型，则他们是单一平台的，不支持编译到32位程序。<br>在<a target="_blank" rel="noopener" href="https://stackoverflow.com/">stackoverflow</a>上有个回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19690504/how-do-i-compile-and-link-a-32-bit-windows-executable-using-mingw-w64">How do I compile and link a 32-bit Windows executable using mingw-w64</a><br>还有CSDN上的一个问题：<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/391866590">MinGW-w64如何编译32位程序</a><br>解决办法：可以选择<code>SJLJ</code>的异常模型版本，可以从<a target="_blank" rel="noopener" href="https://qa.debian.org/watch/sf.php/mingw-w64">这里</a>检索下载。也可以使用<a target="_blank" rel="noopener" href="http://tdm-gcc.tdragon.net/download">TDM GCC</a>(目前只更新到了MinGW5.1.0)。</p>
<h2 id="C语言的隐式函数声明"><a href="#C语言的隐式函数声明" class="headerlink" title="C语言的隐式函数声明"></a>C语言的隐式函数声明</h2><p>下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hw.c</span></span><br><span class="line"><span class="comment">// 注意没有包含任何头文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc编译，是会编译成功并且可以执行的(具有警告)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hw.c -o hw.exe</span><br><span class="line">test.c: In <span class="keyword">function</span> <span class="string">&#x27;main&#x27;</span>:</span><br><span class="line">test.c:2:5: warning: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;printf&#x27;</span> [-Wimplicit-function-declaration]</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\n&quot;</span>);</span><br><span class="line">     ^~~~~~</span><br><span class="line">test.c:2:5: warning: incompatible implicit declaration of built-in <span class="keyword">function</span> <span class="string">&#x27;printf&#x27;</span></span><br><span class="line">test.c:2:5: note: include <span class="string">&#x27;&lt;stdio.h&gt;&#x27;</span> or provide a declaration of <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么问题来了，我在当前的编译单元内并没有包含<code>printf</code>的声明，怎么就可以编译通过呢？<br>因为C语言的历史上支持过<code>implicit function declaration</code>(C89支持函数的隐式声明):</p>
<blockquote>
<p>[ISO/IEC 9899:1990 6.3.2.2] If the expression that precedes the parenthesized argument list in a function call consists solely of an identifier. and if no declaration is visible for this identifier, the identifier is implicitly declared exactly as if. in the innermost block containing the function call. the declaration</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">idenfifrer</span> <span class="params">()</span> ;</span><br></pre></td></tr></table></figure>
<p>然而这个特性 C99 就废除掉了：</p>
<blockquote>
<p>[ISO/IEC 9899:1999 Foreword] <strong>remove implicit function declaration</strong></p>
</blockquote>
<p>上面的代码相当于：</p>
<ol>
<li>编译器隐式声明了<code>printf</code>函数</li>
<li>链接器默认链接了<code>stdlib</code>，所以才不会产生符号未定义的链接错误</li>
</ol>
<p>在gcc编译器如果不想要默认链接可以使用链接器参数(这里只列出其中的三个)：</p>
<ul>
<li><strong>-nodefaultlibs</strong>: 不使用标准系统库，只有编译参数中指定的库才会传递给链接器</li>
<li><strong>-nostdlib</strong>: Do not use the standard system startup files or libraries when linking.</li>
<li><strong>-nolibc</strong>: Do not use the C library or system libraries tightly coupled with it when linking.</li>
</ul>
<p>更多的gcc链接参数可以看这里：<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html">3.14 Options for Linking</a></p>
<h2 id="Clang查看对象的内存布局"><a href="#Clang查看对象的内存布局" class="headerlink" title="Clang查看对象的内存布局"></a>Clang查看对象的内存布局</h2><p>clang可以在编译时使用<code>-cc1 -fdump-record-layouts</code>参数来查看对象的内存布局。<br>但是使用上面的命令不会从Path路径查找标准头文件，我们需要先对源文件进行预处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ gcc -E main.c -o main_pp.cpp</span><br></pre></td></tr></table></figure>
<p>然后对预处理之后的<code>.cpp</code>文件执行编译时加入<code>-cc1 -fdump-record-layouts</code>参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -cc1 -fdump-record-layouts main_pp.cpp</span><br></pre></td></tr></table></figure>

<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class_layout.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">0</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">123</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">123</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  cobj.<span class="built_in">func</span>();</span><br><span class="line">  B &amp;bobj=cobj;</span><br><span class="line">  bobj.<span class="built_in">func</span>();</span><br><span class="line">  A &amp;aobj=cobj;</span><br><span class="line">  aobj.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -E class_layout.cpp -o class_layout_pp.cpp</span><br></pre></td></tr></table></figure>
<p>查看上面三个类的内存布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -cc1 -fdump-record-layouts class_layout_pp.cpp</span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class A</span><br><span class="line">         0 |   (A vtable pointer)</span><br><span class="line">           | [sizeof=8, dsize=8, align=8,</span><br><span class="line">           |  nvsize=8, nvalign=8]</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class B</span><br><span class="line">         0 |   class A (primary base)</span><br><span class="line">         0 |     (A vtable pointer)</span><br><span class="line">           | [sizeof=8, dsize=8, align=8,</span><br><span class="line">           |  nvsize=8, nvalign=8]</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class C</span><br><span class="line">         0 |   class B (primary base)</span><br><span class="line">         0 |     class A (primary base)</span><br><span class="line">         0 |       (A vtable pointer)</span><br><span class="line">           | [sizeof=8, dsize=8, align=8,</span><br><span class="line">           |  nvsize=8, nvalign=8]</span><br></pre></td></tr></table></figure>

<p>参考文章：<a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/">Dumping a C++ object’s memory layout with Clang</a></p>
<h2 id="虚函数的默认参数根据调用者-指针或引用-的静态类型决定"><a href="#虚函数的默认参数根据调用者-指针或引用-的静态类型决定" class="headerlink" title="虚函数的默认参数根据调用者(指针或引用)的静态类型决定"></a>虚函数的默认参数根据调用者(指针或引用)的静态类型决定</h2><p>之前曾经在<a href="https://imzlp.com/posts/19242/#override%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A%E8%A6%86%E7%9B%96%E5%85%B6%E5%8E%9F%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">C/C++标准的一些摘录#override函数不会覆盖其原有默认参数</a>中曾经写道过这点内容，但是不够详细，这里做一个补充。</p>
<p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;A::func,arg is &quot;</span>&lt;&lt;ival&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">123</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;B::func,arg is &quot;</span>&lt;&lt;ival&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival=<span class="number">456</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;C::func,arg is &quot;</span>&lt;&lt;ival&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  cobj.<span class="built_in">func</span>(); <span class="comment">// print what?</span></span><br><span class="line">  B &amp;bobj=cobj;</span><br><span class="line">  bobj.<span class="built_in">func</span>(); <span class="comment">// print what?</span></span><br><span class="line">  A &amp;aobj=cobj;</span><br><span class="line">  aobj.<span class="built_in">func</span>(); <span class="comment">//print what?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">C::func,arg is <span class="number">456</span></span><br><span class="line">C::func,arg is <span class="number">123</span></span><br><span class="line">C::func,arg is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>C++标准中规定了关于虚函数的默认参数使用描述：</p>
<blockquote>
<p>[ISO/IEC 14882:2014]A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object.</p>
</blockquote>
<p>即，虚函数的默认参数的使用是执行该虚函数调用的指针或引用的静态类型的决定的。<br>从上面的例子来看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  cobj.<span class="built_in">func</span>(); <span class="comment">// 执行虚函数调用的对象的静态类型是C,则本次调用的默认参数是C::func声明的，即456</span></span><br><span class="line">  B &amp;bobj=cobj;</span><br><span class="line">  bobj.<span class="built_in">func</span>(); <span class="comment">// 执行虚函数调用的对象的静态类型是B,则本次调用的默认参数是B::func，即123</span></span><br><span class="line">  A &amp;aobj=cobj;</span><br><span class="line">  aobj.<span class="built_in">func</span>(); <span class="comment">// 执行虚函数调用的对象的静态类型是A,则本次调用的默认参数是A::func，即0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即多态函数的默认参数并不是动态绑定的，并不会在运行时才确定使用继承层次中的哪一个实现的默认参数，而是编译时根据对象的类型就确定了使用哪个默认参数。<br>可以看一下上面代码的LLVM-IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca %<span class="keyword">class</span>.C, align <span class="number">8</span></span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.B*, align <span class="number">8</span></span><br><span class="line">  %<span class="number">3</span> = alloca %<span class="keyword">class</span>.A*, align <span class="number">8</span></span><br><span class="line">  <span class="comment">// class C的构造函数</span></span><br><span class="line">  call <span class="type">void</span> @_ZN1CC2Ev(%<span class="keyword">class</span>.C* %<span class="number">1</span>) #<span class="number">3</span></span><br><span class="line">  <span class="comment">// 直接通过C类型的对象cobj调用func</span></span><br><span class="line">  call <span class="type">void</span> @_ZN1C4funcEi(%<span class="keyword">class</span>.C* %<span class="number">1</span>, i32 <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过B类型的引用bobj用来调用func</span></span><br><span class="line">  %<span class="number">4</span> = bitcast %<span class="keyword">class</span>.C* %<span class="number">1</span> to %<span class="keyword">class</span>.B*</span><br><span class="line">  store %<span class="keyword">class</span>.B* %<span class="number">4</span>, %<span class="keyword">class</span>.B** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">5</span> = load %<span class="keyword">class</span>.B*, %<span class="keyword">class</span>.B** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = bitcast %<span class="keyword">class</span>.B* %<span class="number">5</span> to <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)***</span><br><span class="line">  %<span class="number">7</span> = load <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)**, <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)*** %<span class="number">6</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">8</span> = getelementptr inbounds <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)*, <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)** %<span class="number">7</span>, i64 <span class="number">0</span></span><br><span class="line">  %<span class="number">9</span> = load <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)*, <span class="built_in">void</span> (%<span class="keyword">class</span>.B*, i32)** %<span class="number">8</span>, align <span class="number">8</span></span><br><span class="line">  <span class="comment">// 该调用的默认参数在编译时已经确定为B::func的版本，不会推迟到动态绑定时</span></span><br><span class="line">  call <span class="type">void</span> %<span class="number">9</span>(%<span class="keyword">class</span>.B* %<span class="number">5</span>, i32 <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过A类型的引用aobj来调用func</span></span><br><span class="line">  %<span class="number">10</span> = bitcast %<span class="keyword">class</span>.C* %<span class="number">1</span> to %<span class="keyword">class</span>.A*</span><br><span class="line">  store %<span class="keyword">class</span>.A* %<span class="number">10</span>, %<span class="keyword">class</span>.A** %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">11</span> = load %<span class="keyword">class</span>.A*, %<span class="keyword">class</span>.A** %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">12</span> = bitcast %<span class="keyword">class</span>.A* %<span class="number">11</span> to <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)***</span><br><span class="line">  %<span class="number">13</span> = load <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)**, <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)*** %<span class="number">12</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">14</span> = getelementptr inbounds <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)*, <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)** %<span class="number">13</span>, i64 <span class="number">0</span></span><br><span class="line">  %<span class="number">15</span> = load <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)*, <span class="built_in">void</span> (%<span class="keyword">class</span>.A*, i32)** %<span class="number">14</span>, align <span class="number">8</span></span><br><span class="line">  <span class="comment">// 该调用的默认参数在编译时已经确定为A::func的版本，不会推迟到动态绑定时</span></span><br><span class="line">  call <span class="type">void</span> %<span class="number">15</span>(%<span class="keyword">class</span>.A* %<span class="number">11</span>, i32 <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Lambda的捕获"><a href="#C-Lambda的捕获" class="headerlink" title="C++ Lambda的捕获"></a>C++ Lambda的捕获</h2><p>在之前的一篇文章中(<a href="https://imzlp.com/posts/19441/">lambda在编译器中实现的方式</a>)写道过编辑器中Lambda的结果实际上就是一个重载了<code>()</code>的类。<br>但是关于捕获的地方有一点需要补充：如何确定捕获的个数？如果使用值捕获<code>[=]</code>或者引用捕获<code>[&amp;]</code>会把之前的所有数据都作为该Lambda的数据成员吗？</p>
<p>带着这个问题，来探究一下。<br>首先，先说结论：在使用默认捕获<code>[&amp;]</code>/<code>[=]</code>时，并不会把上文中所有的对象都捕获进来，而是在Lambda表达式内部用到了哪几个才会捕获。</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a=<span class="number">456</span>;<span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; aobj):a&#123;aobj.a&#125;&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">123</span>;</span><br><span class="line">  A aobj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> lambdaObj=[=]()&#123;cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\t&#x27;</span>&lt;&lt;aobj.a&lt;&lt;endl;&#125;;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(lambdaObj)&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">lambdaObj</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">123</span>     <span class="number">456</span></span><br></pre></td></tr></table></figure>
<p>先来看一下这个闭包对象的成员(LLVM-IR)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class A</span></span><br><span class="line">%<span class="keyword">class</span>.A = type &#123; i32 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambdaObj class type</span></span><br><span class="line">%<span class="keyword">class</span>.anon = type &#123; i32, %<span class="keyword">class</span>.A &#125;</span><br></pre></td></tr></table></figure>
<p>因为是值捕获，所以该闭包对象捕获的成员均是一份拷贝。</p>
<p>本来我以为，生成出来的闭包对象应该有一个构造函数，捕获的参数作为构造的参数传进去，不知道是LLVM做了优化还是怎样，没看到有生成出来构造函数，其捕获的初始化部分如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.A, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">123</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  call <span class="type">void</span> @_ZN1AC2Ev(%<span class="keyword">class</span>.A* %<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成出来的闭包对象</span></span><br><span class="line">  %<span class="number">3</span> = alloca %<span class="keyword">class</span>.anon, align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将捕获的参数赋值为类的参数</span></span><br><span class="line">  %<span class="number">4</span> = getelementptr inbounds %<span class="keyword">class</span>.anon, %<span class="keyword">class</span>.anon* %<span class="number">3</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">5</span> = load i32, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">5</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">6</span> = getelementptr inbounds %<span class="keyword">class</span>.anon, %<span class="keyword">class</span>.anon* %<span class="number">3</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span></span><br><span class="line">  <span class="comment">// 调用闭包对象内类成员A的拷贝构造A::A(const A&amp;)</span></span><br><span class="line">  call <span class="type">void</span> @_ZN1AC2ERKS_(%<span class="keyword">class</span>.A* %<span class="number">6</span>, %<span class="keyword">class</span>.A* <span class="built_in">dereferenceable</span>(<span class="number">4</span>) %<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数类型的typedef不能用在定义"><a href="#函数类型的typedef不能用在定义" class="headerlink" title="函数类型的typedef不能用在定义"></a>函数类型的typedef不能用在定义</h2><p>考虑如下情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">Func TestFunc; <span class="comment">// OK</span></span><br><span class="line">Func TestFunc2&#123;&#125; <span class="comment">// ill-formed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[ISO/IEC 14882:2014 §8.3.5.10]A typedef of function type may be used to declare a function but shall not be used to define a function (8.4).</p>
</blockquote>
<h2 id="Lambda-Expressions-Syntax"><a href="#Lambda-Expressions-Syntax" class="headerlink" title="Lambda-Expressions Syntax"></a>Lambda-Expressions Syntax</h2><p>首先先来看一下C++标准中对于Lambda-Expressions的Syntax描述(注意也是递归描述的)：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/lambda-expressions-syntex.webp" alt="index"><br>下面这个代码表达了什么意思？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  []()&#123;&#125;;</span><br><span class="line">  []&#123;&#125;();</span><br><span class="line">  &#123;&#125;[]&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看第一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这一行是使用lambda-expression声明了一个Unamed的闭包对象(closure object)，不捕获、不传参也不做任何实现。</p>
<p>第二行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;&#125;();</span><br></pre></td></tr></table></figure>
<p>这个就有点意思了，根据上面的<code>Lambda-Expression Syntax</code>图里标注的那样:${lambda\textrm{-}declarator}_{opt}$是<code>Opt</code>的，表示可以省略。<br>而${lambda\textrm{-}declarator}$又包括${(parameter\textrm{-}declaration\textrm{-}clause) mutable}_{opt}$等，所以表示lambda表达式在声明时参数列表可以省略。<br>也就是说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambdaObj=[]()&#123;&#125;;</span><br><span class="line"><span class="comment">// 可以写为</span></span><br><span class="line">audo lambdaObj=[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们可以理解第二行的前半部分为声明一个<code>闭包对象(closure object)</code>，而最后的那个<code>();</code>则是调用该闭包对象。</p>
<p>第三行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这一行也可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>一个<code>block</code>然后使用lambda-expression创建一个Unamed的闭包对象(closure object)。</p>
<h2 id="C-声明语义的一个坑点"><a href="#C-声明语义的一个坑点" class="headerlink" title="C++声明语义的一个坑点"></a>C++声明语义的一个坑点</h2><p>以下代码有什么问题？会输出什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">string</span>(hw);</span><br><span class="line">    std::cout&lt;&lt;hw&lt;&lt;std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string hw&#123;<span class="string">&quot;helloworld&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T Obj;</span><br><span class="line">  Obj.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是什么都不会输出！<br>真正执行的语义并不是我们期望的那样：创造一个<code>std::string</code>的临时变量，然后执行临时变量的销毁语义。<br>因为C++的声明语义规则如下；<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/cpp-declara-syntax.webp"><br>注意上面图里是递归描述的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">string</span>(hw);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::string hw;</span><br><span class="line"><span class="comment">// 当然这么也是等价的</span></span><br><span class="line">std::<span class="built_in">string</span> ((((((hw))))));</span><br></pre></td></tr></table></figure>
<p>所以在<code>print</code>函数里，是创造了一个<code>std::string</code>的局部变量(local-scope)<code>hw</code>，把类范围(class-scope)的<code>hw</code>给隐藏了。<br>解决办法：使用<code>&#123;&#125;</code>代替<code>()</code>，上面的例子里使用initializer-list会调用copy-constructor，然后立刻销毁该临时对象。</p>
<p>在当前的这个例子里，还没什么危害，如果在多线程编程里对锁进行这样的操作那就十分令人窒息了。</p>
<h2 id="VC越界输出烫烫烫的原因"><a href="#VC越界输出烫烫烫的原因" class="headerlink" title="VC越界输出烫烫烫的原因"></a>VC越界输出烫烫烫的原因</h2><p>在当年用VC学习C语言时，在遇到内存访问越界的时候会看到输出<code>烫烫烫</code>等”类似乱码”的东西。<br>例如下面的代码(使用vs2017-debug-x86编译)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> NoInitCharArray[<span class="number">10</span>];</span><br><span class="line">  std::cout &lt;&lt; NoInitCharArray &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x32dbg调试：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/x32dbg-NoInitCharArray.webp"></p>
<p>通过IDA调试：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/IDA-NoInitCharArray.webp"><br>运行结果：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/IDA-0xCC-Debug.webp"></p>
<p>其实时因为，VC在<code>debug</code>模式下，会将未初始化的内存设置为<code>0xCC</code>，而中文的GBK编码下<code>0xCC</code>恰好就是<code>烫</code>。</p>
<h2 id="Clang的一个Bug"><a href="#Clang的一个Bug" class="headerlink" title="Clang的一个Bug"></a>Clang的一个Bug</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _ZN1A4testEi(A*,<span class="type">int</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bbb\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  a.<span class="built_in">test</span>(<span class="number">123</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过Clang编译运行会输出<code>bbb</code>(使用最新的Clang5.0也是如此)，而GCC则产生一个重定义错误。<br>先挖坑了，有时间再分析一下这个问题。</p>
<h2 id="ISO-C与POSIX对Byte定义的区别"><a href="#ISO-C与POSIX对Byte定义的区别" class="headerlink" title="ISO C与POSIX对Byte定义的区别"></a>ISO C与POSIX对Byte定义的区别</h2><h3 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h3><blockquote>
<p><strong>byte</strong><br>addressable unit of data storage large enough to hold any member of the basic character set of the execution environment<br><strong>NOTE 1</strong> It is possible to express the address of each individual byte of an object uniquely.<br><strong>NOTE 2</strong> A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit.</p>
</blockquote>
<h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h3><blockquote>
<p><strong>Byte</strong><br>An individually addressable unit of data storage that is exactly an octet, used to store a character or a portion of a character; see also Section 3.87 (on page 47). A byte is composed of a contiguous sequence of 8 bits. The least significant bit is called the ‘‘low-order’’ bit; the most significant is called the ‘‘high-order’’ bit.<br>Note: The definition of byte from the ISO C standard is broader than the above and might accommodate hardware architectures with different sized addressable units than octets.</p>
</blockquote>
<h2 id="sizeof-size-of-reference-member-of-class"><a href="#sizeof-size-of-reference-member-of-class" class="headerlink" title="sizeof size of reference member of class"></a>sizeof size of reference member of class</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ATest</span>&#123;</span><br><span class="line">  <span class="built_in">ATest</span>(<span class="type">int</span> &amp;x):<span class="built_in">y</span>(a)&#123;&#125;</span><br><span class="line">  <span class="type">int</span> &amp;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The size?</span></span><br><span class="line"><span class="built_in">sizeof</span>(ATest);</span><br></pre></td></tr></table></figure>
<p>上面类<code>ATest</code>在LLVM/Clang下编译的内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%struct.ATest = type &#123; i32* &#125;</span><br></pre></td></tr></table></figure>
<p>至于引用为什么是指针，具体请看<a href="https://imzlp.com/posts/1756/#%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">引用的实现</a>。<br>所以<code>sizeof(ATest)</code>在这个实现下的结果是8。</p>
<h2 id="What-is-Translation-Unit-in-C-C"><a href="#What-is-Translation-Unit-in-C-C" class="headerlink" title="What is Translation Unit in C/C++?"></a>What is Translation Unit in C/C++?</h2><blockquote>
<p>[ISO/IEC 14882:2014]A source file together with all the headers (17.6.1.2) and source files included (16.2) via the preprocessing directive <code>#include</code>, less any source lines skipped by any of the conditional inclusion (16.1) preprocessing directives, is called a <strong>translation unit</strong>. [ Note: A C ++ program need not all be translated at the same time. — end note ]</p>
</blockquote>
<blockquote>
<p>[ISO/IEC 9899:1999]<br>A source file together with all the headers and source files included via the preprocessing directive <code>#include</code> is known as a <strong>preprocessing translation unit</strong>. After preprocessing, a preprocessing translation unit is called a <strong>translation unit</strong>.</p>
</blockquote>
<h2 id="C语言跨scope的变量访问"><a href="#C语言跨scope的变量访问" class="headerlink" title="C语言跨scope的变量访问"></a>C语言跨scope的变量访问</h2><p>如果具有下面的<strong>C语言</strong>代码，并且使用C编译器编译。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i =<span class="number">456</span>;</span><br><span class="line">  <span class="comment">// 如何访问外部的i？</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在C语言中因为没有<code>namespace</code>的概念，所以不能用C++中的<code>::</code>来限定操作。<br>但是可以使用下面的骚操作来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">456</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Google-C-Style-Guile"><a href="#Google-C-Style-Guile" class="headerlink" title="Google C++ Style Guile"></a>Google C++ Style Guile</h2><p>简易图片版：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/GoogleCppStyleGuide.webp"><br>中文PDF版：</p>
<div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/Google.C++.Progeamming.Guide.pdf" data-height="700px"></div>

<h2 id="C-17特性速查表"><a href="#C-17特性速查表" class="headerlink" title="C++17特性速查表"></a>C++17特性速查表</h2><div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/Language.Features.of.CPP17.pdf" data-height="700px"></div>

<h2 id="值类别速查表"><a href="#值类别速查表" class="headerlink" title="值类别速查表"></a>值类别速查表</h2><div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/value-category-cheatsheet.pdf" data-height="700px"></div>


<h2 id="C-11的新特性与兼容性"><a href="#C-11的新特性与兼容性" class="headerlink" title="C++11的新特性与兼容性"></a>C++11的新特性与兼容性</h2><div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/notes/cpp/index/TC++PL-Compatibility.pdf" data-height="700px"></div>

<h2 id="new、构造函数和异常"><a href="#new、构造函数和异常" class="headerlink" title="new、构造函数和异常"></a>new、构造函数和异常</h2><p>new操作实际上是由两个部分组成的：</p>
<ol>
<li>首先调用operator new分配内存</li>
<li>调用对象的构造函数</li>
</ol>
<blockquote>
<p>Evaluation of a new expression invokes one or more allocation and constructor functions; see 5.3.4</p>
</blockquote>
<p>这很重要，虽然一般情况下没有什么问题，但是考虑到异常安全这就是很重要的：如果new一个对象时抛出异常如何判断是operator new抛出了异常还是类的构造函数抛出了异常？<br>如果operator new抛出了异常，则没有任何内存被分配(抛出std:;bad_alloc)，也就不应该调用operator delete，但是如果是类的构造函数中抛出异常，说明内存已经分配完毕，则我们就需要调用operator delete来执行清理操作。</p>
<h2 id="指针比较的含义"><a href="#指针比较的含义" class="headerlink" title="指针比较的含义"></a>指针比较的含义</h2><p>在C++中，一个对象可以具有多个有效的地址，因此，指针比较不是地址的问题，而是对象同一性的问题。</p>
<h2 id="C-中常见术语错误"><a href="#C-中常见术语错误" class="headerlink" title="C++中常见术语错误"></a>C++中常见术语错误</h2><p>一个比较常见的问题是，不同语言间对于实现相同行为的描述术语也都不相同。比如Java或者其他语言用<code>方法(method)</code>来描述类内的函数，而C++里是没有<code>方法(method)</code>这个概念的，应该称为<code>成员函数(member function)</code>。<br>在C++中比较常出错的有以下几种术语：</p>
<table>
<thead>
<tr>
<th align="center">Wrong</th>
<th align="center">Right</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pure virtual base class</td>
<td align="center">Abstract class</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">Member function</td>
</tr>
<tr>
<td align="center">Virtual method</td>
<td align="center">???</td>
</tr>
<tr>
<td align="center">Destructed</td>
<td align="center">Destroyed</td>
</tr>
<tr>
<td align="center">Cast operator</td>
<td align="center">Conversion operator</td>
</tr>
</tbody></table>
<h2 id="为什么要有引用？"><a href="#为什么要有引用？" class="headerlink" title="为什么要有引用？"></a>为什么要有引用？</h2><p>我觉得C++具有引用的有两个基本原因：</p>
<ol>
<li>防止对象拷贝带来的开销(比指针的间接访问要更简洁)</li>
<li>对于IO流的使用(比如cout&lt;&lt;x&lt;&lt;y返回流的引用等价于使用cout&lt;&lt;x,cout&lt;&lt;y)</li>
</ol>
<h2 id="C-一些语言特性被设计的原因"><a href="#C-一些语言特性被设计的原因" class="headerlink" title="C++一些语言特性被设计的原因"></a>C++一些语言特性被设计的原因</h2><ul>
<li>名字空间就是针对不同库里使用相同的名字而提供的机制</li>
<li>异常处理是为建立一种处理错误的公共模型提供了基础</li>
<li>模板是为定义独立于具体类型的容器类和算法而提供的一种机制，其中的具体类型可以由用户或者其他的库提供</li>
<li>构造函数和析构函数为对象的初始化和最后清理提供了一种公共模型</li>
<li>抽象类提供了一种机制，借助于它可以独立地定义接口，与实际被接口的类无关</li>
<li>运行时类型信息是为了寻回类型信息而提供的一种机制，因为当对象被传递给一个库再传递回来的时候，可能只携带着不够特殊(基类的)类型信息。</li>
</ul>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/notes/">NOTES</a></li>
          <li>CPP</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang%E7%BC%96%E8%AF%91C-%E4%B8%BAWebAssembly"><span class="nav-number">1.</span> <span class="nav-text">Clang编译C++为WebAssembly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLVM%E8%87%AA%E5%B8%A6IR%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">LLVM自带IR解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-23-The-Next-C-Standard"><span class="nav-number">3.</span> <span class="nav-text">C++23:The Next C++ Standard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MinGW-w64%E7%9A%84Win%E7%8B%AC%E7%AB%8B%E6%9E%84%E5%BB%BA"><span class="nav-number">4.</span> <span class="nav-text">MinGW-w64的Win独立构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nodiscard"><span class="nav-number">5.</span> <span class="nav-text">[[nodiscard]]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C99-VAL-are-turing-complete"><span class="nav-number">6.</span> <span class="nav-text">C99 VAL are turing complete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E7%89%B9%E5%AE%9A%E7%BC%96%E5%8F%B7%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-number">7.</span> <span class="nav-text">禁用特定编号的警告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">构造函数为什么不能取地址？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">9.</span> <span class="nav-text">模板特化的类型萃取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="nav-number">10.</span> <span class="nav-text">友元关系不能被继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scoped-enum"><span class="nav-number">11.</span> <span class="nav-text">Scoped enum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LoadLibrary-faild"><span class="nav-number">12.</span> <span class="nav-text">LoadLibrary faild</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E4%BD%BF%E7%94%A8-%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%8D%E7%BB%9F%E4%B8%80"><span class="nav-number">13.</span> <span class="nav-text">预处理使用##时需要注意编译器的不统一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%ADdelete-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.</span> <span class="nav-text">C++中delete[]的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VS%E5%86%85%E5%AD%98%E6%96%AD%E7%82%B9"><span class="nav-number">15.</span> <span class="nav-text">VS内存断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#move%E5%92%8Cforward%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">move和forward的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rvalue%E5%92%8Clvalue%E7%9A%84%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number">17.</span> <span class="nav-text">rvalue和lvalue的重载规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0non-const-lvalue%E7%89%88%E6%9C%AC"><span class="nav-number">17.1.</span> <span class="nav-text">实现non-const lvalue版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0const-lvalue%E7%89%88%E6%9C%AC"><span class="nav-number">17.2.</span> <span class="nav-text">实现const lvalue版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%AE%9E%E7%8E%B0rvalue%E7%89%88%E6%9C%AC"><span class="nav-number">17.3.</span> <span class="nav-text">只实现rvalue版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A2%E6%9C%89rvalue%E4%B9%9F%E6%9C%89lvalue%E7%89%88%E6%9C%AC"><span class="nav-number">17.4.</span> <span class="nav-text">既有rvalue也有lvalue版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">17.5.</span> <span class="nav-text">结语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rvalue%E5%92%8Clvalue"><span class="nav-number">18.</span> <span class="nav-text">rvalue和lvalue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81%E9%A1%BA%E5%BA%8F"><span class="nav-number">19.</span> <span class="nav-text">C++局部对象的销毁顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8E%E7%BD%AE-amp-%E4%B8%8E-amp-amp-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">20.</span> <span class="nav-text">C++函数的后置&amp;与&amp;&amp;修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E7%9A%84%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="nav-number">21.</span> <span class="nav-text">static的链接问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#placement-new%E7%BC%96%E8%AF%91%E6%97%B6%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">22.</span> <span class="nav-text">placement-new编译时的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Next-Big-Thing-C-20"><span class="nav-number">23.</span> <span class="nav-text">The Next Big Thing:C++20</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%B7%B2%E8%A2%AB%E4%BC%98%E5%8C%96%EF%BC%8C%E5%9B%A0%E8%80%8C%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="nav-number">24.</span> <span class="nav-text">变量已被优化，因而不可用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C5083%E9%94%99%E8%AF%AF"><span class="nav-number">25.</span> <span class="nav-text">C5083错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VS%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%AE%8F"><span class="nav-number">26.</span> <span class="nav-text">VS中的属性宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Win%E5%BA%93%E4%BD%86%E6%B2%A1%E6%9C%89%E6%B7%BB%E5%8A%A0%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF"><span class="nav-number">27.</span> <span class="nav-text">使用Win库但没有添加链接库的链接错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8Lib%E6%97%B6%E7%9A%84LINK1112%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF"><span class="nav-number">28.</span> <span class="nav-text">引入外部Lib时的LINK1112链接错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8Lib%E6%97%B6%E7%9A%84LINK2038%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF"><span class="nav-number">29.</span> <span class="nav-text">引入外部Lib时的LINK2038链接错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84C1010%E9%94%99%E8%AF%AF"><span class="nav-number">30.</span> <span class="nav-text">预编译的C1010错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">31.</span> <span class="nav-text">类内默认值与构造函数初始化的顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96"><span class="nav-number">32.</span> <span class="nav-text">变量模板的特化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-the-Object-in-C-C"><span class="nav-number">33.</span> <span class="nav-text">What is the Object in C&#x2F;C++?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%A8%A1%E6%9D%BF%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">34.</span> <span class="nav-text">C++模板必须提供声明和定义的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VS%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="nav-number">35.</span> <span class="nav-text">VS修改文件编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E5%AE%9E%E4%BE%8B%E7%9A%84static%E6%88%90%E5%91%98"><span class="nav-number">36.</span> <span class="nav-text">C++模板特化实例的static成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9C%A8%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">37.</span> <span class="nav-text">this不能用在函数默认参数的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%90%83%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-number">38.</span> <span class="nav-text">萃取数组的元素个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bin2Hex"><span class="nav-number">39.</span> <span class="nav-text">Bin2Hex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">40.</span> <span class="nav-text">C读写二进制文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GNU%E6%89%A9%E5%B1%95%EF%BC%9Astruct%E5%88%9D%E5%A7%8B%E5%8C%96-first-%E2%80%A6-last"><span class="nav-number">41.</span> <span class="nav-text">GNU扩展：struct初始化[first … last]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEprivate%E6%88%90%E5%91%98"><span class="nav-number">42.</span> <span class="nav-text">static成员初始化可以访问private成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">43.</span> <span class="nav-text">!!的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%B0%B1%E6%98%AF%E6%95%B4%E5%9E%8B"><span class="nav-number">44.</span> <span class="nav-text">C语言中的枚举就是整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A4%9F%E6%8F%90%E4%BE%9B%E5%AE%9A%E4%B9%89"><span class="nav-number">45.</span> <span class="nav-text">C++中纯虚函数不能够提供定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8DC%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">46.</span> <span class="nav-text">正则匹配C函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%81%9A%E5%90%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">47.</span> <span class="nav-text">C语言中聚合结构的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">48.</span> <span class="nav-text">通过函数指针进行函数调用不可以使用默认参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unspecified-behavior"><span class="nav-number">49.</span> <span class="nav-text">unspecified behavior</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#well-formed-program"><span class="nav-number">50.</span> <span class="nav-text">well-formed program</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-Define-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="nav-number">51.</span> <span class="nav-text">Implementation-Define(实现定义行为)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UB-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="nav-number">52.</span> <span class="nav-text">UB(未定义行为)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%90%8D%E5%AD%97-injected-class-name-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">53.</span> <span class="nav-text">关于注入类名字(injected-class-name)的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A6%81%E6%8A%A0%E5%AD%97%E7%9C%BC%E7%9A%84C-%E9%97%AE%E9%A2%98"><span class="nav-number">54.</span> <span class="nav-text">一个要抠字眼的C++问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reintrtpret-cast%E7%9A%84%E8%BD%AC%E6%8D%A2-%E4%BD%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">55.</span> <span class="nav-text">reintrtpret_cast的转换(位模式的转换)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%88%B0%E6%95%B4%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">55.1.</span> <span class="nav-text">指针到整型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%88%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">55.2.</span> <span class="nav-text">整型到指针的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">55.3.</span> <span class="nav-text">函数指针的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#offsetof%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9C%A8%E9%9D%9EPOD%E7%B1%BB%E5%9E%8B-Standard-Layout"><span class="nav-number">56.</span> <span class="nav-text">offsetof不能用在非POD类型(Standard Layout)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84Standard-Layout-types"><span class="nav-number">57.</span> <span class="nav-text">C++中的Standard Layout types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AF%B9this%E6%8C%87%E9%92%88%E5%81%9A%E6%94%BE%E7%BD%AEnew%E6%93%8D%E4%BD%9C"><span class="nav-number">58.</span> <span class="nav-text">在基类子对象内对this指针做放置new操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MinGW-W64%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="nav-number">59.</span> <span class="nav-text">MinGW-W64编译32位程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9A%90%E5%BC%8F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">60.</span> <span class="nav-text">C语言的隐式函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">61.</span> <span class="nav-text">Clang查看对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%A0%B9%E6%8D%AE%E8%B0%83%E7%94%A8%E8%80%85-%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8-%E7%9A%84%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%86%B3%E5%AE%9A"><span class="nav-number">62.</span> <span class="nav-text">虚函数的默认参数根据调用者(指针或引用)的静态类型决定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Lambda%E7%9A%84%E6%8D%95%E8%8E%B7"><span class="nav-number">63.</span> <span class="nav-text">C++ Lambda的捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84typedef%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89"><span class="nav-number">64.</span> <span class="nav-text">函数类型的typedef不能用在定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-Expressions-Syntax"><span class="nav-number">65.</span> <span class="nav-text">Lambda-Expressions Syntax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%A3%B0%E6%98%8E%E8%AF%AD%E4%B9%89%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%E7%82%B9"><span class="nav-number">66.</span> <span class="nav-text">C++声明语义的一个坑点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VC%E8%B6%8A%E7%95%8C%E8%BE%93%E5%87%BA%E7%83%AB%E7%83%AB%E7%83%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">67.</span> <span class="nav-text">VC越界输出烫烫烫的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang%E7%9A%84%E4%B8%80%E4%B8%AABug"><span class="nav-number">68.</span> <span class="nav-text">Clang的一个Bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ISO-C%E4%B8%8EPOSIX%E5%AF%B9Byte%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">69.</span> <span class="nav-text">ISO C与POSIX对Byte定义的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ISO-C"><span class="nav-number">69.1.</span> <span class="nav-text">ISO C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX"><span class="nav-number">69.2.</span> <span class="nav-text">POSIX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-size-of-reference-member-of-class"><span class="nav-number">70.</span> <span class="nav-text">sizeof size of reference member of class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Translation-Unit-in-C-C"><span class="nav-number">71.</span> <span class="nav-text">What is Translation Unit in C&#x2F;C++?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E8%B7%A8scope%E7%9A%84%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">72.</span> <span class="nav-text">C语言跨scope的变量访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Google-C-Style-Guile"><span class="nav-number">73.</span> <span class="nav-text">Google C++ Style Guile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-17%E7%89%B9%E6%80%A7%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-number">74.</span> <span class="nav-text">C++17特性速查表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-number">75.</span> <span class="nav-text">值类别速查表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">76.</span> <span class="nav-text">C++11的新特性与兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">77.</span> <span class="nav-text">new、构造函数和异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%AF%94%E8%BE%83%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">78.</span> <span class="nav-text">指针比较的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD%E9%94%99%E8%AF%AF"><span class="nav-number">79.</span> <span class="nav-text">C++中常见术语错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="nav-number">80.</span> <span class="nav-text">为什么要有引用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%80%E4%BA%9B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E8%A2%AB%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">81.</span> <span class="nav-text">C++一些语言特性被设计的原因</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="查利鹏"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">查利鹏</p>
  <div class="site-description" itemprop="description">唯有热爱可抵岁月漫长。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021027036号 </a>
      <img src="/images/beian_logo.webp" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502007298" rel="noopener" target="_blank">粤公网安备44030502007298号 </a>
  </div>

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">查利鹏</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">747k</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/3.1.2/es5/tex-mml-chtml.min.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imzlp.com/notes/cpp/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "留下点什么吧~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
