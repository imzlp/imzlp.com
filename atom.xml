<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>循迹研究室</title>
  <icon>https://imzlp.com/icon.png</icon>
  
  <link href="https://imzlp.com/atom.xml" rel="self"/>
  
  <link href="https://imzlp.com/"/>
  <updated>2024-05-08T08:00:51.708Z</updated>
  <id>https://imzlp.com/</id>
  
  <author>
    <name>查利鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://imzlp.com/posts/1/"/>
    <id>https://imzlp.com/posts/1/</id>
    <published>2024-05-08T08:00:51.708Z</published>
    <updated>2024-05-08T08:00:51.708Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;欢迎访问循迹研究室，这是一个专注于游戏开发的技术站点。我在Github上的开源项目：&lt;a href=&quot;https://github.com/hxhb&quot;&gt;github.com/hxhb&lt;/a&gt;及&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>部署一个自托管的MEMOS笔记系统</title>
    <link href="https://imzlp.com/posts/30014/"/>
    <id>https://imzlp.com/posts/30014/</id>
    <published>2024-04-13T10:34:01.000Z</published>
    <updated>2024-04-13T10:34:01.000Z</updated>
    
    
    <summary type="html">&lt;!--- 我坚持不依赖任何中心化的平台服务，任何平台一旦具有盈利和监管压力，广告和内容审查不可避免。而且个人的数据，我也不想“贡献”给第三方平台。 ---&gt;
&lt;p&gt;对于个人知识管理，我非常热衷于搞一套自己的local-first和开源的self-host的服务，这样就能不依赖任何平台、数据完全自主可控、服务可随时迁移。不管是Obsidian、Hexo博客、以及本篇文章介绍的&lt;a href=&quot;https://github.com/usememos/memos&quot;&gt;memos&lt;/a&gt;，都是这个选择标准。&lt;/p&gt;
&lt;p&gt;本文的主角，&lt;a href=&quot;https://github.com/usememos/memos&quot;&gt;memos&lt;/a&gt;是一个开源的轻量级笔记的服务，可以像发微博的方式记笔记，支持TAG标记和引用。具有账号系统和权限管理，网页访问随时登录，笔记可以公开或私有，非常灵活。我选择它是因为可以跟Obsidian互为补充，Obsidian还是太重了，在PC上好用但移动端体验不佳。所以我需要一个轻量级、随时可用的一种笔记服务。&lt;/p&gt;
&lt;p&gt;本篇文章会介绍，如何在VPS上用Docker部署一个Memos服务，并结合Nginx绑定域名、Certbot签发以及自动更新SSL证书和定时备份memos数据库，还有我为该服务做的一些配置优化。&lt;/p&gt;</summary>
    
    
    
    <category term="知识管理" scheme="https://imzlp.com/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
    <category term="MEMOS" scheme="https://imzlp.com/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/MEMOS/"/>
    
    
    <category term="知识管理" scheme="https://imzlp.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
    <category term="MEMOS" scheme="https://imzlp.com/tags/MEMOS/"/>
    
    <category term="自托管服务" scheme="https://imzlp.com/tags/%E8%87%AA%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用HotPatcher加速真机资源验证</title>
    <link href="https://imzlp.com/posts/76004/"/>
    <id>https://imzlp.com/posts/76004/</id>
    <published>2024-04-07T18:40:11.000Z</published>
    <updated>2024-04-07T18:40:11.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中，主要在介绍&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;如何应用在热更新流程里。但是&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;并不只是能实现热更的需求，更是一个灵活的资源打包框架。&lt;/p&gt;
&lt;p&gt;当项目开发进行到一定阶段，海量的资源需要进包，等待一次完整出包的时间会很久。如果真机出现问题，&lt;strong&gt;修复-&amp;gt;打包-&amp;gt;验证&lt;/strong&gt;，这个串行流程就会变动极为冗长。经常会遇到脚本、数据或者某些的资源错误，导致包的异常。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2024/04/07/182636.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，再完整出一个包就等待数个小时的时间，导致测试无法进行冒烟跑测。就算重新出包也难保一定没有其他遗漏的问题，否则又要重来一遍。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2024/04/07/161430.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于这种痛点，我们迫切地需要一种在开发阶段能够快速地修复包内资源问题，进行快速验证的方法。而&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;提供了这样的功能，如果能充分利用起来，就不必等待完整出包。&lt;/p&gt;
&lt;p&gt;本篇文章会介绍，如何利用HotPatcher提供的编辑器功能，来快速打包预设配置和特定资源。加速资源在真机上的验证流程，大幅提升测试效率。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/HotPatcher/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>开源杂谈：HotPatcher的开发进展</title>
    <link href="https://imzlp.com/posts/16808/"/>
    <id>https://imzlp.com/posts/16808/</id>
    <published>2024-04-07T10:01:40.000Z</published>
    <updated>2024-04-07T10:01:40.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;距离&lt;a href=&quot;https://github.com/hxhb/HotPatcher/&quot;&gt;HotPatcher&lt;/a&gt;的上次版本发布，已经过去了大半年的时间，对UE4的支持较好，但对UE5的支持欠缺，群里也频繁有人询问适配情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HotPatcher的上个Release版本是20230604发布的&lt;a href=&quot;https://github.com/hxhb/HotPatcher/releases/tag/v81.0&quot;&gt;v81.0&lt;/a&gt;，只兼容了UE5.1.0，并且不支持WP和Nanite，后续Epic又推出了UE5.2和5.3，但插件并未适配。虽然可以自己修改编译错误，但功能支持在UE5里算是半成品状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;趁着清明假期爆肝了几天，我对HotPatcher做了全面优化与适配支持，可以兼容UE4.21~UE5的最新版本，并且发布了一个新的Release版本：&lt;a href=&quot;https://github.com/hxhb/HotPatcher/releases/tag/v82.0&quot;&gt;v82.0&lt;/a&gt;。本篇文章的后半部分会介绍&lt;a href=&quot;https://github.com/hxhb/HotPatcher/&quot;&gt;HotPatcher&lt;/a&gt;在UE5中的适配情况、注意事项、以及更新日志。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2024/04/06/171019.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外，在2020年我曾经写过一篇文字：&lt;a href=&quot;https://imzlp.com/posts/8890/&quot;&gt;对开源的一些思考与想法&lt;/a&gt;，而过去这两年间，我对于维护开源项目的又有些新的想法，一起做个总结。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/HotPatcher/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：记一次iPhone硬件维修</title>
    <link href="https://imzlp.com/posts/27221/"/>
    <id>https://imzlp.com/posts/27221/</id>
    <published>2024-03-01T14:45:08.000Z</published>
    <updated>2024-05-08T15:32:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;元旦期间，我的iPhone12跌落导致了一些故障，勉强能用。但前段时间电池也鼓包很容易自动关机，已经彻底不能用了。换了备机之后，搁置了一段时间。&lt;/p&gt;
&lt;p&gt;最近想起来，因为还能正常开机，且主要功能还能正常使用，所以推测应该还是部分故障，不是整体损坏。完全报废有些可惜，只能换不锈钢盆了。&lt;/p&gt;
&lt;p&gt;自己动手拆机分析了下故障原因，并尝试购买配件修理解决，本篇文章记录拆机和解决过程。&lt;/p&gt;</summary>
    
    
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="数码" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%95%B0%E7%A0%81/"/>
    
    <category term="硬件维修" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%95%B0%E7%A0%81/%E7%A1%AC%E4%BB%B6%E7%BB%B4%E4%BF%AE/"/>
    
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="数码" scheme="https://imzlp.com/tags/%E6%95%B0%E7%A0%81/"/>
    
    <category term="硬件维修" scheme="https://imzlp.com/tags/%E7%A1%AC%E4%BB%B6%E7%BB%B4%E4%BF%AE/"/>
    
  </entry>
  
  <entry>
    <title>循迹旅行：澳门旅游攻略</title>
    <link href="https://imzlp.com/posts/35791/"/>
    <id>https://imzlp.com/posts/35791/</id>
    <published>2024-02-15T15:35:31.000Z</published>
    <updated>2024-02-15T15:35:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;今年春节在深圳过年，计划大湾区旅行的下一站为澳门。而且从深圳去澳门也算比较方便，于是规划成行。做了一些攻略和行程安排，可以作为首次去澳门旅游的参考。&lt;/p&gt;</summary>
    
    
    
    <category term="循迹旅行" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/"/>
    
    <category term="大湾区" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/%E5%A4%A7%E6%B9%BE%E5%8C%BA/"/>
    
    
    <category term="循迹旅行" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/"/>
    
    <category term="大湾区" scheme="https://imzlp.com/tags/%E5%A4%A7%E6%B9%BE%E5%8C%BA/"/>
    
    <category term="澳门" scheme="https://imzlp.com/tags/%E6%BE%B3%E9%97%A8/"/>
    
    <category term="Macau" scheme="https://imzlp.com/tags/Macau/"/>
    
  </entry>
  
  <entry>
    <title>UE中利用反射为资产建立属性缓存</title>
    <link href="https://imzlp.com/posts/71162/"/>
    <id>https://imzlp.com/posts/71162/</id>
    <published>2023-10-25T15:27:37.000Z</published>
    <updated>2023-10-25T15:27:37.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在前一篇文章&lt;a href=&quot;https://imzlp.com/posts/19901/&quot;&gt;UE中资源自修正的设计与实现方案&lt;/a&gt;中，我介绍了利用ResScannerUE的资产检查进行过滤，然后自动化处理的实现方案。&lt;/p&gt;
&lt;p&gt;在通常情况下，如果想要检查资源内的某个属性，就需要把资产加载进来，获取对象：&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2023/10/24/105204.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是，如果想要批量地检查资源的属性，用这种形式挨个加载资源的耗时很久，尤其是在没有DDC的情况下，加载资源就会触发DDC缓存的构建，这部分耗时很久，对于机器性能占比也较高。&lt;/p&gt;
&lt;p&gt;而且随着资产规模的扩大，如果想要完整扫描一遍工程里的所有资源，耗时就会异常夸张。所以，我设想能否实现一种无需加载资源，但能够获取资源内属性的方法。&lt;/p&gt;
&lt;p&gt;经过研究发现，通过一种取巧的方法做到这一点，利用了反射、资产序列化、以及AssetRegistry的特性组合起来。并且是非侵入式的，无需修改任何现有资源类型的代码。&lt;/p&gt;
&lt;p&gt;本篇文章会介绍其实现原理，以及对引擎中相关逻辑的分析，并介绍该机制在工程中的实际应用。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="AssetRegistry" scheme="https://imzlp.com/tags/AssetRegistry/"/>
    
  </entry>
  
  <entry>
    <title>UE中资源自修正的设计与实现方案</title>
    <link href="https://imzlp.com/posts/19901/"/>
    <id>https://imzlp.com/posts/19901/</id>
    <published>2023-10-18T14:45:12.000Z</published>
    <updated>2023-10-18T14:45:12.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在先前的文章中，我曾介绍了在UE中利用ResScannerUE进行资源的&lt;strong&gt;多阶段&lt;/strong&gt;与&lt;strong&gt;自动化&lt;/strong&gt;检查的实现和执行效率优化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/22655&quot;&gt;UE中多阶段的自动化资源检查方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/20376/&quot;&gt;基于ResScannerUE的资源检查自动化实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/11750&quot;&gt;UE资源合规检查工具ResScannerUE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;已经能够实现非常灵活地配置资源检查和及时提醒，具有非常强大的规则表达能力。但它们还都仅限于&lt;strong&gt;发现问题&lt;/strong&gt;予以提醒的阶段，虽然有强制约束不能提交，但仍需人工地去处理。尤其是具有大量存量资源的情况下，手动处理的人力耗时非常大。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2023/202310181358828.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于这种情况下，我设计了一种自动化修正资源的机制，能够在规范制定之后自动修复资源，确保被扫描出来资源的都被设置为正确的状态。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2023/202310131604358.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;补齐了我这套资源检查方案中的最后一块拼图，并且可以应用在各个阶段的扫描过程，按需执行。本篇文章会介绍它的设计思路与实现机制，以及一些在项目中实际的应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="ResScannerUE" scheme="https://imzlp.com/tags/ResScannerUE/"/>
    
  </entry>
  
  <entry>
    <title>UE插件与工具开发：j2的设计思路与实现</title>
    <link href="https://imzlp.com/posts/86105/"/>
    <id>https://imzlp.com/posts/86105/</id>
    <published>2023-10-14T20:23:37.000Z</published>
    <updated>2023-10-14T20:23:37.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;如果让我挑一个近期在工作当中使用UE感觉最无意义和折磨的事情，那一定是根据一大串字符串路径，在ContentBrowser里找到它。&lt;/p&gt;
&lt;p&gt;由于无法快速地直接跳转到目录和资源，每次逐级点开一个深层目录都给我带来一种浪费人生的感觉。 &lt;/p&gt;
&lt;p&gt;基于这种痛点，我写了一个小工具，可以极大地缓解这种手动焦虑。我把它命名为&lt;code&gt;j2&lt;/code&gt;（jump to），是一个极简的ContentBrowser跳转工具，开源在github上：&lt;a href=&quot;https://github.com/hxhb/JumpTo&quot;&gt;hxhb/JumpTo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本片文章会介绍该项目的用法，以及构想解决方法的思考过程和逐步的代码实现。虽然功能本身是一个极简的插件，但对于实际痛点的发现、分析和解决过程值得记录。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>基于Obsidian构建知识管理体系</title>
    <link href="https://imzlp.com/posts/30911/"/>
    <id>https://imzlp.com/posts/30911/</id>
    <published>2023-09-07T16:19:40.000Z</published>
    <updated>2023-09-26T10:42:58.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在2020年，我曾写过一篇文章&lt;a href=&quot;https://imzlp.com/posts/29551/&quot;&gt;如何构建自己的知识体系？&lt;/a&gt;，其中主要是对于日常技术积累的思考，偏向于方法论。&lt;/p&gt;
&lt;p&gt;本篇文章会从工具和实际使用的角度出发，基于&lt;a href=&quot;https://obsidian.md/&quot;&gt;Obsidian&lt;/a&gt;探索个人知识管理的可能性，并尝试将其与Hexo博客结合起来。当然，这种工具偏好和实践具有强主观性，本文完全从我个人的实践和经历出发，&lt;strong&gt;没有最好的工具，只有最适合自己的。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识管理" scheme="https://imzlp.com/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
    <category term="Obsidian" scheme="https://imzlp.com/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/Obsidian/"/>
    
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="博客管理" scheme="https://imzlp.com/tags/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Obsidian" scheme="https://imzlp.com/tags/Obsidian/"/>
    
    <category term="知识管理" scheme="https://imzlp.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>循迹旅行：香港旅游攻略</title>
    <link href="https://imzlp.com/posts/31438/"/>
    <id>https://imzlp.com/posts/31438/</id>
    <published>2023-08-21T09:37:37.000Z</published>
    <updated>2023-09-01T09:50:12.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;深圳与香港仅一江之隔，虽早有打算去香港玩一圈，但因为前两三年因为疫情的原因迟迟未能成行。今年疫情放开之后，香港和内地之间通关也变得比较方便了，所以把去香港提上了日程。&lt;/p&gt;
&lt;p&gt;周末和老婆一起去香港玩了一趟，去之前做了一些攻略和行程安排，可以作为首次去香港旅游的参考。&lt;/p&gt;</summary>
    
    
    
    <category term="循迹旅行" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/"/>
    
    <category term="大湾区" scheme="https://imzlp.com/categories/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/%E5%A4%A7%E6%B9%BE%E5%8C%BA/"/>
    
    
    <category term="循迹旅行" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E6%97%85%E8%A1%8C/"/>
    
    <category term="大湾区" scheme="https://imzlp.com/tags/%E5%A4%A7%E6%B9%BE%E5%8C%BA/"/>
    
    <category term="香港" scheme="https://imzlp.com/tags/%E9%A6%99%E6%B8%AF/"/>
    
    <category term="HongKong" scheme="https://imzlp.com/tags/HongKong/"/>
    
  </entry>
  
  <entry>
    <title>UE构建提升：优化远程构建IOS的实现</title>
    <link href="https://imzlp.com/posts/50293/"/>
    <id>https://imzlp.com/posts/50293/</id>
    <published>2023-08-16T10:43:50.000Z</published>
    <updated>2023-09-05T20:11:12.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;远程构建是UE中非常方便好用的一种打包IOS方式，能够只在Mac上编译代码，不COOK资源，能够极大地降低对于Mac硬件的需求。&lt;/p&gt;
&lt;p&gt;而且，Mac的售价颇高，传统模式下，如果需要部署多个独立的IOS包构建流程，通常就需要采购多台独立的Mac机器分别部署，硬件成本较高。&lt;/p&gt;
&lt;p&gt;况且，IOS的开发环境往往需要随着IOS系统迭代进行更新。每年WWDC发布新版本IOS，就会需要新版本的XCode支持，新版本XCode又依赖新版本的MacOS，套娃式的链式依赖。如果Mac的构建环境增多，那么更新这些机器的构建环境也会变为一个繁琐的重复任务。&lt;/p&gt;
&lt;p&gt;远程构建IOS也能够比较好的解决这个问题，一台独立的Mac，可以同时给多个IOS构建流程提供支持，如果需要更新环境也只需要处理一台即可。而且编译代码的耗时相对固定，且能够进行增量编译，理论上来说只要不是所有的机器同时执行全量编译，那么对于Mac的性能压力就没有那么大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2023/20230816154208.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;博客中也有开启远程构建IOS的文章：&lt;a href=&quot;https://imzlp.com/posts/1948/#%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BAiOS&quot;&gt;UE 开发笔记：Mac/iOS 篇&lt;/a&gt;，可以参考基础配置启用。&lt;/p&gt;
&lt;p&gt;但UE默认实现的IOS远程构建在实际使用中也存在不少的问题，无法实现从部署到构建全自动化流程，本篇文章会针对远程构建在实际的工程应用中痛点进行优化。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="BuildSystem" scheme="https://imzlp.com/categories/UnrealEngine/BuildSystem/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="BuildSystem" scheme="https://imzlp.com/tags/BuildSystem/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：利用AI助力生活及开发探索</title>
    <link href="https://imzlp.com/posts/71467/"/>
    <id>https://imzlp.com/posts/71467/</id>
    <published>2023-04-24T17:01:46.000Z</published>
    <updated>2023-04-24T17:01:46.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;工欲善其事，必先利其器！&lt;/strong&gt;以ChatGPT和Stable Diffusion为代表的AIGC工具横空出世，AI浪潮席卷了各行各业。作为开发者，如何利用AI的能力，提升做事情的效率，是个值得研究的问题。&lt;/p&gt;
&lt;p&gt;现阶段需要注意的是，GPT回复的内容非完全准确，存在胡诌的可能。但它的潜力在于有望实现了一种通用型的AI助手。没有人能在所有领域都具备专家级别的知识，在不熟悉的领域，充分利用GPT能够显著降低上手成本。&lt;/p&gt;
&lt;p&gt;本篇文章我会介绍，利用GPT助力工作、生活和学习的一些案例，以及使用GPT API进行二次开发应用场景的探索。文后会分享一些我在使用的Prompts，并推荐一些我觉得不错的GPT工具，以及对Azure OpenAI服务使用Cloudflare Worker封装的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="AI" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/AI/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="AI" scheme="https://imzlp.com/tags/AI/"/>
    
    <category term="GPT" scheme="https://imzlp.com/tags/GPT/"/>
    
    <category term="OpenAI" scheme="https://imzlp.com/tags/OpenAI/"/>
    
  </entry>
  
  <entry>
    <title>DevOps：虚幻引擎的CI/CD实践</title>
    <link href="https://imzlp.com/posts/96336/"/>
    <id>https://imzlp.com/posts/96336/</id>
    <published>2023-04-15T14:30:56.000Z</published>
    <updated>2023-04-15T14:30:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;DevOps是一种思想，以自动化进行持续集成(CI)和持续部署(CD)为基础，优化开发、测试、运维等所有环节。强调软件开发测试运维的一体化，减少各个部门或流程之间的沟通成本从而实现快速高质量的发布和迭代。&lt;/p&gt;
&lt;p&gt;虽然在游戏领域的开发情况和传统互联网有很大区别，但借用DevOps的概念把项目中所有的生产环节最大限度地接入自动化，能够大幅提升效率。&lt;/p&gt;
&lt;p&gt;本篇文章会介绍，UE实现自动化的基础概念，及我在虚幻引擎自动化构建方面的一些尝试和实际的工程实践。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="DevOps" scheme="https://imzlp.com/categories/UnrealEngine/DevOps/"/>
    
    <category term="CI/CD" scheme="https://imzlp.com/categories/UnrealEngine/DevOps/CI-CD/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="CI/CD" scheme="https://imzlp.com/tags/CI-CD/"/>
    
    <category term="DevOps" scheme="https://imzlp.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：在复杂的世界中寻找确定性</title>
    <link href="https://imzlp.com/posts/83875/"/>
    <id>https://imzlp.com/posts/83875/</id>
    <published>2023-04-08T14:10:39.000Z</published>
    <updated>2023-04-08T14:10:39.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近总会产生一种莫名的焦虑感，经过一段时间的自我观察和思考，我认为需要直面这些问题并尝试给出回答。&lt;/p&gt;
&lt;p&gt;本文是对当前生活状态和问题进行研究并剖析的思想实验，总结用于指导生活和工作的思想工具。作为个人方法论，其中包含大量的主观内容。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="方法论" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>资源管理：UASSET资源加密方案</title>
    <link href="https://imzlp.com/posts/32412/"/>
    <id>https://imzlp.com/posts/32412/</id>
    <published>2023-04-07T12:50:04.000Z</published>
    <updated>2023-04-07T12:50:04.000Z</updated>
    
    
    <summary type="html">&lt;!-- ![](https://img.imzlp.com/imgs/zlp/picgo/2023/20230407125507.webp) --&gt;
&lt;p&gt;在游戏项目开发中，会涉及到大量的开发、美术、策划以及外包等等各个方面的研发人员。出于资源安全和信息保密的考虑，通常会做一些复杂的权限控制和同步逻辑。&lt;/p&gt;
&lt;p&gt;但抛开权限控制，仅探讨资源本身，在UE中资源是向上兼容的，用同版本号的引擎或者更高版本号的引擎可以直接打开。这意味着分发出去的资源，可以直接在另外的项目里使用。所以，该如何保证开发阶段资源的安全性是要重点关注的。&lt;/p&gt;
&lt;p&gt;本篇文章提供一种加密工程中原始UASSET资源的思路，并介绍可以用于资源加密的基础原理。但如果公开具体的加密实现，就等同于裸奔，所以本篇文章仅提供对uasset资源结构的分析以及可用于实现加密的思路，但不会提供具体的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="加密" scheme="https://imzlp.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>UE插件与工具开发：Commandlet</title>
    <link href="https://imzlp.com/posts/27475/"/>
    <id>https://imzlp.com/posts/27475/</id>
    <published>2023-03-23T13:46:03.000Z</published>
    <updated>2023-03-23T13:46:03.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用UnrealEngine开发工具时，有相当一部分的情况是对资源处理和数据导出需求，这些任务是需要频繁且自动化执行的，通常会把它们集成到CI/CD系统中。&lt;/p&gt;
&lt;p&gt;在具体的实现中，就要利用UE的&lt;code&gt;Commandlet&lt;/code&gt;机制，用命令行的形式去驱动引擎，做自定的行为。&lt;/p&gt;
&lt;p&gt;以我开发的插件中支持的Commandlet功能为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/10938/&quot;&gt;HotPatcher&lt;/a&gt;：导出基础包信息、打包补丁&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/22655/&quot;&gt;ResScannerUE&lt;/a&gt;：变动资源的增量扫描&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/24350/&quot;&gt;HotChunker&lt;/a&gt;：独立打包Chunk&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/26943/&quot;&gt;libZSTD&lt;/a&gt;：训练Shader字典&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/20203/&quot;&gt;ExportNavMesh&lt;/a&gt;：导出NavMesh数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Commandlet能够使它们比较方便地集成到CI/CD中，实现自动化。&lt;/p&gt;
&lt;p&gt;本篇文章中，我将会主要介绍UE的Commandlet机制，并分析它的实现原理，以及提供一些开发技巧、我在开发过程中的一些思考等。&lt;/p&gt;
&lt;p&gt;同时，这也是我&lt;a href=&quot;https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/&quot;&gt;UE插件与工具开发&lt;/a&gt;系列的第二篇文章，后续会持续更新，敬请期待。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>资源管理：重塑UE的包拆分方案</title>
    <link href="https://imzlp.com/posts/37036/"/>
    <id>https://imzlp.com/posts/37036/</id>
    <published>2023-03-15T11:24:32.000Z</published>
    <updated>2023-03-15T11:24:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前我写了一篇文章，介绍UE默认的拆包方式(&lt;a href=&quot;https://imzlp.com/posts/13765/&quot;&gt;UE 热更新：拆分基础包&lt;/a&gt;)，但UE默认的拆包方式在大规模资源项目中不够灵活，无法满足对超大规模资源项目的精细化管理需求。&lt;/p&gt;
&lt;p&gt;为了解决&lt;a href=&quot;https://imzlp.com/posts/37036/#UE%E9%BB%98%E8%AE%A4%E6%89%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;UE默认打包和资源拆分的痛点&lt;/a&gt;，我基于HotPatcherCore开发了一个扩展，能够能够解决默认拆包流程的缺点，足够地灵活与强大。博客中有篇文章，介绍它的整体实现机制： &lt;a href=&quot;https://imzlp.com/posts/24350/&quot;&gt;一种灵活与非侵入式的基础包拆分方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;HotChunker能够非侵入式地集成到UE默认的打包流程中，无需手动做任何的处理，只要UE默认打包，就会自动拉起HotChunker的拆包流程，实现资源的Cook、打包，以及自动Copy到StagedBuilds目录中。&lt;/p&gt;
&lt;p&gt;本篇文章会着重介绍，使用HotChunker在进行资源拆分的配置方式和自动化构建、最大限度地降低资源冗余、以及进行并行打包的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存扩展：UE中利用IOS新的内存特性</title>
    <link href="https://imzlp.com/posts/56381/"/>
    <id>https://imzlp.com/posts/56381/</id>
    <published>2023-01-31T10:37:38.000Z</published>
    <updated>2023-01-31T10:37:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;内存优化是游戏开发中经常关注的课题，为了避免App过度分配内存触发OOM被系统强杀，通常的优化手段是从使用层面入手，提升内存的利用效率，裁剪不需要的功能、控制加载的资源等等。&lt;/p&gt;
&lt;p&gt;但还有一种情况，提升App触发OOM的阈值，让系统允许我们的App分配更多的内存。在新的IOS版本中，苹果为App引入了新的内存特性，可以允许App扩展寻址空间和提高可分配内存。&lt;/p&gt;
&lt;p&gt;本篇文章，我将研究如何把这些特性在UE内利用起来，提高游戏在IOS平台的可分配内存总量。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="内存优化" scheme="https://imzlp.com/categories/UnrealEngine/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Profiling" scheme="https://imzlp.com/tags/Profiling/"/>
    
    <category term="内存优化" scheme="https://imzlp.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="Memory" scheme="https://imzlp.com/tags/Memory/"/>
    
    <category term="IOS" scheme="https://imzlp.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>UE插件与工具开发：基础概念</title>
    <link href="https://imzlp.com/posts/75405/"/>
    <id>https://imzlp.com/posts/75405/</id>
    <published>2023-01-29T12:12:55.000Z</published>
    <updated>2023-01-29T12:12:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用UnrealEngine进行项目开发的过程中，经常会开发和接入各种类型的插件来对引擎进行扩展，从而实现不同的需求。对于开发者而言，对运行机制的理解优于工具的使用。所以对于插件的接入和开发，有必要了解其原理。&lt;/p&gt;
&lt;p&gt;之前我也开发了一些UE的工具和插件，我希望写一个相关的系列文章，把UE插件与工具开发相关具有共性的技术内容做一些总结，并分享一些我开发插件时的一些思考和功能脚手架。尽可能用最少的代码、最小的侵入式和最佳的实现策略，来实现需要的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Tools" scheme="https://imzlp.com/tags/Tools/"/>
    
    <category term="Plugins" scheme="https://imzlp.com/tags/Plugins/"/>
    
  </entry>
  
  <entry>
    <title>HotPatcher的模块化改造和开发规划</title>
    <link href="https://imzlp.com/posts/30178/"/>
    <id>https://imzlp.com/posts/30178/</id>
    <published>2023-01-07T11:25:54.000Z</published>
    <updated>2023-01-07T11:25:54.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;随着&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的开发以及我对于资源管理方面的技术的研究，围绕着&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;实现的功能越来越多，实现也越来越复杂，加上引擎的不断更新，一个大而全的插件对引擎的兼容性越来越难以维护。&lt;/p&gt;
&lt;p&gt;随着新一代引擎UE5的到来，&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;同样会跟进UE5中支持，并针对UE5的特性开发新的功能。我希望它不仅仅只是一个资源打包工具，而是包含资源管理、审计、打包、热更新、包体优化、构建提升等等全方位的资源管理方案，并且作为一个开放式的资源处理框架。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2022/202301071731545.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章会介绍&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的模块化进展，对现有功能的支持。以及如何利用&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;强大的打包能力根据项目需求进行自定义的模块化扩展。最后，会介绍&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;项目后续的开发计划。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/HotPatcher/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/HotPatcher/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2022 Unreal Open Day</title>
    <link href="https://imzlp.com/posts/10975/"/>
    <id>https://imzlp.com/posts/10975/</id>
    <published>2022-11-20T10:04:57.000Z</published>
    <updated>2022-11-20T10:04:57.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;2022年的Unreal Open Day是Epic官方以线下活动+线上直播的形式进行的，很开心今年参加了线下的Unreal Open Day活动。&lt;br&gt;今年我录制了一场线上的技术演讲，也去上海直播现场参加了线下活动，很荣幸再次获得了Epic授予的&lt;strong&gt;杰出社区贡献者&lt;/strong&gt;奖项，对我是认可也是激励，期待UE技术社区能发展的越来越好，成为最为活跃的游戏开发者社区。&lt;br&gt;本篇文章做一个简单的记录，把 UOD 2022的资料做一下整理，也把我参加 UOD 的视频、演讲 PPT，以及相关的资料做一个总结，还有一些在 UOD 直播现场拍的照片。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="UOD" scheme="https://imzlp.com/categories/UnrealEngine/UOD/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UOD" scheme="https://imzlp.com/tags/UOD/"/>
    
    <category term="UnrelOpenDay" scheme="https://imzlp.com/tags/UnrelOpenDay/"/>
    
  </entry>
  
  <entry>
    <title>一种灵活与非侵入式的基础包拆分方案</title>
    <link href="https://imzlp.com/posts/24350/"/>
    <id>https://imzlp.com/posts/24350/</id>
    <published>2022-10-23T15:20:00.000Z</published>
    <updated>2022-10-23T15:20:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE默认的资源管理较为复杂，默认情况下是根据在&lt;code&gt;ProjectSetting&lt;/code&gt;里配置的地图、目录、PrimaryAsset的配置，以及对一些条件的组合检测来执行资源打包过程的。并且，UE的Cook是根据运行时的动态加载来实时添加资源打到包中的，这导致打包的资源进包过程几乎等同于黑盒。&lt;/p&gt;
&lt;p&gt;博客中介绍&lt;strong&gt;默认的进包资源规则&lt;/strong&gt;及&lt;strong&gt;基础包拆分&lt;/strong&gt;的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/22570/&quot;&gt;UE 资源管理：引擎打包资源分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/13765/&quot;&gt;UE 热更新：拆分基础包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章提供了一种新的思路，利用&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的精确Cook和打包机制，实现了一个HotChunker的Mod，能够对引擎的&lt;strong&gt;非侵入式&lt;/strong&gt;，直接&lt;strong&gt;复用UE默认打包过程&lt;/strong&gt;、&lt;strong&gt;简单清晰&lt;/strong&gt;地进行拆分基础包。本篇文会具体介绍使用方式以及实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：如何写好一篇技术文章</title>
    <link href="https://imzlp.com/posts/23932/"/>
    <id>https://imzlp.com/posts/23932/</id>
    <published>2022-09-12T20:18:36.000Z</published>
    <updated>2022-09-12T20:18:36.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;技术文章是能够有效锻炼&lt;strong&gt;表达能力&lt;/strong&gt;和进行&lt;strong&gt;技术积累&lt;/strong&gt;的方法。与单纯的技术笔记不同，我认为的技术文章应该是对&lt;strong&gt;实际的问题&lt;/strong&gt;或&lt;strong&gt;新技术思路&lt;/strong&gt;的解决方案，而不是技术点的简单堆砌。&lt;/p&gt;
&lt;p&gt;对于如何写一篇我认为合格的技术文章， 最近做了一些思考，本篇文章会探讨我写文章时的一些思路和步骤，以及工具推荐和CI/CD自动化发布的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="方法论" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>UE中ASTC贴图压缩分析及效率优化</title>
    <link href="https://imzlp.com/posts/7181/"/>
    <id>https://imzlp.com/posts/7181/</id>
    <published>2022-09-08T19:01:53.000Z</published>
    <updated>2022-09-08T19:01:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ASTC&lt;/code&gt;是&lt;code&gt;Adaptive Scalable Texture Compression&lt;/code&gt;的简称，是在移动端流行的贴图压缩方案。当平台使用ASTC打包时，UE默认使用&lt;a href=&quot;https://github.com/GameTechDev/ISPCTextureCompressor&quot;&gt;Intel ISPC Texture Compressor&lt;/a&gt;压缩贴图，但它具有一些局限性，只支持&lt;code&gt;8x8&lt;/code&gt;及以上的压缩规格，&lt;code&gt;10x10&lt;/code&gt;和&lt;code&gt;12x12&lt;/code&gt;则不支持，如果在项目中指定它们，也是会使用&lt;code&gt;8x8&lt;/code&gt;的规格。除&lt;a href=&quot;https://github.com/GameTechDev/ISPCTextureCompressor&quot;&gt;ISPC&lt;/a&gt;外，引擎中也提供了ARM的&lt;a href=&quot;https://github.com/ARM-software/astc-encoder&quot;&gt;astc-encoder&lt;/a&gt;压缩方式，可以支持&lt;code&gt;8x8&lt;/code&gt;以下的规格，但默认未启用，而且引擎中的集成压缩效率非常低，在大规模资源中，使用&lt;a href=&quot;https://github.com/ARM-software/astc-encoder&quot;&gt;astc-encoder&lt;/a&gt;压缩贴图对Cook耗时是非常大的挑战。&lt;/p&gt;
&lt;p&gt;本篇文章分析UE中贴图使用ASTC压缩的配置以及实现方式，以及引擎中&lt;a href=&quot;https://github.com/ARM-software/astc-encoder&quot;&gt;astc-encoder&lt;/a&gt;的压缩效率和优化思路。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="ASTC" scheme="https://imzlp.com/categories/UnrealEngine/ASTC/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
    <category term="ASTC" scheme="https://imzlp.com/tags/ASTC/"/>
    
    <category term="贴图压缩" scheme="https://imzlp.com/tags/%E8%B4%B4%E5%9B%BE%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="包体优化" scheme="https://imzlp.com/tags/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UE中多阶段的自动化资源检查方案</title>
    <link href="https://imzlp.com/posts/22655/"/>
    <id>https://imzlp.com/posts/22655/</id>
    <published>2022-08-23T11:30:21.000Z</published>
    <updated>2022-08-23T11:30:21.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在大型项目中，资源的规模非常庞大，涉及的制作团队也非常广泛，场景、角色、UI、动画、特效、蓝图、数据表格等等，随之而来就是资源量和资源规范的管理难以把控。&lt;/p&gt;
&lt;p&gt;对于制定的资源规格，美术制作人员难以覆盖100%的情况，会存在不经意间漏掉，大多数情况下都是包内发现问题后再处理，而且对于存量的资源，需要耗费大量的人力处理，难以审查和修复。&lt;/p&gt;
&lt;p&gt;基于这种痛点，我之前开发了一个资源扫描工具，可以方便地编辑规则对项目内的资源进行扫描。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/71162/&quot;&gt;UE 中利用反射为资产建立属性缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/19901/&quot;&gt;UE 中资源自修正的设计与实现方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/22655/&quot;&gt;UE 中多阶段的自动化资源检查方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/20376/&quot;&gt;基于ResScannerUE的资源检查自动化实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;UE资源合规检查工具ResScannerUE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;近期，我对插件做了全方面地升级，增强了编辑时和自动化检查的能力，本篇文章会介绍如何利用&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;实现&lt;strong&gt;编辑时&lt;/strong&gt;、&lt;strong&gt;提交时&lt;/strong&gt;、&lt;strong&gt;CI定时或Hook任务&lt;/strong&gt;、&lt;strong&gt;Cook时&lt;/strong&gt;等各个阶段的资源扫描，把错误地资源尽可能地在制作时暴露出来并提示解决，避免包内资源异常。&lt;/p&gt;
&lt;p&gt;在插件的具体实现上，也针对扫描速度做了很多优化，尽可能把检查变成一个无感知的行为，文章内会具体介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="ResScanner" scheme="https://imzlp.com/tags/ResScanner/"/>
    
  </entry>
  
  <entry>
    <title>一种高效的ZSTD Shader字典训练方案</title>
    <link href="https://imzlp.com/posts/26943/"/>
    <id>https://imzlp.com/posts/26943/</id>
    <published>2022-07-14T13:01:54.000Z</published>
    <updated>2022-07-14T13:01:54.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在文章&lt;a href=&quot;https://imzlp.com/posts/24725/&quot;&gt;基于 ZSTD 字典的 Shader 压缩方案&lt;/a&gt;中，我介绍了一种利用ZSTD字典压缩UE的ShaderCode的方法，可以极大地提升ShaderLibrary的压缩比。但训练字典和使用字典进行压缩的流程仍然比较复杂，并不是一个高效的工程实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需关闭引擎默认的Shader压缩&lt;/li&gt;
&lt;li&gt;Cook一遍项目才能Dump每个Unique Shader的ShaderCode&lt;/li&gt;
&lt;li&gt;基于Dump出的ShaderCode文件，使用ZSTD程序训练字典&lt;/li&gt;
&lt;li&gt;再次执行完整的Cook过程，使用字典进行压缩，生成最终的shaderbytecode&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据上述的流程，需要变动引擎才能实现Dump ShaderCode；其次是流程的割裂，Dump ShaderCode之后需要拉起&lt;code&gt;zstd&lt;/code&gt;程序执行训练才能得到字典；最后，仍需要再Cook一遍工程，使用训练出的字典压缩Shader。并且在关掉Shader的压缩后会导致使用LZ4压缩的DDC Cache Miss，重复Cook执行的时间开销巨大，在海量Shader的项目中耗时无法接受。&lt;/p&gt;
&lt;p&gt;基于这种痛点，我研究并实现了一种高效的字典训练方法，无需修改引擎，并且十分快速地训练字典和基于字典压缩。能够直接从ushaderbytecode中训练字典，并生成使用ZSTD+字典压缩的ushaderbytecode，极大地提升了处理效率，完全Plugin-Only的实现，接入成本几乎为零，后续将作为&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的扩展模块发布。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="ZSTD" scheme="https://imzlp.com/tags/ZSTD/"/>
    
    <category term="ushaderbytecode" scheme="https://imzlp.com/tags/ushaderbytecode/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎中Pak的运行时重组方案</title>
    <link href="https://imzlp.com/posts/12188/"/>
    <id>https://imzlp.com/posts/12188/</id>
    <published>2022-05-23T11:03:22.000Z</published>
    <updated>2022-05-23T11:03:22.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Pak是UE中的UFS中的一环（Unreal File System），是在应用层构造的一种虚拟文件系统。用于把游戏相关的资源、文件打包至一个Pak文件中，避免在运行时对游戏资源的访问创建出大量的文件句柄，并且可以做读缓存（PakCache），提升加载效率。&lt;/p&gt;
&lt;p&gt;并且，在UFS中，可以控制每个Pak的优先级，可以用来控制文件系统中文件的优先级。在通过UFS加载文件时，优先级高的Pak中的文件会被首先命中，就可以替换掉低优先级的文件，这也是UE实现热更新的关键，详见之前的&lt;a href=&quot;https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/&quot;&gt;热更新系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但默认情况下，Pak的打包都是在UE端进行的，&lt;code&gt;PakUtilities&lt;/code&gt;和&lt;code&gt;UnrealPak&lt;/code&gt;都是开发端的功能，运行时不存在，这意味着不能在运行时创建出Pak文件。但Pak本身是Archive的文件形式，理论上是可以进行运行时重组的。&lt;/p&gt;
&lt;p&gt;本篇文章就从Pak的创建、文件格式、UFS分析、运行时重组可行性等方面着手，探讨运行时重组Pak的实现细节以及应用方向。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Pak" scheme="https://imzlp.com/categories/UnrealEngine/Pak/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Pak" scheme="https://imzlp.com/tags/Pak/"/>
    
  </entry>
  
  <entry>
    <title>基于ZSTD字典的Shader压缩方案</title>
    <link href="https://imzlp.com/posts/24725/"/>
    <id>https://imzlp.com/posts/24725/</id>
    <published>2022-04-17T17:37:38.000Z</published>
    <updated>2022-04-17T17:37:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;随着项目规模的日益增大，UE里Shader的变体数量逐渐累增，往往能够达到数百万的Shader变体，虽然UE为了避免Shader的重复存储提供了&lt;code&gt;Share Material Shader Code&lt;/code&gt;功能，可以把Shader序列化到一个独立的&lt;code&gt;ushaderbytecode&lt;/code&gt;文件中，但也会占用几百M的包体大小。而UE默认情况下，把这些NotUAsset文件默认进Chunk0，即必须进基础包，对于移动端的基础包影响很大，几百M的空间，可以放很多资源了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，只能从三个方面入手：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低项目中的变体数量，Dump出项目中的Shader信息，分析哪些是不必要的；&lt;/li&gt;
&lt;li&gt;拆分shaderbytecode，基础包中只包含必要的Shader，其余按需下载。但UE默认没有提供这样的机制，可以使用我开发的&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;拆分基础包，生成多个shader lib，使用热更流程动态下载资源和所需的shaderbytecode。&lt;/li&gt;
&lt;li&gt;使用压缩率更高的算法来对ShaderCode进行压缩，引擎中默认使用LZ4；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方式需要TA和美术协同实现，想要有显著的提升较为困难。第二种方案详见之前的热更新系列文章（&lt;a href=&quot;https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/&quot;&gt;Unreal Engine#热更新&lt;/a&gt;）。本篇文章从第三种方式入手，为Shader实现了一种特殊的压缩方式，可以有效地降低shaderbytecode的大小，大幅度提升Shader的压缩比，并且可以与方案2结合使用，在拆分shaderbytecode的同时，大幅度提高压缩率。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="优化" scheme="https://imzlp.com/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="Shader" scheme="https://imzlp.com/tags/Shader/"/>
    
    <category term="Compression" scheme="https://imzlp.com/tags/Compression/"/>
    
  </entry>
  
  <entry>
    <title>高效调试：命令行参数启动UE Android App</title>
    <link href="https://imzlp.com/posts/29169/"/>
    <id>https://imzlp.com/posts/29169/</id>
    <published>2022-01-01T19:58:02.000Z</published>
    <updated>2022-01-01T19:58:02.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用UE开发的过程中，指定命令行参数（Command Line）是一个经常会用到的功能，可以方便地控制部分流程、开关等。UE也是大量地使用了Comandline来控制引擎的行为，官方文档：&lt;a href=&quot;https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/CommandLineArguments/&quot;&gt;Command-Line Arguments&lt;/a&gt;，不同的模块都可以从Commandline中读取或检查参数，实现自定义的命令行参数功能。&lt;/p&gt;
&lt;p&gt;但是，对于移动端Android平台，并不能很方便地指定启动参数，需要编辑&lt;code&gt;ue4commandline.txt&lt;/code&gt;文件，非常繁琐。&lt;/p&gt;
&lt;p&gt;基于这种痛点需求，我利用元旦的假期开发一个UE的Android的插件，可以让Android的程序像PC一样方便启动和指定命令行参数，并且不需要修改引擎，启用插件后打包Apk即可使用，开源在Github上：&lt;a href=&quot;https://github.com/hxhb/AppCmderUE&quot;&gt;hxhb/AppCmderUE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/picgo/2023/20230118171536.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章分析了UE在Androdid端Commandline的读取规则，并介绍了&lt;a href=&quot;https://github.com/hxhb/AppCmderUE&quot;&gt;AppCmderUE&lt;/a&gt;插件的实现原理与使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Debugging" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/Debugging/"/>
    
    <category term="Android" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/Debugging/Android/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
    <category term="Debugging" scheme="https://imzlp.com/tags/Debugging/"/>
    
  </entry>
  
  <entry>
    <title>UE资源管理：引擎打包资源分析</title>
    <link href="https://imzlp.com/posts/22570/"/>
    <id>https://imzlp.com/posts/22570/</id>
    <published>2021-12-31T14:33:25.000Z</published>
    <updated>2021-12-31T14:33:25.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;默认情况下，在UE中打包项目时，会拉起BuildCookRun来执行Compile/Cook/Pak/Stage等一系列流程。在UE中，只有参与Cook的资源才会被打包，但是通常会包含很多预期之外的资源，可能会造成困扰，到底引擎依赖哪些资源？以及该如何管理UE参与打包的资源。&lt;/p&gt;
&lt;p&gt;本篇文章从UE打包时分析资源进行Cook的规则入手，研究在打包时究竟会将哪些资源进行Cook，了解这一点对于资源管理很有作用，基于此可以实现自定义的Cook过程，将Cook任务分配至不同的进程乃至机器实现并行化，加速UE的构建过程。&lt;/p&gt;
&lt;p&gt;除了uasset这些资源外，打包时还有很多Non-Asset文件，如ini、Shader Library、AssetRegistry、或者项目中添加的脚本文件等等，在之前的文章&lt;a href=&quot;https://imzlp.com/posts/17371/&quot;&gt;UE热更新：需求分析与方案设计&lt;/a&gt;中有过介绍，UE对于它们的&lt;strong&gt;收集&lt;/strong&gt;并不在Cook阶段（Shader Library和AssetRegistry是在Cook阶段生成），本篇文章暂不作讨论，后续会写一篇专门介绍的文章。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：我的2021年度总结</title>
    <link href="https://imzlp.com/posts/24854/"/>
    <id>https://imzlp.com/posts/24854/</id>
    <published>2021-12-23T20:58:35.000Z</published>
    <updated>2021-12-23T20:58:35.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;我一直希望做的所有事情都是可以量化、能够被记录的，不然一年又一年循环往复会记不起自己到底做了什么事情，所以会做一个年度总结。&lt;/p&gt;
&lt;p&gt;2021年马上结束，回想这一年，发生了许多事，有了很多新的想法，也是对我影响最大的一年。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="年度总结" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="年度总结" scheme="https://imzlp.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>循迹研究：分析流量数据的二三事</title>
    <link href="https://imzlp.com/posts/14354/"/>
    <id>https://imzlp.com/posts/14354/</id>
    <published>2021-11-21T10:25:13.000Z</published>
    <updated>2021-11-21T10:25:13.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;近期查看了博客Google Analysic的访问数据，通过流量分析发现一些很有意思的点，能够在一定程度上体现出在使用虚幻引擎进行游戏开发方面的用户特征。文章内的数据样本为本站2021.11.14-2021.11.20一周的访问流量，总体数据量有限不一定能体现出真实趋势，仅供参考。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="数据分析" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="数据分析" scheme="https://imzlp.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UE5：Game Feature预研</title>
    <link href="https://imzlp.com/posts/17658/"/>
    <id>https://imzlp.com/posts/17658/</id>
    <published>2021-11-17T12:31:24.000Z</published>
    <updated>2021-11-17T12:31:24.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE5的预览宣传视频里，介绍了一种模块化开发GamePlay的机制，类似于Mod式地开发和管理游戏功能和资源，被称作“Game Feature”，在UE4.27和UE5中已经可以启用了，我觉得这个新的Gameplay Modualr形式很棒，所以做一个技术预研。&lt;/p&gt;
&lt;p&gt;本篇文章介绍Game Feature的启用流程和运行机制介绍，文末分享了一个基于Game Feature的展示Demo。并为&lt;a href=&quot;https://imzlp.com/posts/17590&quot;&gt;HotPatcher&lt;/a&gt;实现了能够将Feature独立打包的机制，Game Feature不必预先打包进基础包内，可以在运行中按需下载与加载，实现真正意义上的独立地模块化加载。&lt;/p&gt;
&lt;p&gt;目前UE5 EA版本中还有不完善的地方，相关的内容也会随着引擎的更新进行补充。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="GameFeature" scheme="https://imzlp.com/categories/UnrealEngine/GameFeature/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="GameFeature" scheme="https://imzlp.com/tags/GameFeature/"/>
    
    <category term="GameplayModular" scheme="https://imzlp.com/tags/GameplayModular/"/>
    
  </entry>
  
  <entry>
    <title>开源一个虚幻引擎启动器UE Launcher</title>
    <link href="https://imzlp.com/posts/3635/"/>
    <id>https://imzlp.com/posts/3635/</id>
    <published>2021-11-10T14:17:15.000Z</published>
    <updated>2021-11-10T14:17:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;通常在使用UE进行项目开发时，本地会有多个引擎版本，而Epic Game Launcher只支持安装版引擎的启动，不支持源码编译的引擎。&lt;br&gt;当本地具有多个引擎版本时，切换不方便，并且没有一种便捷地启动引擎工具、项目以及给项目添加启动参数的方式，在执行Commandlet时需要创建很多脚本，管理非常麻烦。基于这些痛点，我开发了一个UE启动器：&lt;a href=&quot;https://github.com/hxhb/UE4Launcher&quot;&gt;UELauncher&lt;/a&gt;，用来解决这些问题，同时支持UE4和UE5。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="工具开发" scheme="https://imzlp.com/categories/UnrealEngine/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="工具开发" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    <category term="Launcher" scheme="https://imzlp.com/tags/Launcher/"/>
    
    <category term="Tools" scheme="https://imzlp.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>基于ResScannerUE的资源检查自动化实践</title>
    <link href="https://imzlp.com/posts/20376/"/>
    <id>https://imzlp.com/posts/20376/</id>
    <published>2021-10-25T15:49:18.000Z</published>
    <updated>2021-10-25T15:49:18.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;对于项目中的资源检查需求，需要能够实现简单且方便地配置、自动化地执行，并且能够及时地定位相关人员。基于这个需求，我开源了一个资源合规扫描工具&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;，配置文档：&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;UE 资源合规检查工具 ResScannerUE&lt;/a&gt;。&lt;br&gt;本篇文章将介绍如何通过该工具，实现资源扫描的自动化，并提供了与Git结合的方式进行增量检测支持，使用Commandlet在CI平台上实现Content内容变更的自动触发并执行检测规则，并能够定位到出问题资源最近提交人，实现精确定位，实时发送扫描报告至企业微信，提醒通知相关人员进行处理。&lt;br&gt;另外，我还提供了基于Git的Pre-Commit Hook实现，可以在提交之前检测本次提交是否具有不合规资源，并禁止提交，避免问题资源污染远程仓库。整体方案经过了精心设计和大量体验优化、增强自动化支持，可以非常方便地配置、接入，能够实现各种资源扫描的需求。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="ResScanner" scheme="https://imzlp.com/tags/ResScanner/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎中的属性面板定制化</title>
    <link href="https://imzlp.com/posts/26919/"/>
    <id>https://imzlp.com/posts/26919/</id>
    <published>2021-10-25T09:34:21.000Z</published>
    <updated>2021-10-25T09:34:21.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在UE中开发编辑器插件时，通过USTRUCT的反射信息自动创建属性面板是非常方便提供配置化的方式，但经常会有一些特殊的属性面板定制需求，比如提供特殊的面板选项、根据参数的不同展示不同类型的值等。UE中的属性面板在&lt;a href=&quot;https://imzlp.com/posts/17590/&quot;&gt;HotPatcher&lt;/a&gt;和&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;中都有应用，能够非常方便地进行插件地配置与定制化。UE的官方文档：&lt;a href=&quot;https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Slate/DetailsCustomization/&quot;&gt;Details Panel Customization&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本篇文章从创建独立的&lt;code&gt;Details&lt;/code&gt;面板入手，通过&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;中的具体案例，提供属性面板和属性条目的自定义的实现方法。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Slate" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/Slate/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Slate" scheme="https://imzlp.com/tags/Slate/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：Config的重载与应用</title>
    <link href="https://imzlp.com/posts/9028/"/>
    <id>https://imzlp.com/posts/9028/</id>
    <published>2021-10-18T14:57:38.000Z</published>
    <updated>2021-10-18T14:57:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在UE引擎中有大量的配置使用ini来进行设置与控制。对于项目而言，了解其中哪些是能够更新的，能够对制定项目的更新内容规则有帮助。并且，UE很多功能都是通过CVars等方式实现的配置化和动态开关以及对指定平台或设备的Device Profiles设置，同样可以在热更中实现运行中配置的动态下发及应用。&lt;br&gt;本篇文章从引擎机制分析ini config的加载流程、以及不同的配置模块在热更之后重载、在项目中如何应用等内容，基于Ini配置文件的热更实现运行时引擎或项目中参数的修改、reapply，增强游戏的更新能力。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>UE资源合规检查工具ResScannerUE</title>
    <link href="https://imzlp.com/posts/11750/"/>
    <id>https://imzlp.com/posts/11750/</id>
    <published>2021-09-15T15:29:18.000Z</published>
    <updated>2021-09-15T15:29:18.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在游戏项目开发中，因为资源量大，涉及人员广，比较难自觉地统一资源规范，如果资源出现问题，手动排查要花费大量的人力，这也是资源管理的风险和痛点。&lt;br&gt;基于这种需求，我开发了一款编辑器下的资源扫描规范工具&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;，可以非常方便地配置规则并实现自动化，由美术人员在资源提交前、定期执行等方式，提前检查项目中的资源是否合规，避免在打包后才发现问题。&lt;br&gt;本篇文章介绍&lt;a href=&quot;https://imzlp.com/posts/11750/&quot;&gt;ResScannerUE&lt;/a&gt;插件的使用方法、运行机制、自定义规则的扩展方式，以及后续的优化安排。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/categories/UnrealEngine/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="资源管理" scheme="https://imzlp.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    <category term="ResScanner" scheme="https://imzlp.com/tags/ResScanner/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：Shader更新策略</title>
    <link href="https://imzlp.com/posts/15810/"/>
    <id>https://imzlp.com/posts/15810/</id>
    <published>2021-09-13T10:24:16.000Z</published>
    <updated>2021-09-13T10:24:16.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的一些文章中，介绍了UE热更新丢失Shader使用默认材质的处理问题，以及Shader Patch的方案。&lt;br&gt;详情可见文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/5867/&quot;&gt;UE 热更新：Create Shader Patch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/16895/#%E7%83%AD%E6%9B%B4%E7%9A%84%E8%B5%84%E6%BA%90%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C-%E6%9D%90%E8%B4%A8%E4%B8%A2%E5%A4%B1&quot;&gt;UE热更新：Questions &amp;amp; Answers#热更的资源没有效果/材质丢失&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/notes/ue/index/UE4/pak-shadercode-error-in-ue425.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实运行时丢失材质的根本原因是新添加或修改的资源所依赖的Shader没有被打包，运行时读取失败导致的错误。本篇文章来介绍一下Shader更新的策略和优缺点，以及对引擎内机制的分析，并提供一个结合Shader Patch与Inline Shader Code优点的优化方案，已经在&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPacther&lt;/a&gt;中实现。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Shader" scheme="https://imzlp.com/tags/Shader/"/>
    
    <category term="InlineShaderCode" scheme="https://imzlp.com/tags/InlineShaderCode/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：资源的二进制补丁方案</title>
    <link href="https://imzlp.com/posts/25136/"/>
    <id>https://imzlp.com/posts/25136/</id>
    <published>2021-09-06T16:27:10.000Z</published>
    <updated>2021-09-06T16:27:10.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;先前介绍了一系列UE中热更新工程实践的文章，能够实现基于原始工程的资源的版本比对与差异更新。但默认情况下资源的更新是基于文件的更新，某个资源产生了变动，就要将该资源的文件完整地打包进去，而UE的资源变动在Cook之后并不会造成整个文件的全部更新，序列化时只变动了某些bytes。在这种情况下，基于文件的Patch机制能够大幅度减少补丁的大小，本篇文章对二进制补丁的生成和加载方案做一个概述，以&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;为基础，可以方便地实现二进制补丁的生成。&lt;br&gt;为了实现这个需求，我将HDiffPatch移植到了UE内，将其作为&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;默认的二进制差异补丁的DIFF/PATCH算法，基于Modular Feature方式也可以方便地扩展其他的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE As Lib机制初探</title>
    <link href="https://imzlp.com/posts/26475/"/>
    <id>https://imzlp.com/posts/26475/</id>
    <published>2021-08-24T09:34:30.000Z</published>
    <updated>2021-08-24T09:34:30.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE4.27推出了一项新的机制，可以把UE编译成库，能够嵌入到外部程序中，由其他的程序来驱动引擎的执行与消息通信。但是目前官方还没有放出任何有价值的文档，我分析了引擎中的相关代码，提出一个UE as Lib的实践方案，理论上也能在4.27之前的引擎版本实现，或许会与后续官方发布的文档不一致，权当抛砖引玉。相关的研究内容也会在本篇文章中持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UEAsLib" scheme="https://imzlp.com/tags/UEAsLib/"/>
    
  </entry>
  
  <entry>
    <title>Profiling IOS With Unreal Insights</title>
    <link href="https://imzlp.com/posts/14154/"/>
    <id>https://imzlp.com/posts/14154/</id>
    <published>2021-08-19T14:14:48.000Z</published>
    <updated>2021-08-19T14:14:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Unreal Insights是UE自4.23之后提供的一个Profiling工具，可以非常方便地看到游戏运行的各个线程的火焰图，但是官方文档只提供了PC和Android的连接方法，并不直接支持IOS，不太方便。研究了一下发现IOS主要是网络策略的问题，本篇文章提供一个UE与IOS设备的真机Profliing以及端口互通方案，可以支持实时的Profiling以及Cook on the fly等IOS真机与PC数据互通的需求。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Profiling" scheme="https://imzlp.com/categories/UnrealEngine/Profiling/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Profiling" scheme="https://imzlp.com/tags/Profiling/"/>
    
    <category term="IOS" scheme="https://imzlp.com/tags/IOS/"/>
    
    <category term="UnrealInsights" scheme="https://imzlp.com/tags/UnrealInsights/"/>
    
  </entry>
  
  <entry>
    <title>UE多用户协同编辑服务部署指南</title>
    <link href="https://imzlp.com/posts/25226/"/>
    <id>https://imzlp.com/posts/25226/</id>
    <published>2021-08-05T16:15:28.000Z</published>
    <updated>2021-08-05T16:15:28.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在大世界项目以及疫情导致的远程办公需求，开发中的协同编辑显得格外重要。在UE的资源机制中，地图是单个的资源，虽然可以使用Sub-level的形式拆分，但是最小元素仍然是单个资源，当不同的Designer修改相同的资源时，就会造成文件冲突，也没办法像文本那样合并。并且每个人负责编辑单个子关卡也没有办法实时预览整个场景的效果，在协同开发中，这是一个瓶颈。&lt;br&gt;在UE4.23之后，UE官方推出了一个多人协作机制，可以使多人共同地编辑同一份地图，并不会造成冲突，并且可以同步其他变动的资源并能够实时生效，作为版本控制的补充，能够比较完美地解决同步协作的问题。&lt;br&gt;本篇文章记录一下启用流程、使用规范以及网络策略等问题，也会提取独立的Server端程序而无需依赖完整的引擎，实现Server端的方便部署。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="工具开发" scheme="https://imzlp.com/categories/UnrealEngine/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UnrealMultiUserServer" scheme="https://imzlp.com/tags/UnrealMultiUserServer/"/>
    
    <category term="多用户协同" scheme="https://imzlp.com/tags/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C/"/>
    
  </entry>
  
  <entry>
    <title>Zlib/Oodle/ZSTD压缩算法性能对比</title>
    <link href="https://imzlp.com/posts/30732/"/>
    <id>https://imzlp.com/posts/30732/</id>
    <published>2021-07-06T19:59:39.000Z</published>
    <updated>2021-07-06T19:59:39.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前我写了一篇文章，在UE中集成了ZSTD压缩算法：&lt;a href=&quot;https://imzlp.com/posts/8470/&quot;&gt;ModularFeature：为 UE4 集成 ZSTD 压缩算法&lt;/a&gt;，并且把UE5中的Oodle的压缩算法库提取出来，可以在UE4中使用：&lt;a href=&quot;https://imzlp.com/notes/ue5/#Oodle-Compression&quot;&gt;Oodle Compression&lt;/a&gt;。最近分析了一下他们的压缩、解压、CPU、内存的消耗，分别测试了WindowsNoEditor/Android_ASTC/IOS三个平台，以及Oodle的Kraken使用不同的压缩级别在不同平台的性能。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="压缩算法" scheme="https://imzlp.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    <category term="Oodle" scheme="https://imzlp.com/tags/Oodle/"/>
    
    <category term="zstd" scheme="https://imzlp.com/tags/zstd/"/>
    
    <category term="zlib" scheme="https://imzlp.com/tags/zlib/"/>
    
  </entry>
  
  <entry>
    <title>UE5：新一代虚幻引擎初探</title>
    <link href="https://imzlp.com/posts/8724/"/>
    <id>https://imzlp.com/posts/8724/</id>
    <published>2021-05-25T12:22:44.000Z</published>
    <updated>2021-05-25T12:22:44.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;终于，在2021年的五月底，UE5终于要推出第一个预览版本了，&lt;a href=&quot;https://mp.weixin.qq.com/s/W0e79uhqOyxLKXeC9MwnDg&quot;&gt;虚幻引擎5——将于中国时间5月26日周三晚10点开启抢先体验计划！&lt;/a&gt;。&lt;br&gt;对UE5期待许久，去年Nanite和lumen一石激起千层浪，时隔一年，终于能够实际体验到了。&lt;br&gt;过去一年，关于UE5的技术消息不多，我做过了一些Epic披露的关于UE5相关的信息总结和分析，有兴趣的可以移步&lt;a href=&quot;https://imzlp.com/notes/ue5/&quot;&gt;notes/ue5&lt;/a&gt;中查看。本篇文章会记录上手UE5的一些体验，相较于UE4开发方式的变动，为UE4到UE5的过渡，以及将UE5应用到生产环境做一个技术预研，近期会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UE5" scheme="https://imzlp.com/tags/UE5/"/>
    
  </entry>
  
  <entry>
    <title>UE项目优化：PSO Cache</title>
    <link href="https://imzlp.com/posts/24336/"/>
    <id>https://imzlp.com/posts/24336/</id>
    <published>2021-04-22T19:40:55.000Z</published>
    <updated>2021-04-22T19:40:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE中具有PSO Cache机制，全称Pipeline State Object Caching，用于预先记录和构建出运行时所使用的材质依赖的Shader信息，当项目首次使用这些Shader时，该列表可以加速Shader的加载/编译过程。PSO Cache会把渲染状态、顶点声明、Primitive类型、RenderTarget像素格式等数据保存到文件中，提升Shader的加载效率。&lt;br&gt;本篇文章主要介绍PSO Cache的启用及构建流程，并会分析PSO Cache在引擎中的加载流程以及实现热更PSO方式、错误处理等，PSO Cache的原理有时间再进行详细分析。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="PSOCache" scheme="https://imzlp.com/categories/UnrealEngine/PSOCache/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="PSOCache" scheme="https://imzlp.com/tags/PSOCache/"/>
    
    <category term="PSO" scheme="https://imzlp.com/tags/PSO/"/>
    
    <category term="优化" scheme="https://imzlp.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UE开发笔记：Android篇</title>
    <link href="https://imzlp.com/posts/17996/"/>
    <id>https://imzlp.com/posts/17996/</id>
    <published>2021-04-15T19:54:12.000Z</published>
    <updated>2021-04-15T19:54:12.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的一篇文章中，介绍了Mac/IOS的开发笔记和一些工程实践：&lt;a href=&quot;https://imzlp.com/posts/1948/&quot;&gt;UE4 开发笔记：Mac/iOS 篇&lt;/a&gt;。本篇文章作为姊妹篇，记录我在使用UE在开发Android时所用的标准化环境、调试工具、工程实践以及分析相关的引擎代码等内容，记录了一些在项目中遇到的坑，主要从我之前的笔记&lt;a href=&quot;https://imzlp.com/notes/ue/&quot;&gt;notes/ue&lt;/a&gt;中整理而来，后续Android相关的内容也都会更新到这篇文章里。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/categories/UnrealEngine/Android/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
    <category term="UPL" scheme="https://imzlp.com/tags/UPL/"/>
    
  </entry>
  
  <entry>
    <title>UE性能分析：内存优化</title>
    <link href="https://imzlp.com/posts/19135/"/>
    <id>https://imzlp.com/posts/19135/</id>
    <published>2021-03-30T10:59:16.000Z</published>
    <updated>2021-03-30T10:59:16.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在开发游戏时，程序性能是需要着重考虑的问题，因为要尽可能覆盖最多的用户群体，就要考虑那些中低端设备的运行效果，兼容非常多配置差异的硬件，在这种情况下，怎么样分析和优化游戏的性能瓶颈是关键。&lt;/p&gt;
&lt;p&gt;在运行时把更多的资源加载至内存中，本质上是一种空间换时间的思路。因为频繁从磁盘进行IO是非常耗时的，把资源预先加载到内存就可以实现高速读取，但是内存资源也是有限的，并不能不加限制地使用，尤其是对某些中低端移动设备而言，4G甚至更小的内存的设备目前还具有不少的占有率，所以在内存方面不能浪费，而且过高的内存占用也有可能导致被系统查杀。&lt;/p&gt;
&lt;p&gt;内存优化本质上就是在加载效率和内存占用之间寻求一个平衡，怎么样在能满足兼容更多低配设备正常运行不触发OOM的同时尽可能地把可利用的内存使用起来，提高程序的运行效率。&lt;/p&gt;
&lt;p&gt;准备写几篇性能优化相关的文章，本篇文章先从UE内存分析入手，介绍常用的内存分析工具和方法，以及对UE项目中能够进行的内存优化手段做一个整理，这部分内容之前以笔记的形式记录在&lt;a href=&quot;https://imzlp.com/notes/ue/&quot;&gt;notes/ue&lt;/a&gt;中，后续内存相关的内容都会补充到本篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Profiling" scheme="https://imzlp.com/categories/UnrealEngine/Profiling/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Profiling" scheme="https://imzlp.com/tags/Profiling/"/>
    
    <category term="内存优化" scheme="https://imzlp.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="Memory" scheme="https://imzlp.com/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：Questions &amp; Answers</title>
    <link href="https://imzlp.com/posts/16895/"/>
    <id>https://imzlp.com/posts/16895/</id>
    <published>2021-03-12T10:45:44.000Z</published>
    <updated>2021-03-12T10:45:44.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;项目开源这一年多以来，经过了不少的更新和优化，也被越来越多的开发者选择作为自己项目的热更新方案，期间有不少人陆陆续续询问UE4热更新相关遇到的问题，很多问题比较常见，重复询问的频率也比较多，所以我准备把一些常见的问题进行整理，方便初步上手UE4热更新方案的人能够尽快地排查问题。&lt;/p&gt;
&lt;p&gt;本篇文章会持续更新UE4热更新和&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;相关的Q&amp;amp;A内容，有疑问的地方也可以直接在本篇文章中评论，我会定期统一回答和整理，也可以加入我的UE4热更新群讨论遇到的问题(QQ群958363331)。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：Create Shader Patch</title>
    <link href="https://imzlp.com/posts/5867/"/>
    <id>https://imzlp.com/posts/5867/</id>
    <published>2021-03-12T09:49:27.000Z</published>
    <updated>2021-03-12T09:49:27.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前的热更新系列文章中介绍了UE热更新的流程和打包细节，其实有一些热更补丁优化的工程实践我觉得也可以详细介绍。&lt;/p&gt;
&lt;p&gt;本篇文章从生成Shader的Patch入手，目的减少每次热更新时的Shader的大小，并会对引擎内部的实现细节做一些分析，解决引擎中的Shader Patch的相关问题，并基于&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的实现自动化的Shade Patch流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2021.11.02 UPDATE：&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;已支持对Patch中所有Cook资源编译的Shader收集起来打包为Shader Library，可以替代Shader Patch的机制。详情见文章：&lt;a href=&quot;https://imzlp.com/posts/15810/&quot;&gt;UE热更新：Shader更新策略&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="ShaderPatch" scheme="https://imzlp.com/tags/ShaderPatch/"/>
    
    <category term="ushaderbytecode" scheme="https://imzlp.com/tags/ushaderbytecode/"/>
    
  </entry>
  
  <entry>
    <title>UE反射实现分析：反射代码生成（一）</title>
    <link href="https://imzlp.com/posts/9780/"/>
    <id>https://imzlp.com/posts/9780/</id>
    <published>2021-03-10T15:14:19.000Z</published>
    <updated>2021-03-10T15:14:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前写了两篇UE中实现反射的文章分析，介绍了UE的反射基础概念和依赖的一些C++特性，本篇文章开始分析UE反射实现的具体流程。&lt;/p&gt;
&lt;p&gt;C++标准中并没有反射的特性，UE使用的反射是基于&lt;strong&gt;标记语法&lt;/strong&gt;和&lt;strong&gt;UHT扫描生成辅助代码&lt;/strong&gt;来实现的一套机制，正如&lt;a href=&quot;https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)&quot;&gt;David Wheeler&lt;/a&gt;的那句名言一样：“&lt;em&gt;All problems in computer science can be solved by another level of indirection&lt;/em&gt;”，UHT做的就是这样的事情，在真正执行编译之前分析标记代码并产生真正的C++代码，收集反射类型的元数据，供运行时之用。&lt;/p&gt;
&lt;p&gt;UHT生成的代码内容很多，为了避免文章组织上的混乱，本篇文章主要讲&lt;code&gt;GENERATED_BODY&lt;/code&gt;/&lt;code&gt;UFUNCTION&lt;/code&gt;等反射标记通过UHT之后生成到&lt;code&gt;generated.h&lt;/code&gt;中的&lt;strong&gt;真正的C++代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UHT生成的代码分别在&lt;code&gt;generated.h&lt;/code&gt;和&lt;code&gt;gen.cpp&lt;/code&gt;中，&lt;code&gt;generated.h&lt;/code&gt;中的代码大多是定义了一些宏，用在所声明的类内通过编译器预处理来添加通用成员，&lt;code&gt;gen.cpp&lt;/code&gt;中的代码则是UHT基于反射标记生成的用来描述类反射信息的具体代码，&lt;code&gt;genrated.h&lt;/code&gt;和&lt;code&gt;gen.cpp&lt;/code&gt;也是为了声明和定义分离。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/UnrealEngine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UHT" scheme="https://imzlp.com/tags/UHT/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：资产管理与审计工具</title>
    <link href="https://imzlp.com/posts/3675/"/>
    <id>https://imzlp.com/posts/3675/</id>
    <published>2021-03-09T18:16:31.000Z</published>
    <updated>2021-03-09T18:16:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在前面的文章中，介绍了基础包的拆分规则和实现，在基础的打包规则稳定之后，日常开发中的关注重点就转向侧重于项目的资产管理和包体资源审计、分析项目中的资产大小和冗余情况等。&lt;/p&gt;
&lt;p&gt;本篇文章介绍UE中的资源打包配置、常用的资产管理方式以及资产审计工具等工程实践，热更新系列文章的资源管理篇，也是对上一篇文章&lt;a href=&quot;https://imzlp.com/posts/13765/&quot;&gt;UE4热更新：拆分基础包&lt;/a&gt;的内容补充。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资产审计" scheme="https://imzlp.com/tags/%E8%B5%84%E4%BA%A7%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：拆分基础包</title>
    <link href="https://imzlp.com/posts/13765/"/>
    <id>https://imzlp.com/posts/13765/</id>
    <published>2021-01-27T21:51:56.000Z</published>
    <updated>2021-01-27T21:51:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的几篇文章中，分别介绍了UE热更新的实现机制，以及热更的自动化流程，近期打算继续写几篇文章介绍下UE里热更新中资源包管理的流程和规则。&lt;/p&gt;
&lt;p&gt;当然，不同类型的项目会有不同的打包策略，资源管理也没有通用的最佳策略。本篇文章主要介绍热更新流程中基础包的拆分的工程实践，涉及修改引擎实现Android/IOS通用拆分方式的方法，希望对不同业务的项目能提供一些有用的思路。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在实际的工程实践中，我们抛弃了UE自带的包拆分方案，基于&lt;a href=&quot;https://imzlp.com/posts/17590/&quot;&gt;HotPatcher&lt;/a&gt;框架实现了一套灵活的包拆分方案，详见文章：&lt;a href=&quot;https://imzlp.com/posts/37036/&quot;&gt;资源管理：重塑 UE 的包拆分方案&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：基于HotPatcher的自动化流程</title>
    <link href="https://imzlp.com/posts/10938/"/>
    <id>https://imzlp.com/posts/10938/</id>
    <published>2021-01-24T12:47:34.000Z</published>
    <updated>2021-01-24T12:47:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;是我之前开源的一个UE4热更新版本管理和资源打包工具，可以方便地进行版本间的差异分析和pak打包。之前的文章为了直观地介绍都是基于手动地在编辑器中进行配置和打包的，在真正的工程实践中，可以自动化的重复操作就要避免手动的参与，较早之前我就在插件中添加了commandlet的支持，近期修复了一些问题以及增加了很多针对commandlet的优化，本篇文章是基于HotPatcher的自动化热更新流程的工程实践。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>对开源的一些思考与想法</title>
    <link href="https://imzlp.com/posts/8890/"/>
    <id>https://imzlp.com/posts/8890/</id>
    <published>2020-12-18T22:21:02.000Z</published>
    <updated>2020-12-18T22:21:02.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;开源，不仅仅只是需要把代码开放那么简单，而是怎么样用自己的代码去解决实际的需求、进行不断地迭代更新、以及构建开源项目的交流社区。根据过去一两年的开源经历，聊一聊我从开发者角度思考开源的观点以及对开源行为的一点想法。&lt;/p&gt;</summary>
    
    
    
    <category term="编程随想" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
    <category term="开源" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="开源" scheme="https://imzlp.com/tags/%E5%BC%80%E6%BA%90/"/>
    
    <category term="编程随想" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>UE反射实现分析：C++特性</title>
    <link href="https://imzlp.com/posts/23694/"/>
    <id>https://imzlp.com/posts/23694/</id>
    <published>2020-12-13T19:39:37.000Z</published>
    <updated>2020-12-13T19:39:37.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在前一篇文章中，介绍了UE的反射的基础概念，这篇文章开始研究UE的反射机制的具体实现。&lt;/p&gt;
&lt;p&gt;在介绍UE的代码之前，需要先要介绍一些C++特性，虽然UE的反射实现是大量依赖UHT的代码生成的，但是也需要C++的语法特性支持，只有把这些特性还有它们背后的含义了解清楚，才能够更好地理解UE的反射机制。&lt;/p&gt;
&lt;p&gt;本篇文章中介绍的C++的特性和标准描述均基于&lt;code&gt;ISO/IEC 14882:2014&lt;/code&gt;，也就是C++14标准。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/UnrealEngine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>UE反射实现分析：基础概念</title>
    <link href="https://imzlp.com/posts/12624/"/>
    <id>https://imzlp.com/posts/12624/</id>
    <published>2020-12-12T23:56:24.000Z</published>
    <updated>2020-12-12T23:56:24.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;反射&lt;/strong&gt;，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC等方面非常有用。但是C++语言本身不支持反射特性，UE在C++的语法基础上通过UHT实现了反射信息的生成，从而实现了运行时的反射的目的。&lt;/p&gt;
&lt;p&gt;在之前的文章中，有一些涉及到UE的构建系统和反射相关的内容。&lt;/p&gt;
&lt;p&gt;涉及了UE的构建系统文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/16643/&quot;&gt;UE4 Build System：Target and Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/20425/&quot;&gt;UEC++ 与标准 C++ 的区别与联系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于UE的反射机制来做一些奇淫巧技的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/15049/&quot;&gt;UE4：Hook UObject&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UE的反射实现是依赖于构建系统中UHT来执行代码生成的，本篇文章对UE的反射做一个基础概念介绍，后续会花几篇文章完整地介绍UE里反射的实现机制。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/UnrealEngine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>2020 Unreal Open Day</title>
    <link href="https://imzlp.com/posts/11043/"/>
    <id>https://imzlp.com/posts/11043/</id>
    <published>2020-12-05T13:38:15.000Z</published>
    <updated>2020-12-05T13:38:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;2020年的Unreal Open Day是在线上直播和技术分会场的形式进行的，很开心参加了今年的UOD活动，我录制了一场UOD的技术视频，也去上海直播现场参加了UOD的颁奖活动，很荣幸也很感谢Epic授予我&lt;strong&gt;杰出社区贡献者&lt;/strong&gt;奖项，对我既是认可也是激励，我也会尽力产出更多的技术内容，促进UE社区的发展。&lt;/p&gt;
&lt;p&gt;本篇文章做一个简单的记录，把UOD的资料做一下整理，也把我参加UOD的视频、演讲PPT，以及相关的资料做一个总结，还有一些在UOD直播现场拍的照片。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="UOD" scheme="https://imzlp.com/categories/UnrealEngine/UOD/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UnrealOpenDay" scheme="https://imzlp.com/tags/UnrealOpenDay/"/>
    
    <category term="UOD" scheme="https://imzlp.com/tags/UOD/"/>
    
  </entry>
  
  <entry>
    <title>UE：UPL与JNI调用的最佳实践</title>
    <link href="https://imzlp.com/posts/27289/"/>
    <id>https://imzlp.com/posts/27289/</id>
    <published>2020-11-15T10:45:27.000Z</published>
    <updated>2020-11-15T10:45:27.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用UE4开发Android时，有时需要获取平台相关的信息、或者执行平台相关的操作，在这种情况下，需要在代码中添加Java的代码以及在C++中调用它们。有些需求也需要在游戏中从Java侧接收一些事件，需要处理Java调用C++的流程。&lt;/p&gt;
&lt;p&gt;本篇文章主要涉及以下几部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UE工程中添加Java代码&lt;/li&gt;
&lt;li&gt;Java函数的签名规则&lt;/li&gt;
&lt;li&gt;Java调用C++的函数&lt;/li&gt;
&lt;li&gt;C++调用Java的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何利用UE的UPL特性、Java的签名规则，以及在UE中进行JNI调用实现方法，会在文章中做详细的介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/categories/UnrealEngine/Android/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
    <category term="JNI" scheme="https://imzlp.com/tags/JNI/"/>
    
    <category term="UPL" scheme="https://imzlp.com/tags/UPL/"/>
    
  </entry>
  
  <entry>
    <title>UE：Hook UObject</title>
    <link href="https://imzlp.com/posts/15049/"/>
    <id>https://imzlp.com/posts/15049/</id>
    <published>2020-11-08T22:35:37.000Z</published>
    <updated>2020-11-08T22:35:37.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Hook是一种机制，通过拦截和勾取一些事件来实现自己需求的方式。不同于传统的底层Hook，本篇文章主要介绍在UE中如何使用类似Hook的这种机制来实现业务需求。&lt;/p&gt;
&lt;p&gt;有些需求是要全局地修改某个类的所有对象，比如在UI中为某种类型的的Button播放统一的音效，如果在每个控件都需要监听它的OnClicked再去播放音效，会有大量的重复操作。所以，我想要找一种全局的方法，可以监听所有UButton的点击事件，然后统一来处理。再或者想要控制一个在蓝图中不可见的属性，如果只是一些简单的需求就要去修改引擎的代码，有点得不偿失。&lt;/p&gt;
&lt;p&gt;可以通过UE的反射机制来实现这些需求，本篇文章来提供一种思路，做一个简单的实现分析。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/UnrealEngine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>BuildGraph：构建支持多平台打包的二进制引擎</title>
    <link href="https://imzlp.com/posts/11956/"/>
    <id>https://imzlp.com/posts/11956/</id>
    <published>2020-11-08T15:40:19.000Z</published>
    <updated>2023-10-22T12:35:18.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;通常，UE4开发者获取UE4引擎的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从Epic Games Launcher安装&lt;/li&gt;
&lt;li&gt;从Github上Clone代码本地编译&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从EpicGamesLauncher安装的是公版引擎，不能修改代码重新编译，可以在根据选择安装支持的平台、调试符号等。&lt;br&gt;自己从Github上Clone代码进行编译的则是源码版引擎，有些功能只能在源码版中使用（比如Standalone Application），但是如果在项目中修改了引擎的代码，导致每个人都需要Clone一遍源码编译一遍引擎，这个过程十分耗时，而且源码版引擎的占用的磁盘空间十分巨大，达到上百G。在当需要把引擎部署到多台构建机时，编译引擎的时间和空间是冗余的，所以需要通过一台机器编译引擎，然后其他的机器只需要拉取编译后的引擎即可，实现与安装版引擎一样的行为。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍BuildGraph的工作流程，以及对引擎默认构建脚本&lt;code&gt;InstalledEngineBuild.xml&lt;/code&gt;的分析；如何使用BuildGraph从源码配置、编译并导出支持Android/IOS打包的二进制引擎、以及如何裁剪和加速整个的构建流程。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="构建" scheme="https://imzlp.com/categories/UnrealEngine/%E6%9E%84%E5%BB%BA/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="BuildGraph" scheme="https://imzlp.com/tags/BuildGraph/"/>
    
  </entry>
  
  <entry>
    <title>二零二零：下一个五年计划</title>
    <link href="https://imzlp.com/posts/27392/"/>
    <id>https://imzlp.com/posts/27392/</id>
    <published>2020-10-25T12:18:58.000Z</published>
    <updated>2020-10-25T12:18:58.000Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="年度总结" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="年度总结" scheme="https://imzlp.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UE工具集：我的开源项目介绍</title>
    <link href="https://imzlp.com/posts/21696/"/>
    <id>https://imzlp.com/posts/21696/</id>
    <published>2020-10-11T10:33:56.000Z</published>
    <updated>2020-10-11T10:33:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;工欲善其事必先利其器，本文主要介绍在我在使用UE的过程中开发的一些开源的工具和插件，能够方便地在项目中使用，提高开发效率。之前简单罗列在&lt;a href=&quot;https://imzlp.com/resources/&quot;&gt;资源&lt;/a&gt;页面里，今天做一个详细的整理，对各个工具、插件做一些介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="开源" scheme="https://imzlp.com/categories/UnrealEngine/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="开源" scheme="https://imzlp.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>如何构建自己的知识体系？</title>
    <link href="https://imzlp.com/posts/29551/"/>
    <id>https://imzlp.com/posts/29551/</id>
    <published>2020-10-10T10:08:52.000Z</published>
    <updated>2020-10-10T10:08:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;学习如逆水行舟，不进则退。这一点在CS领域尤甚，新技术、新框架日新月异地发展，业务层面的技术迭代非常快，可能刚熟悉了一项技术，很快就又被淘汰了。所以只有不停地接触、了解和学习新的知识和技能才能不断地拓展自己的程序生涯。&lt;br&gt;本篇文章是我写博客几年的对平时技术积累进行的一些思考，本来当作&lt;a href=&quot;/notes&quot;&gt;notes&lt;/a&gt;改版的记录，现在觉得抽离出来当作单独的文章也比较合适，我很少写感悟类的东西，觉得方法论太虚，但是如果具有理论指导行动的自制力，方法论也是很有必要的，希望自己也能做到。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>UE集成WWise：概念与代码分析</title>
    <link href="https://imzlp.com/posts/9809/"/>
    <id>https://imzlp.com/posts/9809/</id>
    <published>2020-09-12T15:31:46.000Z</published>
    <updated>2020-09-12T15:31:46.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.audiokinetic.com/zh/products/wwise/&quot;&gt;WWise&lt;/a&gt;是Audiokinetic的跨平台音频引擎，可以与游戏引擎很好地进行交互，负责音频的同事可以只在WWise中处理音频，把游戏业务和音频的制作与管理分离，提供事件和参数给游戏引擎使用，实现与业务的解耦和对音频更精确的控制。&lt;br&gt;本篇文章主要介绍WWise与UE4的集成、远程构建、资源分析、文档收录，WWise与UE的控制交互以及Bank生成的代码分析。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Wwise" scheme="https://imzlp.com/categories/UnrealEngine/Wwise/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Wwise" scheme="https://imzlp.com/tags/Wwise/"/>
    
  </entry>
  
  <entry>
    <title>UE导入图集：TexturePacker</title>
    <link href="https://imzlp.com/posts/28513/"/>
    <id>https://imzlp.com/posts/28513/</id>
    <published>2020-09-11T15:53:22.000Z</published>
    <updated>2020-09-11T15:53:22.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在开发游戏时，会使用到大量的图片资源，使用图集的作用在于减少 DrawCall，提高性能。在UE中没有图集的打包工具，比较流行的方案是使用第三方的图集打包工具&lt;a href=&quot;https://www.codeandweb.com/texturepacker&quot;&gt;TexturePacker&lt;/a&gt;。新版本的TexturePacker支持直接导出UE4的Sprite，并且可以在引擎中直接导入。在之前的版本中可以使用&lt;a href=&quot;https://github.com/ufna/VaTexAtlas&quot;&gt;VaTexAtlas&lt;/a&gt;通过Json Array的数据导入，不过与TexturePacker直接导出UE的Sprite相比，VaTexAtlas并没有优势，UE的Sprite还可以直接预览，VaTexAtlas则不可以，在官方已经支持的情况下不建议再使用VaTexAtlas作为UE导入图集的方式。&lt;/p&gt;
&lt;p&gt;本篇文章主要内容是记录TexturePacker图集生成文件的分析、导入UE、选项介绍、以及记录在UE中使用遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="图集" scheme="https://imzlp.com/categories/UnrealEngine/%E5%9B%BE%E9%9B%86/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="图集" scheme="https://imzlp.com/tags/%E5%9B%BE%E9%9B%86/"/>
    
    <category term="TexturePackaer" scheme="https://imzlp.com/tags/TexturePackaer/"/>
    
  </entry>
  
  <entry>
    <title>UE开发笔记：Mac/iOS篇</title>
    <link href="https://imzlp.com/posts/1948/"/>
    <id>https://imzlp.com/posts/1948/</id>
    <published>2020-09-01T21:45:03.000Z</published>
    <updated>2023-09-08T09:47:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章的主要内容是介绍UE在Mac上的开发环境部署、配置iOS远程出包、UPL在iOS上的应用（介入ipa出包过程）、工具和开发技巧、以及分析相关的引擎代码等内容，记录了一些在项目中遇到的坑，主要从我之前的&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;笔记&lt;/a&gt;中整理而来，后续Mac和iOS相关的内容也都会更新到这篇文章里。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Apple" scheme="https://imzlp.com/categories/UnrealEngine/Apple/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="iOS" scheme="https://imzlp.com/tags/iOS/"/>
    
    <category term="Mac" scheme="https://imzlp.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：需求分析与方案设计</title>
    <link href="https://imzlp.com/posts/17371/"/>
    <id>https://imzlp.com/posts/17371/</id>
    <published>2020-05-16T11:22:35.000Z</published>
    <updated>2020-05-16T11:22:35.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;游戏热更新是在玩家不重新安装游戏的前提下获取最新游戏内容的方式，在PC和移动端的网络游戏中有很多应用，因为游戏上上线后要快速调整、修复bug、更新内容等等。如果每修改一点点内容都需要玩家去AppStore更新应用，甚至去网站手动下载再安装，而且不同的平台对于游戏的审核规则和反馈时间也不一致，运营也会疯掉。&lt;/p&gt;
&lt;p&gt;在其他引擎中的热更应该有比较成熟的方案，但是在UE里还没看到有比较全面的文章来讲UE4的热更实现的文章，恰好之前分析和实现了UE4热更的内容，准备写两篇文章来记录一下思路和实现方案，并会实现一个可以运行的Demo，希望能对有需要的朋友一点帮助。&lt;/p&gt;
&lt;p&gt;为了方便地统一收集和管理热更新和HotPatcher常见的问题与解决方案，我新建了一篇文章来记录和整理：&lt;a href=&quot;https://imzlp.com/posts/16895/&quot;&gt;UE4热更新：Questions &amp;amp; Answers&lt;/a&gt;，遇到问题可以先去看这个FAQ页面。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>ModularFeature：为UE4集成ZSTD压缩算法</title>
    <link href="https://imzlp.com/posts/8470/"/>
    <id>https://imzlp.com/posts/8470/</id>
    <published>2020-04-20T21:52:56.000Z</published>
    <updated>2020-04-20T21:52:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE在打包时默认使用&lt;code&gt;Zlib&lt;/code&gt;作为资源的压缩算法，但是从压缩率和解压速度来看它并不是最好的选择，可以从&lt;a href=&quot;https://quixdb.github.io/squash-benchmark/&quot;&gt;Squash Compression Benchmark&lt;/a&gt;去看各种压缩算的效率对比，我选择了facebook开源的&lt;a href=&quot;https://facebook.github.io/zstd/&quot;&gt;ZStandard&lt;/a&gt;作为替换Zlib的压缩实现，因为ZSTD在保证压缩比的同时还具有不错的解压效率。&lt;br&gt;本篇文章并不只是讲怎么在UE里集成一个压缩算法，还会简单介绍一下UE里的一些功能的模块化组织方式——&lt;code&gt;ModularFeature&lt;/code&gt;，使用这种方式可以比较方便地替换某些功能的实现，本文中的替换压缩算法是一个实践。&lt;/p&gt;
&lt;p&gt;我在UE中集成&lt;a href=&quot;https://facebook.github.io/zstd/&quot;&gt;ZSTD&lt;/a&gt;的方式是写了一个插件，源码集成，开源在Github上：&lt;a href=&quot;https://github.com/hxhb/ue-zstd&quot;&gt;hxhb/ue-zstd&lt;/a&gt;，支持Android和Windows、IOS以及MacOS，欢迎Star。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="压缩算法" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="ZSTD" scheme="https://imzlp.com/tags/ZSTD/"/>
    
    <category term="压缩算法" scheme="https://imzlp.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>UE热更新：基于UnLua的Lua编程指南</title>
    <link href="https://imzlp.com/posts/36659/"/>
    <id>https://imzlp.com/posts/36659/</id>
    <published>2020-03-24T10:50:17.000Z</published>
    <updated>2021-06-22T11:08:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE使用的是C++这种编译型语言，在编译之后就成了二进制，只有通过玩家重新安装才能打到更新游戏的目的。但是对于游戏业务而言，对于需求调整和bug修复时间要求非常迫切，频繁地让玩家更新App是不能接受的，游戏项目一般使用Lua作为游戏业务的脚本语言，是为了把运行时不可变的C++代码变成运行时可更新的Lua代码。&lt;/p&gt;
&lt;p&gt;UE官方没有提供Lua的支持，但是腾讯开源了&lt;a href=&quot;https://github.com/Tencent/UnLua&quot;&gt;UnLua&lt;/a&gt;，在我当前的项目使用了，这两天我梳理了一下UnLua的资料（主要是官方文档、issus、宣讲PPT），加上自己测试UnLua写了一个小Demo的感悟，形成了本篇UE结合UnLua的编程指南，主要是总结使用UnLua来写业务的一些基本方法和坑，方便查看，本篇文章会持续更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，Lua文件打包成Pak可以用我之前开源的工具：&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;hxhb/HotPatcher&lt;/a&gt;，而且我基于UnLua自己修改了一个版本，添加了一些额外的优化，源码集成了&lt;a href=&quot;https://github.com/diegonehab/luasocket&quot;&gt;Luasocket&lt;/a&gt;/&lt;a href=&quot;https://github.com/Tencent/LuaPanda&quot;&gt;Luapanda&lt;/a&gt;/&lt;code&gt;lpeg&lt;/code&gt;/&lt;code&gt;Sproto&lt;/code&gt;/&lt;code&gt;Luacrypt&lt;/code&gt;库，可以直接使用&lt;a href=&quot;https://github.com/Tencent/LuaPanda&quot;&gt;LuaPanda&lt;/a&gt;调试，Github地址为：&lt;a href=&quot;https://github.com/hxhb/debugable-unlua&quot;&gt;hxhb/debugable-unlua&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Lua" scheme="https://imzlp.com/categories/UnrealEngine/Lua/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Lua" scheme="https://imzlp.com/tags/Lua/"/>
    
    <category term="UnLua" scheme="https://imzlp.com/tags/UnLua/"/>
    
  </entry>
  
  <entry>
    <title>UEC++与标准C++的区别与联系</title>
    <link href="https://imzlp.com/posts/20425/"/>
    <id>https://imzlp.com/posts/20425/</id>
    <published>2020-02-11T11:22:44.000Z</published>
    <updated>2020-02-11T11:22:44.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;受&lt;a href=&quot;https://g.co/kgs/oevWTp&quot;&gt;新冠病毒(COVID-19)&lt;/a&gt;影响，整个春节都禁足在家，目前还没有复工，只能看看书整理一下笔记，希望疫情尽快过去，希望朋友们都身体健康。&lt;br&gt;本篇文章的主要内容是分析一下在使用UE开发时使用的C++和**标准C++**在语法上有哪些区别，UEC++本质是C++的一个超集，它支持和使用C++的全部特性，但是它在标准特性之上自己构建了一套语法。很多开发中的编译问题只有知道了两者的边界，才能够快速和准确地定位问题出现在哪个阶段。对于使用UE之前就学习过C++的来说这不是什么问题，但是对于先接触UE然后慢慢学C++的同学来说，这是个挺大的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标准C++**是基于&lt;/strong&gt;ISO/IEC 14882**的语言规范（C++98/03/11/14/17等标准），UEC++则是我们开发当中使用的Epic在标准C++之上扩展的用法，这里不讨论GC、反射之类的基于C++之上自己构建的对象体系，也不涉及UE中的各种库，关注的着重点在于核心语法层面。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/UnrealEngine/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>UE源码分析：修改游戏默认的数据存储路径</title>
    <link href="https://imzlp.com/posts/20367/"/>
    <id>https://imzlp.com/posts/20367/</id>
    <published>2020-01-22T09:10:02.000Z</published>
    <updated>2020-01-22T09:10:02.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;默认情况下，使用UE打包出游戏的Apk并在手机上安装之后，启动游戏会在&lt;code&gt;/storage/emulated/0/UE4Game/&lt;/code&gt;下创建游戏的数据目录(也就是内部存储器的根目录下)。按照Google的规则，每个APP的数据文件最好都是放在自己的私有目录，所以我想要把UE打包出来的游戏的数据全放到&lt;code&gt;/storage/emulated/0/Android/data/PACKAGE_NAME&lt;/code&gt;目录中(不管是log、ini、还是crash信息)。&lt;br&gt;一个看似简单的需求，有几种不同的方法，涉及到了UE4的路径管理/JNI/Android Manifest以及对UBT的代码的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/categories/UnrealEngine/Android/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UE资源热更打包工具HotPatcher</title>
    <link href="https://imzlp.com/posts/17590/"/>
    <id>https://imzlp.com/posts/17590/</id>
    <published>2020-01-15T09:41:30.000Z</published>
    <updated>2020-08-31T17:27:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;重要通知：作者没有任何平台和渠道录制收费课程，也不对任何第三方的商业行为背书。请擦亮双眼，谨防上当受骗。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;本软件的开源协议：允许在商业项目中免费使用功能，但不允许任何第三方基于该插件进行任何形式的二次收费，包括但不限于录制收费课程、对插件及代码的二次分发等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;是一个用于管理热更版本和资源打包工具，用于追踪工程版本的原始资源变动来打出Patch。支持一键Cook多平台，一键打包多平台Patch，编辑器支持Windows和MacOS，再写一套从服务器下载patch的流程就是一套完整的游戏热更方案。&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;已经在非常多的UE项目中使用，并会持续更新支持新的引擎版本，欢迎提issus。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;与UnrealFrontEnd中的Patch机制不同，UE的Patch管理工程时存在一些问题：基于原始的的工程版本，很难在不同的电脑上打出完全相同的Patch，也无法基于Patch的版本再打出一个Patch，并且Patch包含的内容不能够直观预览。并且不能方便地能够把外部文件打包到pak中（如lua文件、db等non-assets，往往不在Content目录下），也无法方便地管理工程和Patch版本。&lt;/p&gt;
&lt;p&gt;这个插件就是为了解决这样的问题，以项目原始资源作为版本依据，只需管理工程本身而无需关注UE生成的其他文件。并且可以方便地进行Cook/生成Pak/提取基础包中的资源信息/版本间diff/Patch拆分等操作。具有非常丰富的配置化选项与Commandlet支持，可以非常方便地实现自动化热更新出包流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前支持的引擎版本为UE4.21-UE5，并对IoStore机制提供了支持！有很多朋友私信来问插件相关的问题，我创建了个群来讨论UE热更新和HotPatcher插件的问题(QQ群958363331)，欢迎加入交流UE相关的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了方便地统一收集和管理热更新和HotPatcher常见的问题与解决方案，我新建了一篇文章来记录和整理：&lt;a href=&quot;https://imzlp.com/posts/16895/&quot;&gt;UE4热更新：Questions &amp;amp; Answers&lt;/a&gt;，遇到问题可以先去看这个FAQ页面。关于比较多人反馈插件内配置参数与之前的录制视频不一致的问题，是因为插件进行了很多更新迭代，每个版本的详细变动，可看&lt;a href=&quot;https://imzlp.com/posts/17590/#Update-Log&quot;&gt;更新日志&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/UnrealEngine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE项目的设计规范和代码标准</title>
    <link href="https://imzlp.com/posts/25915/"/>
    <id>https://imzlp.com/posts/25915/</id>
    <published>2020-01-01T11:55:16.000Z</published>
    <updated>2020-01-01T11:55:16.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近新开了项目，大概总结了之前项目的一些问题，列举了一些UE开发项目的设计规范和代码标准（代码标准这个词看起来太严肃了，写代码的习惯是一个比较主观的概念，其实叫代码约定更好，但是在组内推广还是要有严格执行的要求）。本篇文章会持续更新和整理，欢迎指出问题和交流意见。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="代码规范" scheme="https://imzlp.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>成为虚幻商城的内容创作者</title>
    <link href="https://imzlp.com/posts/1927/"/>
    <id>https://imzlp.com/posts/1927/</id>
    <published>2019-12-08T22:49:19.000Z</published>
    <updated>2019-12-08T22:49:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;上周我把之前写的一个插件&lt;a href=&quot;https://www.unrealengine.com/marketplace/en-US/slug/exportnavigation&quot;&gt;ExortNavigation&lt;/a&gt;上架了虚幻商城，熟悉了一下UE代码插件的提交流程，在此记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Marketplace" scheme="https://imzlp.com/categories/UnrealEngine/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/Marketplace/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="虚幻商城" scheme="https://imzlp.com/tags/%E8%99%9A%E5%B9%BB%E5%95%86%E5%9F%8E/"/>
    
    <category term="Epic Marketplace" scheme="https://imzlp.com/tags/Epic-Marketplace/"/>
    
    <category term="插件开发" scheme="https://imzlp.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Export Recast Navigation Data from UE4</title>
    <link href="https://imzlp.com/posts/20203/"/>
    <id>https://imzlp.com/posts/20203/</id>
    <published>2019-11-01T09:18:13.000Z</published>
    <updated>2019-11-01T09:18:13.000Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最新版本已支持UE5，详见github的UE5.0分支：&lt;a href=&quot;https://github.com/hxhb/ue4-export-nav-data/tree/UE5.0&quot;&gt;ue4-export-nav-data/tree/UE5.0&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/recastnavigation/recastnavigation&quot;&gt;Recast Navigation&lt;/a&gt;是一个开源的游戏导航/寻路引擎，可以为游戏中的AI提供寻路计算。UE和Unity都是集成了RecastNavigation来为游戏提供导航和寻路计算(当然是修改过的版本)，UE的模块&lt;code&gt;NavigationSystem&lt;/code&gt;以及&lt;code&gt;NavMesh&lt;/code&gt;中可以看到相关的代码实现。&lt;br&gt;最近有个需求是要将客户端的地图信息导出给非UE网络架构的服务端，用于在服务器上对玩家位置的校验，想到可以把客户端的生成的导航数据导出作为客户端世界的&lt;strong&gt;地图&lt;/strong&gt;，所以折腾了一下写了一个UE的插件（开源在Github上：**&lt;a href=&quot;https://github.com/hxhb/ue4-export-nav-data&quot;&gt;ue4-export-nav-data&lt;/a&gt;&lt;strong&gt;）实现了&lt;/strong&gt;直接**将UE生成的导航数据导出，有兴趣的可以直接去看具体的代码。&lt;br&gt;根据导出的导航数据可以完整地在非UE网络架构的服务端上实现基于&lt;a href=&quot;https://github.com/recastnavigation/recastnavigation&quot;&gt;Recast Navigation&lt;/a&gt;的寻路计算，而且与UE无缝衔接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**2019.12.04 Update:**本插件已上架虚幻商城，购买链接&lt;a href=&quot;https://unrealengine.com/marketplace/en-US/slug/exportnavigation&quot;&gt;ExportNavigation&lt;/a&gt;，为了程序员情怀支持开源，所以该项目在Github上的开源仓库不会关闭，但基本不会更新，如果该插件对你有用，欢迎在商城购买支持作者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Recast" scheme="https://imzlp.com/tags/Recast/"/>
    
    <category term="Navigation" scheme="https://imzlp.com/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>Oculus Quest Development with UE4</title>
    <link href="https://imzlp.com/posts/30042/"/>
    <id>https://imzlp.com/posts/30042/</id>
    <published>2019-09-24T10:41:10.000Z</published>
    <updated>2020-09-17T21:31:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.oculus.com/quest/&quot;&gt;Oculus Quest&lt;/a&gt;是Oculus发布的新一代支持6DoF的VR一体机设备，不需要连接PC以及额外的定位基站，而且支持Guardian，当戴着头显走出定位边界时，头显中会立即显示现实中的画面，防止玩家误碰出现意外情况。&lt;br&gt;&lt;a href=&quot;https://www.oculus.com/quest/&quot;&gt;Oculus Quest&lt;/a&gt;使用两个&lt;code&gt;Pentile OLED&lt;/code&gt;的屏幕，单眼分辨率为&lt;code&gt;1440x1600&lt;/code&gt;，刷新率为&lt;code&gt;72Hz&lt;/code&gt;，使用的是&lt;code&gt;arm&lt;/code&gt;架构的高通骁龙835处理器，与两年前的Android旗舰级的处理器相同(如小米6、三星S8)。&lt;br&gt;Quest使用的是&lt;code&gt;Oculus Insight&lt;/code&gt;(inside-out tracing)定位方案，使用四枚摄像头进行位置追踪，分别位于头显面板的四角。&lt;br&gt;发布会时对Oculus Insight的介绍：&lt;a href=&quot;https://www.youtube.com/watch?v=2jY3B_F3GZk&quot;&gt;Oculus Insight VR Positional Tracking System (Sep 2018)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及国外的一个老哥对Quest追踪范围的测试视频：&lt;a href=&quot;https://drive.google.com/file/d/1-bqNmwUi8J57yykxLP6szgiLeU3IgdgL/view&quot;&gt;Quest Distance Test&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Oculus Quest&lt;/code&gt;64G存储版本的售价为399刀，128G的为499刀，不计税的价格大概是3500；相比较HTC的同类新产品(HTC Vive Focus)是便宜了不少，与PC-Base VR相比那就更具优势了，还不需要一台高性能的主机，我觉得6DoF的VR一体机设备一定是未来的趋势！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;国庆前的OC6，Oculus发布了Oculus Link和finger tracking两项技术，十分厉害，十分看好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整套Quest设备的大小与&lt;code&gt;10.5&lt;/code&gt;寸的iPad差不多，提个小包就能带走：&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/30042/20190925000314.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;Quest设备的参数细节不再多说，本篇文章的主要内容是使用UE来开发Quest项目时的环境部署、开发文档、调试工具以及额外的注意事项，会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="VR" scheme="https://imzlp.com/categories/UnrealEngine/VR/"/>
    
    <category term="Quest" scheme="https://imzlp.com/categories/UnrealEngine/VR/Quest/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
    <category term="OculusQuest" scheme="https://imzlp.com/tags/OculusQuest/"/>
    
  </entry>
  
  <entry>
    <title>UE Build System：Target and Module</title>
    <link href="https://imzlp.com/posts/16643/"/>
    <id>https://imzlp.com/posts/16643/</id>
    <published>2019-09-12T13:14:22.000Z</published>
    <updated>2019-09-12T13:14:22.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Module是构成Unreal的基本元素，每一个Module封装和实现了一组功能，并且可以供其他的Module使用，整个Unreal Engine就是靠各个Module组合驱动的，连我们创建的游戏项目本身，都是一个单独的Module。&lt;/p&gt;
&lt;p&gt;那么UE又是怎么创建和构建这这些Module的呢？这是写这篇文章的主要目的，研究一下Unreal的构建系统以及它们(Target和Module)支持的各种属性。&lt;/p&gt;
&lt;p&gt;建议在看这篇文章之前先看一下我之前的这篇文章：&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;，主要内容是大致过一遍UE的构建流程，本篇文章只是UE构建系统中的一环。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Build System" scheme="https://imzlp.com/categories/UnrealEngine/Build-System/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/tags/UBT/"/>
    
  </entry>
  
  <entry>
    <title>UE工具链配置与开发技巧</title>
    <link href="https://imzlp.com/posts/12143/"/>
    <id>https://imzlp.com/posts/12143/</id>
    <published>2019-09-09T23:32:08.000Z</published>
    <updated>2019-09-09T23:32:08.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;工欲善其事，必先利其器！掌握好的工具会使开发效率上一个层次。&lt;br&gt;本文是我平时记录在&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;notes&lt;/a&gt;中关于UE工具链以及一些组合UE使用的工具配置和使用技巧的笔记整理，后续这方面的内容也会收录到这篇文章中。&lt;br&gt;下面是我之前写的关于UE工具链或扩展相关的单独的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/9050/&quot;&gt;分析UBT中EULA的内容分发限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/31962/&quot;&gt;Create A Standalone Application in UE4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/11515/&quot;&gt;抓取UE4 API并生成带索引的Dash文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>分析UBT中EULA的内容分发限制</title>
    <link href="https://imzlp.com/posts/9050/"/>
    <id>https://imzlp.com/posts/9050/</id>
    <published>2019-08-24T14:15:36.000Z</published>
    <updated>2019-08-24T14:15:36.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE的&lt;a href=&quot;https://www.unrealengine.com/en-US/eula&quot;&gt;EULA&lt;/a&gt; &lt;strong&gt;License Grant/(A)&lt;/strong&gt; 中明确说明了，使用UE开发并再分发的内容不得包含 &lt;strong&gt;未Cook的源格式&lt;/strong&gt; 和基于 &lt;strong&gt;引擎工具&lt;/strong&gt; 开发的付费内容，本篇文章研究一下EULA里对内容分发的具体内容和从技术上怎么绕过这个限制。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/categories/UnrealEngine/UBT/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="EULA" scheme="https://imzlp.com/tags/EULA/"/>
    
  </entry>
  
  <entry>
    <title>PixelStreaming：基本概念与上手初探</title>
    <link href="https://imzlp.com/posts/9455/"/>
    <id>https://imzlp.com/posts/9455/</id>
    <published>2019-07-30T17:48:27.000Z</published>
    <updated>2019-07-30T17:48:27.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;PixelStreaming是UE_4.21开始支持的一项技术，简单来说就是能够将游戏跑在服务器上，你可以通过浏览器来玩，玩家端不需要额外操作，只需要一个浏览器，所有的逻辑处理和渲染都在“云”端执行。它不仅仅只是一个插件(虽然有PixelStreamingPlugin这个插件，但它只是&lt;strong&gt;PixelStreaming&lt;/strong&gt;实现中的一环)，其实现具有一套独立与UE游戏的设计和组织方式。&lt;br&gt;本篇文章主要介绍PixelStreaming中的基本概念和使用PixelStreaming的Demo的实际体验。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="PixelStreaming" scheme="https://imzlp.com/categories/UnrealEngine/PixelStreaming/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Pixel Streaming" scheme="https://imzlp.com/tags/Pixel-Streaming/"/>
    
  </entry>
  
  <entry>
    <title>UE Modules:Find the DLL and load it</title>
    <link href="https://imzlp.com/posts/31203/"/>
    <id>https://imzlp.com/posts/31203/</id>
    <published>2019-07-16T18:23:29.000Z</published>
    <updated>2019-07-16T18:23:29.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在Windows上，UE的模块在非&lt;code&gt;IS_MONOLITHIC&lt;/code&gt;(打包成一个单独的可执行文件的&lt;strong&gt;单片模式(Monolithic)&lt;/strong&gt;)模式下，是通过查找DLL来加载模块的。可以调用&lt;code&gt;FModuleManager&lt;/code&gt;下的&lt;code&gt;LoadModuleWithFailureReason&lt;/code&gt;/&lt;code&gt;LoadModuleChecked&lt;/code&gt;等函数，通过传入Module的字符串名字来加载。&lt;br&gt;本篇文章算是&lt;a href=&quot;https://imzlp.com/posts/24007/&quot;&gt;UE4 Modules:Load and Startup&lt;/a&gt;的扩展和补充，与之不同的是，这篇文章的&lt;strong&gt;侧重点&lt;/strong&gt;在于Module的DLL的查找和加载的细节&lt;strong&gt;而不是&lt;/strong&gt;引擎启动和加载Module的时机和顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>UE接入SteamSDK及相关资料</title>
    <link href="https://imzlp.com/posts/3231/"/>
    <id>https://imzlp.com/posts/3231/</id>
    <published>2019-05-27T23:02:17.000Z</published>
    <updated>2019-05-27T23:02:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;游戏上架&lt;a href=&quot;https://store.steampowered.com/&quot;&gt;Steam&lt;/a&gt;必须要接入&lt;a href=&quot;https://partner.steamgames.com/doc/sdk&quot;&gt;SteamSDK&lt;/a&gt;，本篇文章简单介绍一下在UE4中接入&lt;a href=&quot;https://partner.steamgames.com/doc/sdk&quot;&gt;SteamSDK&lt;/a&gt;的方法，后续与接入Steam平台服务相关的内容也会放到这篇文章中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SteamSDK的接入可以使游戏与Steam的社区整合，Steam拥有很好的社区生态，这一点是Epic刚出的&lt;a href=&quot;https://www.epicgames.com/store/e/en-US/&quot;&gt;Epic Games Store&lt;/a&gt;目前比不了的~(当然我是支持市场竞争的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Steam" scheme="https://imzlp.com/tags/Steam/"/>
    
    <category term="SteamSDK" scheme="https://imzlp.com/tags/SteamSDK/"/>
    
  </entry>
  
  <entry>
    <title>UE代码分析:GConfig的加载</title>
    <link href="https://imzlp.com/posts/2386/"/>
    <id>https://imzlp.com/posts/2386/</id>
    <published>2019-05-27T22:57:58.000Z</published>
    <updated>2020-05-28T18:02:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE4中提供了一套非常成熟的INI文件配置机制，引擎中也使用了ini作为引擎和项目的配置文件。本篇文章来简单分析一下引擎中GConfig的加载。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>UE开发的问题笔记和资料辑录</title>
    <link href="https://imzlp.com/posts/25331/"/>
    <id>https://imzlp.com/posts/25331/</id>
    <published>2019-05-27T22:07:50.000Z</published>
    <updated>2019-05-27T22:07:50.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在平时的开发和学习中遇到和解决的一些问题以及摘录的一些资料，都随手写在了&lt;a href=&quot;https://imzlp.com/notes/&quot;&gt;notes&lt;/a&gt;中，UE相关的积攒了不少，其他的混在一起比较混乱，整理到本篇文章中。&lt;br&gt;与&lt;a href=&quot;https://imzlp.com/posts/3380/&quot;&gt;UE4和VR开发技术笔记&lt;/a&gt;不同的是，这里的内容更偏向于项目中实际的问题记录和资料收集。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>HTC Vive Tracker Developer Guide</title>
    <link href="https://imzlp.com/posts/2125/"/>
    <id>https://imzlp.com/posts/2125/</id>
    <published>2019-04-03T11:41:23.000Z</published>
    <updated>2019-04-10T09:42:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;HTC发布的Vive配件&lt;a href=&quot;https://www.vive.com/us/vive-tracker/&quot;&gt;Vive Tracker&lt;/a&gt;可以用来扩展与SteamVR连接的设备。而且还具有Pogo引脚，可以自己DIY出特殊功能的配件，最近看到了一些使用&lt;a href=&quot;https://www.vive.com/us/vive-tracker/&quot;&gt;Vive Tracker&lt;/a&gt;来实现的非常棒的创意。相关的资料和技术细节在本篇文章里整理辑录。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
    <category term="HTCVive" scheme="https://imzlp.com/tags/HTCVive/"/>
    
    <category term="ViveTracker" scheme="https://imzlp.com/tags/ViveTracker/"/>
    
    <category term="MR" scheme="https://imzlp.com/tags/MR/"/>
    
  </entry>
  
  <entry>
    <title>Create A Standalone Application in UE4</title>
    <link href="https://imzlp.com/posts/31962/"/>
    <id>https://imzlp.com/posts/31962/</id>
    <published>2019-03-30T18:14:46.000Z</published>
    <updated>2020-03-18T14:10:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;虽然UE是个&lt;strong&gt;游戏引擎&lt;/strong&gt;，但并不是只能写游戏——你甚至可以用来写Win32 GUI程序😏.&lt;br&gt;通常，我们使用Editor创建一个UE的游戏项目，然后在其基础上构建自己的类并在游戏中使用。但是如果不想要创建一个游戏项目，UE也支持可以独立运行的程序(Standalone Application)，能够从&lt;code&gt;main&lt;/code&gt;函数来自主构建自己的程序，完全控制启用哪些Modules，而不依赖于引擎本身的逻辑架构，也可以将其作为学习和测试UE模块的轻便方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：UE并没有提供直接创建Standalone Application的方法，我自己写了一个创建&lt;code&gt;Program&lt;/code&gt;项目的工具：&lt;a href=&quot;https://github.com/hxhb/ue4program&quot;&gt;hxhb/ue4program&lt;/a&gt;，并实现了一个独立运行工具的Demo：&lt;a href=&quot;https://github.com/hxhb/UE4Launcher&quot;&gt;hxhb/UE4Launcher&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="工具开发" scheme="https://imzlp.com/categories/UnrealEngine/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="工具开发" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX数学符号速查表</title>
    <link href="https://imzlp.com/posts/23224/"/>
    <id>https://imzlp.com/posts/23224/</id>
    <published>2019-03-22T00:27:13.000Z</published>
    <updated>2019-03-22T11:25:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近读&lt;a href=&quot;https://book.douban.com/subject/30426701/&quot;&gt;龙书DX12&lt;/a&gt;会用到LaTeX来记录一些公式。为了方便查找，整理了一些常用的LaTeX数学符号语法表，更多符号可以看&lt;a href=&quot;https://artofproblemsolving.com/wiki/index.php/LaTeX:Symbols&quot;&gt;LaTeX:Symbols&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LaTex" scheme="https://imzlp.com/categories/LaTex/"/>
    
    
    <category term="LaTeX" scheme="https://imzlp.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>引擎源码分析：模块的加载和启动</title>
    <link href="https://imzlp.com/posts/24007/"/>
    <id>https://imzlp.com/posts/24007/</id>
    <published>2019-03-19T11:11:57.000Z</published>
    <updated>2019-03-30T15:38:27.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE是模块化的架构，Engine/Game Project/StandaloneApplication/Plugins都是Module(&lt;a href=&quot;http://api.unrealengine.com/INT/API/index.html&quot;&gt;Unreal Engine API Reference&lt;/a&gt;列出了Engine提供的Module列表)，本篇文章从&lt;code&gt;FModuleManager&lt;/code&gt;的代码来分析一下UE的Module是如何通过&lt;code&gt;FModuleManager::LoadModule&lt;/code&gt;加载和启动的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>Build flow of the Unreal Engine4 project</title>
    <link href="https://imzlp.com/posts/6362/"/>
    <id>https://imzlp.com/posts/6362/</id>
    <published>2019-03-16T23:09:52.000Z</published>
    <updated>2019-09-16T19:01:45.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE通过UBT来构建项目(不管是VS里的Build也好，Editor里的Compile也好，最终都会调用UBT)。UBT和UHT是UE工具链的基石，内容太多，没办法一次性分析全部，先梳理出一个大致的轮廓，有时间再慢慢补充。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/tags/UBT/"/>
    
    <category term="UHT" scheme="https://imzlp.com/tags/UHT/"/>
    
  </entry>
  
  <entry>
    <title>C++多态与虚函数表</title>
    <link href="https://imzlp.com/posts/25558/"/>
    <id>https://imzlp.com/posts/25558/</id>
    <published>2019-02-26T13:36:47.000Z</published>
    <updated>2019-02-27T11:47:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++是一门支持面向对象编程(object-oriented Programming)的语言，继承和多态(Polymorphic)是其最重要的特性。&lt;br&gt;关于C++的继承和类内成员的各种内容在之前的文章中已经有了不少介绍，本篇文章主要是研究一下编译器对C++多态的一个实现方式：&lt;strong&gt;虚函数表&lt;/strong&gt;。&lt;br&gt;C++标准(&lt;strong&gt;[IOS/IEC 14882:2014]&lt;/strong&gt;)中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Virtual functions support dynamic binding and object-oriented programming. A class that declares or inherits a virtual function is called a polymorphic class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;strong&gt;C++标准并没有规定如何实现多态&lt;/strong&gt;，所以编译器对多态的实现是&lt;code&gt;Implementation-defined Behavior&lt;/code&gt;，意思就是不同的编译器可能对多态的实现是不一样的，在&lt;strong&gt;不同的平台可能会无法得到相同的实验结果&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="多态" scheme="https://imzlp.com/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="polymorphic" scheme="https://imzlp.com/tags/polymorphic/"/>
    
    <category term="虚函数表" scheme="https://imzlp.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>UE Package Error:ObservedKeyNames.Num()&gt;0</title>
    <link href="https://imzlp.com/posts/359/"/>
    <id>https://imzlp.com/posts/359/</id>
    <published>2019-01-17T09:50:36.000Z</published>
    <updated>2019-01-17T09:50:36.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近项目打包时遇到一个非常奇怪的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight txt&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// package log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ensure condition failed: ObservedKeyNames.Num() &amp;gt; 0 [File:D:&#92;Build&#92;++UE4+Release-4.18+Compile&#92;Sync&#92;Engine&#92;Source&#92;Runtime&#92;AIModule&#92;Private&#92;BehaviorTree&#92;Decorators&#92;BTDecorator_BlueprintBase.cpp] [Line: 67]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/359/ue-package-error-ObservedKeyNames-Num.png&quot;&gt;&lt;br&gt;我调试了一下UE4的代码，分析了一下原因和解决过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>Macro defined by UBT in UE4</title>
    <link href="https://imzlp.com/posts/5214/"/>
    <id>https://imzlp.com/posts/5214/</id>
    <published>2019-01-09T18:17:35.000Z</published>
    <updated>2019-01-09T18:17:35.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE4引擎里面定义了很多引擎中的宏和一些处理逻辑，如&lt;code&gt;WITH_ENGINE&lt;/code&gt;/&lt;code&gt;WITH_EDITOR&lt;/code&gt;等，它们部分是UBT通过读取&lt;code&gt;*.target.cs&lt;/code&gt;文件中的配置来定义的，有些逻辑是通过读取&lt;code&gt;*.Build.cs&lt;/code&gt;的配置处理的。&lt;br&gt;我读了一下UBT的代码，抽出来部分UBT中配置文件(&lt;code&gt;Target.cs&lt;/code&gt;/&lt;code&gt;Build.cs&lt;/code&gt;)参数与MACRO的相互定义，作为速查手册。&lt;br&gt;&lt;code&gt;*.Target.cs&lt;/code&gt;的参数可以看：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html&quot;&gt;UnrealBuildSystem/Targets&lt;/a&gt;&lt;br&gt;&lt;code&gt;*.Build.cs&lt;/code&gt;的参数可以看：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/ModuleFiles/index.html&quot;&gt;UnrealBuildSystem/ModuleFiles&lt;/a&gt;&lt;br&gt;UE的构建系统文档：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/index.html&quot;&gt;Build Tools&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/categories/UnrealEngine/UBT/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/tags/UBT/"/>
    
    <category term="构建系统" scheme="https://imzlp.com/tags/%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>提取Tor并搭建Tor Bridge</title>
    <link href="https://imzlp.com/posts/11177/"/>
    <id>https://imzlp.com/posts/11177/</id>
    <published>2018-11-04T19:36:04.000Z</published>
    <updated>2018-11-05T10:29:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Tor的Bridge如果传播的范围比较广，可能隔几天就被和谐掉了，频繁地换有点麻烦(恍惚间让我想到了当年改host上Google的时光)。今天折腾了一下，自己在VPS上搭建tor的Bridge来自用。&lt;br&gt;而且也从&lt;a href=&quot;https://www.torproject.org/projects/torbrowser.html.en&quot;&gt;Tor Browser&lt;/a&gt;里提取出tor，使其不依赖Tor Browser，可以供其他浏览器使用。&lt;br&gt;&lt;strong&gt;警告&lt;/strong&gt;：部署Bridge&lt;strong&gt;可能&lt;/strong&gt;会增加服务器被墙的概率。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    <category term="tor" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/tor/"/>
    
    
    <category term="暗网" scheme="https://imzlp.com/tags/%E6%9A%97%E7%BD%91/"/>
    
    <category term="onion" scheme="https://imzlp.com/tags/onion/"/>
    
    <category term="Tor" scheme="https://imzlp.com/tags/Tor/"/>
    
    <category term="TorTridge" scheme="https://imzlp.com/tags/TorTridge/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库的使用：加载和链接</title>
    <link href="https://imzlp.com/posts/18949/"/>
    <id>https://imzlp.com/posts/18949/</id>
    <published>2018-10-15T20:50:34.000Z</published>
    <updated>2018-10-15T20:50:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在部分SDK的对接中，有些平台除了DLL外并没有提供导入库来供我们使用，那就只能使用代码中加载DLL的办法来调用DLL内的函数，本文来记录一下两种用法，再分析一下优劣。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="动态链接库" scheme="https://imzlp.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>抓取UE API并生成带索引的Dash文档</title>
    <link href="https://imzlp.com/posts/11515/"/>
    <id>https://imzlp.com/posts/11515/</id>
    <published>2018-07-05T23:43:43.000Z</published>
    <updated>2021-11-22T10:55:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;不知为何，&lt;a href=&quot;http://api.unrealengine.com/INT/API/index.html&quot;&gt;UE API&lt;/a&gt;现在已经不随引擎发布chm的离线文档了，官方发布的最新版本还是2014年的，UE发展到现在有了很多变化，显然四年前的API文档已经丧失部分参考价值了。但是UE文档站自身的搜索功能就我的体验而言，十分的烂。&lt;br&gt;所以折腾了一下把UE API的所有页面爬了下来，并且生成了Dash支持的文档，检索起来十分酸爽。(文后附下载链接)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2022.06.07更新：把API文档更新至UE 5.0.2，可在&lt;a href=&quot;#Update&quot;&gt;文末&lt;/a&gt;下载。。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Dash" scheme="https://imzlp.com/tags/Dash/"/>
    
    <category term="Zeal" scheme="https://imzlp.com/tags/Zeal/"/>
    
  </entry>
  
  <entry>
    <title>使用frp进行内网穿透</title>
    <link href="https://imzlp.com/posts/5050/"/>
    <id>https://imzlp.com/posts/5050/</id>
    <published>2018-06-09T11:40:09.000Z</published>
    <updated>2018-11-10T16:19:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近想到还有块树莓派在吃灰，今天使用&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;frp&lt;/a&gt;折腾了一下内网穿透，把放在家里的树莓派也可以通过外网访问。&lt;/p&gt;</summary>
    
    
    
    <category term="折腾记录" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    <category term="内网穿透" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    
    <category term="树莓派" scheme="https://imzlp.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="frp" scheme="https://imzlp.com/tags/frp/"/>
    
    <category term="内网穿透" scheme="https://imzlp.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>UE和VR开发技术笔记</title>
    <link href="https://imzlp.com/posts/3380/"/>
    <id>https://imzlp.com/posts/3380/</id>
    <published>2018-06-06T08:16:10.000Z</published>
    <updated>2019-01-17T14:00:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;平时随笔写下的一些UE4和VR开发中的技术笔记，以及一些相关资料的收录，之前零零散散放在&lt;a href=&quot;https://imzlp.com/notes/&quot;&gt;imzlp.com/notes&lt;/a&gt;中，今天整理了一下，后续的笔记都会放到这篇文章中。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="VR" scheme="https://imzlp.com/categories/UnrealEngine/VR/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>UE无缝地图：传递Actor到下个关卡</title>
    <link href="https://imzlp.com/posts/19376/"/>
    <id>https://imzlp.com/posts/19376/</id>
    <published>2018-04-28T00:43:40.000Z</published>
    <updated>2018-04-28T00:43:40.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;因为UnrealEngine在切换关卡(&lt;code&gt;OpenLevel&lt;/code&gt;)时会把当前关卡的所有对象全部销毁，但是常常我们需要保存某些对象到下一关卡中，今天读了一下相关的代码，本篇文章讲一下如何来实现。&lt;br&gt;其实Unreal的文档是有说明的(&lt;a href=&quot;https://docs.unrealengine.com/en-us/Gameplay/Networking/Travelling&quot;&gt;Travelling in Multiplayer&lt;/a&gt;)，实现起来也并不麻烦，但是UE文档的一贯风格是资料是不详细的，中文资料更是十分匮乏(多是机翻，而且版本很老)，在搜索中也没有查到相关的靠谱的东西，我自己在读代码实现的过程中就随手记了一下，就当做笔记了。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="Seamlesstravel" scheme="https://imzlp.com/tags/Seamlesstravel/"/>
    
  </entry>
  
  <entry>
    <title>Build protobuf with MSVC on Windows</title>
    <link href="https://imzlp.com/posts/9903/"/>
    <id>https://imzlp.com/posts/9903/</id>
    <published>2018-02-27T10:01:32.000Z</published>
    <updated>2018-02-27T10:01:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近有在VS中用到Protobuf，简单记录一下使用MSVC构建Protobuf的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Protobuf" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Protobuf/"/>
    
    
    <category term="Protobuf" scheme="https://imzlp.com/tags/Protobuf/"/>
    
    <category term="序列化" scheme="https://imzlp.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>反向代理Github Pages启用HTTPS</title>
    <link href="https://imzlp.com/posts/18841/"/>
    <id>https://imzlp.com/posts/18841/</id>
    <published>2017-09-07T20:49:29.000Z</published>
    <updated>2018-02-05T13:26:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;由于&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;不支持&lt;code&gt;custom domain&lt;/code&gt;的HTTPS，今天折腾了一下搞定了在VPS上用&lt;a href=&quot;https://nginx.org/en/&quot;&gt;Nginx&lt;/a&gt;到&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;的反向代理，使用的是&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt;签发的证书，实现了全站HTTPS(资源外链也都换成了HTTPS)，简单记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="博客管理" scheme="https://imzlp.com/tags/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Nginx" scheme="https://imzlp.com/tags/Nginx/"/>
    
    <category term="反向代理" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>为什么不能重载&amp;&amp;与||以及,(comma)？</title>
    <link href="https://imzlp.com/posts/11306/"/>
    <id>https://imzlp.com/posts/11306/</id>
    <published>2017-06-24T22:21:39.000Z</published>
    <updated>2017-06-24T22:21:39.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++的基础语法里提供了&lt;code&gt;||&lt;/code&gt;与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;两个逻辑操作符还有&lt;code&gt;,&lt;/code&gt;(comma)运算符。在类中我们也可以重载这些操作符，但是不要这样做，我会在这篇文章中写出标准描述以及不能重载的原因。&lt;br&gt;概括来说，因为内置的||和&amp;amp;&amp;amp;具有短路求值语义，如果你自己重载了他们就变成了普通的函数调用，会具有与built-in &lt;code&gt;||&lt;/code&gt;与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;完全不同的语义。&lt;br&gt;而,操作符具有从左到右求值的语义，所以如果自己重载，会变成函数调用，也会具有不同于built-in的语义。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++技巧" scheme="https://imzlp.com/tags/C-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++模板元编程资料辑录</title>
    <link href="https://imzlp.com/posts/23043/"/>
    <id>https://imzlp.com/posts/23043/</id>
    <published>2017-06-17T23:21:33.000Z</published>
    <updated>2017-06-17T23:21:33.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文主要是我学习模板元编程过程中的一些心得总结，以及我写的一些模板元编程的代码也都会放到这里来。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="模板元编程" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="模板元编程" scheme="https://imzlp.com/tags/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Template" scheme="https://imzlp.com/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>operator new：void*到T*的转换</title>
    <link href="https://imzlp.com/posts/21564/"/>
    <id>https://imzlp.com/posts/21564/</id>
    <published>2017-05-22T18:03:33.000Z</published>
    <updated>2017-05-22T18:03:33.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++14标准(C++98/11也一样)中，在&lt;strong&gt;Annex C Compatibility&lt;/strong&gt;里有这么一条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Change: Converting void* to a pointer-to-object type requires casting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;* b=a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;* c=b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ISO C will accept this usage of pointer to void being assigned to a pointer to object type. C ++ will not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是为什么&lt;code&gt;operator new()&lt;/code&gt;会返回&lt;code&gt;void*&lt;/code&gt;且不用显式转换为&lt;code&gt;T*&lt;/code&gt;就能赋值给&lt;code&gt;T*&lt;/code&gt;呢？&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>lambda在编译器中实现的方式</title>
    <link href="https://imzlp.com/posts/19441/"/>
    <id>https://imzlp.com/posts/19441/</id>
    <published>2017-05-17T23:35:54.000Z</published>
    <updated>2017-05-17T23:35:54.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++中&lt;code&gt;lambda-expression&lt;/code&gt;的结果叫做&lt;code&gt;闭包对象(closure object)&lt;/code&gt;。本篇文章并非是介绍C++ lambda的用法的(这一点《TC++PL》、《C++ Primer》中都十分详细，或者看我之前的总结&lt;a href=&quot;https://imzlp.com/posts/2441/#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot;&gt;C++11的语法糖#lambda表达式&lt;/a&gt;)，而是从LLVM-IR来分析在Clang中是如何实现&lt;code&gt;lambda-expression&lt;/code&gt;的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="lambda" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/lambda/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
    <category term="lambda" scheme="https://imzlp.com/tags/lambda/"/>
    
    <category term="闭包" scheme="https://imzlp.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>访问控制机制的可见性与可访问性</title>
    <link href="https://imzlp.com/posts/17586/"/>
    <id>https://imzlp.com/posts/17586/</id>
    <published>2017-05-13T10:44:06.000Z</published>
    <updated>2017-05-13T10:44:06.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;https://imzlp.com/posts/12080&quot;&gt;突破C++类的访问控制机制&lt;/a&gt;中简略提到了C++类的成员访问控制(&lt;code&gt;public&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt;/&lt;code&gt;private&lt;/code&gt;)只是限制了成员名字的&lt;strong&gt;可访问性(accessable)**而非&lt;/strong&gt;可见性(visable)**。在这篇文章中主要分析这种性质带来的后果以及如何避免。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="pimpl" scheme="https://imzlp.com/tags/pimpl/"/>
    
  </entry>
  
  <entry>
    <title>突破C++类的访问控制机制</title>
    <link href="https://imzlp.com/posts/12080/"/>
    <id>https://imzlp.com/posts/12080/</id>
    <published>2017-05-12T11:58:05.000Z</published>
    <updated>2021-05-24T17:28:06.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;众所周知，在C++中类成员能够具有三种访问权限，分别为&lt;code&gt;public&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt;/&lt;code&gt;private&lt;/code&gt;：&lt;br&gt;[ISO/IEC 14882:2014]A member of a class can be&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;: that is, its name can be used only by members and friends of the class in which it is declared.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;protected&lt;/strong&gt;: that is, its name can be used only by members and friends of the class in which it is declared, by classes derived from that class, and by their friends (see 11.4).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;: that is, its name can be used anywhere without access restriction.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从标准意图上来看，是希望隐藏类的实现细节和底层数据，即为&lt;strong&gt;封装&lt;/strong&gt;。但是我们也可以通过一些特殊的方式来突破访问权限的限制。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>技术书籍书评汇总</title>
    <link href="https://imzlp.com/posts/15564/"/>
    <id>https://imzlp.com/posts/15564/</id>
    <published>2017-05-06T02:57:42.000Z</published>
    <updated>2017-05-06T02:57:42.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;单独开一篇文章，之前零零散散的书评散落在&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;笔记&lt;/a&gt;和&lt;a href=&quot;https://imzlp.com/tweets&quot;&gt;微言&lt;/a&gt;中，没有具体辑录到一块，不方便索引。以后读过的技术类的书籍之后我会写一些评价就都放到这里来了。因为评价对象是技术书籍，只言片语也不能描述所有的技术细节，本文立意也非“技术笔记”而是“书籍评价”，所以我不会在这里涉及太多书籍中描述的技术细节，只是我作为一个普通读者的阅读感受以及分享我个人的阅读技巧，若其中对某些书透露出褒贬之意均为我个人对书籍的评价无任何贬低作者的意图。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>特殊成员函数的隐式声明及其标准行为</title>
    <link href="https://imzlp.com/posts/21790/"/>
    <id>https://imzlp.com/posts/21790/</id>
    <published>2017-05-04T23:37:05.000Z</published>
    <updated>2017-05-04T23:37:05.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++编程中比较痛恨欲绝的事莫过于：编译器瞒着程序员做了太多事。&lt;br&gt;本篇文章是从C++标准([ISO/IEC 14882:2014])中整理摘录出来的关于编译器生成类的&lt;code&gt;默认构造函数(default constructor)&lt;/code&gt;/&lt;code&gt;拷贝/移动构造函数(copy/move constructor)&lt;/code&gt;/&lt;code&gt;拷贝/移动赋值操作符(copy/move assignment operator)&lt;/code&gt;/&lt;code&gt;析构函数(destructor)&lt;/code&gt;这六个特殊成员函数的几种情况以及其实际行为的文档。可以作为《Inside The C++ Object Model》的辅助资料，组合观看效果更佳(通过标准描述来理解编译器的实现)。&lt;br&gt;另外，《Inside The C++ Object Model》主要是从“编译器实现”的角度来描述的，但是从“C++标准”的角度来看，书里很多是依赖于编译器实现的，就像虚函数表，标准并没有规定编译器应该用何种方式实现多态行为，自然也就不可能描述关于虚函数表的东西。&lt;br&gt;还有很多对于“编译器生成”的行为在主观意识中带有歧义的理解，都可以在这里找到解答，这也是读C++标准的乐趣所在——不论好坏，标准&lt;strong&gt;规定&lt;/strong&gt;不会出错，所有不符合标准描述的实现都是unstandard的。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>函数模板的特化和重载</title>
    <link href="https://imzlp.com/posts/10380/"/>
    <id>https://imzlp.com/posts/10380/</id>
    <published>2017-05-04T00:20:56.000Z</published>
    <updated>2017-05-04T00:20:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;不同于类模板，可以具有显式特化和局部特化(partial specializations)，函数模板没有”局部特化”的概念，只有显式特化和重载。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C++中指向类成员的指针并非指针</title>
    <link href="https://imzlp.com/posts/27615/"/>
    <id>https://imzlp.com/posts/27615/</id>
    <published>2017-04-29T21:28:17.000Z</published>
    <updated>2019-04-22T00:38:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;“指向类成员的指针(Pointers to members)”，是一种在C++不常用的特性，但是这里使用术语“指针”略有不妥，因为它们并不包含地址，行为也不像指针。&lt;br&gt;本篇文章会通过LLVM-IR来分析clang中对于“指向类成员的指针”的实现方式，以及穿插C++14标准内定义的相关内容和涉及到的LLVM-IR的语法。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要extern &quot;C&quot;?</title>
    <link href="https://imzlp.com/posts/5392/"/>
    <id>https://imzlp.com/posts/5392/</id>
    <published>2017-04-11T22:20:00.000Z</published>
    <updated>2017-04-24T01:14:08.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章(&lt;a href=&quot;https://imzlp.com/posts/27118/&quot;&gt;C/C++编译模型分析&lt;/a&gt;)中介绍了C和C++中编译和链接的成因和方式。接上篇文章的坑，本篇文章从&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;着手分析C和C++编译与链接模型中的不同点及其成因，主要为&lt;code&gt;function overload&lt;/code&gt;、&lt;code&gt;function signatures&lt;/code&gt;、&lt;code&gt;name mangling&lt;/code&gt;三个部分。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译和链接" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译模型" scheme="https://imzlp.com/tags/%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编译和链接模型分析</title>
    <link href="https://imzlp.com/posts/27118/"/>
    <id>https://imzlp.com/posts/27118/</id>
    <published>2017-04-10T23:05:44.000Z</published>
    <updated>2017-07-02T00:18:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C和C++均使用分离编译来支持多源文件模块化机制，但是为什么这么做以及如何做是个值得探讨的问题。本篇文章并非是讲述C和C++中如何才能产生不同链接的语法规则，而是分析下C/C++编译器是如何实现编译和链接模型的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译和链接" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译模型" scheme="https://imzlp.com/tags/%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Array of length zero</title>
    <link href="https://imzlp.com/posts/21095/"/>
    <id>https://imzlp.com/posts/21095/</id>
    <published>2017-03-30T19:00:01.000Z</published>
    <updated>2017-03-31T11:48:43.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;看了下在C中&lt;code&gt;Array of length zero&lt;/code&gt;的用法，感觉脑洞大开啊。不过从标准角度(非编译器扩展)来说，这个特性只存在于C语言(C99之后)，C++中是不存在的。先挖个坑，来分析一下。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟存储器的缺页异常分析</title>
    <link href="https://imzlp.com/posts/30933/"/>
    <id>https://imzlp.com/posts/30933/</id>
    <published>2017-03-22T01:22:02.000Z</published>
    <updated>2017-03-22T01:22:02.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;考虑这样一个问题：能否通过管道(fifo)从一个进程A向另一个进程B(A和B之间并无亲属关系)中传递A进程中对象的地址，从而在进程B中访问到A进程的对象呢？&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://imzlp.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟存储器" scheme="https://imzlp.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
    
    <category term="操作系统" scheme="https://imzlp.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟存储器" scheme="https://imzlp.com/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器的迭代器失效</title>
    <link href="https://imzlp.com/posts/3276/"/>
    <id>https://imzlp.com/posts/3276/</id>
    <published>2017-03-17T11:43:47.000Z</published>
    <updated>2017-03-17T11:43:47.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;容器的大小指的是容器中的元素数目；容器的容量指的是重新分配更多内存之前容器能够保存的元素数目。在改变大小或容量时，元素可能会移动到新的存储位置。这意味着指向元素的迭代器(以及指针或引用)可能会失效(即指向旧元素的位置)。&lt;br&gt;指向关联容器元素的迭代器只有当所指元素从容器中删除时(erase)才会失效。与之相反，指向顺序容器元素的迭代器当重新分配空间(&lt;code&gt;resize()&lt;/code&gt;/&lt;code&gt;reverse()&lt;/code&gt;或&lt;code&gt;push_back()&lt;/code&gt;)或指向元素在容器中移动(如在前一个位置进行&lt;code&gt;erase()&lt;/code&gt;或者&lt;code&gt;insert()&lt;/code&gt;)也会失效。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>通过IR代码来分析C++代码语义</title>
    <link href="https://imzlp.com/posts/20479/"/>
    <id>https://imzlp.com/posts/20479/</id>
    <published>2017-03-08T11:46:55.000Z</published>
    <updated>2017-03-08T11:46:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;IR代码是LLVM生成的&lt;code&gt;Intermediate Code&lt;/code&gt;。可以通过IR代码来分析编译器对我们所写的代码是如何解析并执行的，使得分析代码语义变得简洁明了。IR代码的语法语义可参考&lt;a href=&quot;http://llvm.org/docs/LangRef.html#store-instruction&quot;&gt;LLVM Language Reference Manual&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
  </entry>
  
  <entry>
    <title>fork/vfork浅谈</title>
    <link href="https://imzlp.com/posts/2658/"/>
    <id>https://imzlp.com/posts/2658/</id>
    <published>2017-03-06T13:40:08.000Z</published>
    <updated>2017-03-06T13:40:08.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在*UNIX中可以通过fork/vfork来实现多进程编程，整理总结一下相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX" scheme="https://imzlp.com/categories/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/categories/UNIX/POSIX/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/tags/POSIX/"/>
    
    <category term="多进程" scheme="https://imzlp.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="multi-process" scheme="https://imzlp.com/tags/multi-process/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中的编程技巧及其概念</title>
    <link href="https://imzlp.com/posts/1756/"/>
    <id>https://imzlp.com/posts/1756/</id>
    <published>2017-03-05T01:21:25.000Z</published>
    <updated>2017-04-28T07:53:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;一些C++中比较能令人迷惑或者用法比较奇特的示例记录。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="笔记" scheme="https://imzlp.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>main原型考证及程序终止行为</title>
    <link href="https://imzlp.com/posts/15272/"/>
    <id>https://imzlp.com/posts/15272/</id>
    <published>2017-02-27T15:30:09.000Z</published>
    <updated>2017-02-27T15:30:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C和C++中流传着很多版本的&lt;code&gt;main&lt;/code&gt;函数原型，不同的书里也有不同的写法。今天我从几种标准(C89/99/11以及C++98/03/11/14)的角度来寻找一下什么是“&lt;strong&gt;标准行为&lt;/strong&gt;”以及在主函数中return后发生了什么。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C和C++之间的不兼容</title>
    <link href="https://imzlp.com/posts/14446/"/>
    <id>https://imzlp.com/posts/14446/</id>
    <published>2017-02-27T15:25:56.000Z</published>
    <updated>2017-05-23T10:46:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前提到过数次C和C++并不是一个语言，就算是C++中从C继承来的那部分也和ISO C有很大区别，以后我会逐渐整理一些它们之间不兼容的特性到这里来。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C++中declaration与define的区别</title>
    <link href="https://imzlp.com/posts/21831/"/>
    <id>https://imzlp.com/posts/21831/</id>
    <published>2017-02-24T21:09:53.000Z</published>
    <updated>2017-02-24T21:09:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;看过不少C++的书籍里都没有明确地指出处声明(declaration)与定义(define)的区别，或者只是提到了需要支持分离式编译，使用&lt;code&gt;extern&lt;/code&gt; specifier的就是声明，不带的就是定义。实际上我觉得C++标准中对于声明(declaration)与定义(define)的区别描述的更为清晰。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>对象的构造和析构顺序</title>
    <link href="https://imzlp.com/posts/16550/"/>
    <id>https://imzlp.com/posts/16550/</id>
    <published>2017-02-19T18:04:24.000Z</published>
    <updated>2017-02-19T18:04:24.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过一道CppQuiz的题来使用C++14标准描述C++的对象在继承情况下构造和析构的顺序，以及在对象构造/析构时抛出异常。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="对象模型" scheme="https://imzlp.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>重载(overload)和重写(override)</title>
    <link href="https://imzlp.com/posts/29726/"/>
    <id>https://imzlp.com/posts/29726/</id>
    <published>2017-02-06T05:08:43.000Z</published>
    <updated>2017-02-06T05:08:43.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++中&lt;code&gt;重载(overload)&lt;/code&gt;和&lt;code&gt;重写(override)&lt;/code&gt;并无关系，但是由于这个词比较相似还是容易搞混的。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux上的Samba配置</title>
    <link href="https://imzlp.com/posts/17347/"/>
    <id>https://imzlp.com/posts/17347/</id>
    <published>2017-02-04T05:29:47.000Z</published>
    <updated>2017-02-04T05:29:47.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过Samba我们可以将Linux上的文件夹挂载到Windows上，开台Linux虚拟机部署Samba之后，在Windows就可以使用我前几天写的远程编译插件(&lt;a href=&quot;https://imzlp.com/posts/11793/&quot;&gt;sublimeRemoteCompile&lt;/a&gt;)来写代码啦！还是挺爽的。今天把服务器配置Samba共享文件的方法简单记录一下，方便有同样需求的朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="Samba" scheme="https://imzlp.com/tags/Samba/"/>
    
  </entry>
  
  <entry>
    <title>工具、环境的知识收录</title>
    <link href="https://imzlp.com/posts/16793/"/>
    <id>https://imzlp.com/posts/16793/</id>
    <published>2017-02-03T23:39:14.000Z</published>
    <updated>2019-01-17T14:15:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;一些工具、环境配置的一些技巧或者相关的知识概念记录在这里。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="笔记" scheme="https://imzlp.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SublimeText的远程编译插件</title>
    <link href="https://imzlp.com/posts/11793/"/>
    <id>https://imzlp.com/posts/11793/</id>
    <published>2017-01-25T01:43:55.000Z</published>
    <updated>2017-01-25T01:43:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;经常在Win上写一些跑在Linux上的测试小代码还需要手动在Linux下执行编译命令有些麻烦，而且我用树莓派配置samba将代码共享到Win上也需要ssh上去手动编译，有点浪费时间。&lt;br&gt;这几天闲时写了一个SublimeText的小插件，用来在windows下远程编译C/C++的代码，就是在Windows上写代码但是实际会在Linux上执行。目前只是实现了功能，等放假后休息时有空优化一下。&lt;br&gt;代码放在Github上：&lt;a href=&quot;https://github.com/hxhb/sublimeRemoteCompile&quot;&gt;sublimeRemoteCompile&lt;/a&gt;，使用了一些&lt;code&gt;C++11&lt;/code&gt;的特性，编译时需指定。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="小项目" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/tags/SublimeText/"/>
    
  </entry>
  
  <entry>
    <title>数组下标访问背后隐含的逻辑</title>
    <link href="https://imzlp.com/posts/20449/"/>
    <id>https://imzlp.com/posts/20449/</id>
    <published>2017-01-16T00:59:09.000Z</published>
    <updated>2017-01-16T00:59:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;对于数组而言，下标运算是随机读写的一种方式，也是最常用的方式。但是有很多教材(尤其是国内教材)一上来就说数组名就是指针，这是不对的。而且对于数组的下标访问背后是有一套规则的，熟悉这些规则可以在一些复杂语义的情况下分析出代码的实际含义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>裹一层重载的成员函数指针</title>
    <link href="https://imzlp.com/posts/19740/"/>
    <id>https://imzlp.com/posts/19740/</id>
    <published>2016-12-31T04:02:13.000Z</published>
    <updated>2017-05-15T16:27:14.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用变长参数模板和lambda(或者使用generic lambda)来裹一层重载的成员函数指针，从而方便使用(bind绑定或者其他需要重载的成员函数指针的地方)。&lt;br&gt;关于&lt;strong&gt;成员函数指针&lt;/strong&gt;的更多介绍请看我的另一篇文章：&lt;a href=&quot;https://imzlp.com/posts/27615&quot;&gt;C++中指向类成员的指针并非指针&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>The C++ Object and Memory Model</title>
    <link href="https://imzlp.com/posts/21843/"/>
    <id>https://imzlp.com/posts/21843/</id>
    <published>2016-12-15T21:11:24.000Z</published>
    <updated>2016-12-15T21:11:24.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;More documentation:&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/memory_model&quot;&gt;Memory Model&lt;/a&gt; and &lt;a href=&quot;https://imzlp.com/2016/05/18/about-the-compiler-to-generate-the-default-constructor/&quot;&gt;Default Constructor Construction&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://imzlp.com/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>关于读书的一些思考</title>
    <link href="https://imzlp.com/posts/17446/"/>
    <id>https://imzlp.com/posts/17446/</id>
    <published>2016-12-11T20:43:42.000Z</published>
    <updated>2016-12-11T20:43:42.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;如何对一门不熟悉的领域或者书籍划定其中最重要的20%？如何划定细枝末节？&lt;br&gt;之前读书和学习中没有深入思考过这些方法论的东西，觉得方法论只是空谈，但是现在觉得掌握一个合适的技巧如有利刃在手，披荆斩棘方可游刃有余。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读TC++PL、C++Primer和ISO C++</title>
    <link href="https://imzlp.com/posts/4367/"/>
    <id>https://imzlp.com/posts/4367/</id>
    <published>2016-12-06T23:16:00.000Z</published>
    <updated>2016-12-06T23:16:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;花了一个月的时间读完了TC++PL4E，因为我之前读过C++ Primer，C++大部分的语法内容都已了解，所以读的速度还是比较快的，但是通过组合阅读C++标准也发现了很多C++中我原本不知道的东西，从标准和C++之父的视角来看C++确实是足够全面了，由此来对比一下C++ Primer、TC++PL4E和ISO C++文档。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>What is POD in C++?</title>
    <link href="https://imzlp.com/posts/1140/"/>
    <id>https://imzlp.com/posts/1140/</id>
    <published>2016-12-03T00:04:28.000Z</published>
    <updated>2016-12-03T00:04:28.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;POD is  Plain Old Data(普通旧数据).在C++中是指能被“仅当作数据”处理的对象，程序员无暇顾及类布局的复杂性以及用户自定义的构造、拷贝和移动语义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>激进的ADL(Argument-dependent lookup)</title>
    <link href="https://imzlp.com/posts/25788/"/>
    <id>https://imzlp.com/posts/25788/</id>
    <published>2016-11-29T22:39:14.000Z</published>
    <updated>2016-11-29T22:39:14.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;ADL是&lt;code&gt;Argument-dependent lookup&lt;/code&gt;的简写，中文译作参数依赖查找。ADL对于避免冗长的代码很有用处，但是也会造成一些歧义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>TC++PL4E中英版勘误</title>
    <link href="https://imzlp.com/posts/409/"/>
    <id>https://imzlp.com/posts/409/</id>
    <published>2016-11-20T21:46:53.000Z</published>
    <updated>2016-11-20T21:46:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在读The C++ Programming Language Fourth Edition(简称TC++PL4E)，由于我入的实体书是中译本(原版好贵)，所以我是对照着英文版PDF看的，发现了一些原版和中译本中的勘误，还有一些我觉得书中歧义的地方，查阅标准(ISO/IEC 14882:2014(E))之后的定义也一并贴出，汇总在这里列出来。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="勘误表" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8B%98%E8%AF%AF%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="勘误表" scheme="https://imzlp.com/tags/%E5%8B%98%E8%AF%AF%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C/C++标准的一些摘录</title>
    <link href="https://imzlp.com/posts/19242/"/>
    <id>https://imzlp.com/posts/19242/</id>
    <published>2016-11-12T01:19:51.000Z</published>
    <updated>2017-04-05T15:19:57.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C/C++的很多资料网上数不胜数，但是经常会遇到看了一些文章资料后，我觉得作者自己都没彻底明白到底写的是什么(回头看看我以前写的文章也是，那时的眼光太片面和浅显了)。&lt;br&gt;所以对于C/C++的东西我觉得还是要直接来翻标准文档才行，因为标准是不会出现歧义的。不能盲目地只是在网上搜寻并相信别人二次消化过的资料。&lt;br&gt;我认为对于C/C++语言特性的知识，查阅这四份文档就足够了(点击即可在线预览或下载)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/standard/isoc99.pdf&quot;&gt;ISO/IEC 9899:1999 (E)&lt;/a&gt; (C99标准)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/clang/TCPL2E.pdf&quot;&gt;The C Programming language Second Edition&lt;/a&gt; (C语言之父Dennis Ritchie和Brian Kernighan的大作)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/standard/isocpp2014.pdf&quot;&gt;ISO/IEC 14882:2014(E)&lt;/a&gt; (C++14标准)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/cpp/TCPPPL4E.pdf&quot;&gt;The C++ Programming Language Fourth Edition&lt;/a&gt; (C++之父撰写，依据C++11标准)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之所以C语言标准没有依据最新的C11标准是因为目前的C++标准(C++14)的&lt;code&gt;Normative references&lt;/code&gt;的C部分是&lt;strong&gt;ISO/IEC 9899:1999&lt;/strong&gt;，使用TCPL和TC++PL可以作为C/C++标准的应用性描述，可以相互印证。&lt;br&gt;更多的关于C++&lt;code&gt;Normative references&lt;/code&gt;的内容可参照&lt;a href=&quot;https://o66j3dueo.qnssl.com/Document/ISOIEC.14882.2014%28C++14%29.pdf&quot;&gt;ISO/IEC 14882:2014(E)&lt;/a&gt; §1.2 Normative references.&lt;br&gt;我会逐渐把一些常见的会让人觉得模棱两可的语言特性查阅的标准规范摘录到这里来，可以保证写出的东西在标准文档中都有依据。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>CppQuiz一些有趣的题和分析</title>
    <link href="https://imzlp.com/posts/10205/"/>
    <id>https://imzlp.com/posts/10205/</id>
    <published>2016-10-24T06:15:05.000Z</published>
    <updated>2016-10-24T06:15:05.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://cppquiz.org/&quot;&gt;CppQuiz&lt;/a&gt; is a simple online quiz that you can use to test your knowledge of the C++ programming language.&lt;br&gt;很有意思，今天刷了几道随手写点东西出来，以后有空再刷刷都放到这里来好了。其实CppQuiz有很多题都可以从《深度探索C++对象模型》中找到原因…如果有很多题不会做我建议还是买一本《深度探索C++对象模型》认真看一遍吧！&lt;br&gt;另外，我尽量在解答题的同时会在C++标准(ISO/IEC 14882：2014)中找到相关的描述。&lt;/p&gt;</summary>
    
    
    
    <category term="代码分析" scheme="https://imzlp.com/categories/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="CppQuiz" scheme="https://imzlp.com/tags/CppQuiz/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Github/Coding Pages博客</title>
    <link href="https://imzlp.com/posts/42318/"/>
    <id>https://imzlp.com/posts/42318/</id>
    <published>2016-10-21T06:36:49.000Z</published>
    <updated>2016-10-21T06:36:49.000Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客已切换为Github Action进行自动化部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用Hexo生成静态博客然后部署到Github/Coding Pages是目前我的博客的托管方式。&lt;br&gt;用起来是很爽，但是存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hexo的环境配置太麻烦，麻烦到几乎换台电脑就不能更新博客了&lt;/li&gt;
&lt;li&gt;每次修改文章之后都要重新生成一遍&lt;/li&gt;
&lt;li&gt;再加上提交博客源文件的话执行命令的次数太多了(主要是第一步)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在提交博文的时候浪费了很多时间，我优化了一下流程几乎可以全自动提交更新了。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="持续集成" scheme="https://imzlp.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Boost源码分析笔记</title>
    <link href="https://imzlp.com/posts/18194/"/>
    <id>https://imzlp.com/posts/18194/</id>
    <published>2016-10-19T21:39:33.000Z</published>
    <updated>2016-10-19T21:39:33.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在读Boost的代码，将一些Boost库中好用的模块用法以及实现分析写一下咯，不定期更新。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Boost" scheme="https://imzlp.com/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>配置SublimeText为Boost开发环境</title>
    <link href="https://imzlp.com/posts/49268/"/>
    <id>https://imzlp.com/posts/49268/</id>
    <published>2016-10-13T09:24:16.000Z</published>
    <updated>2016-10-13T09:24:16.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;近期想研究下&lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt;库，网络上提供的大都是使用IDE(VS/Code::Blocks等)的教程，但是只是写一些测试代码就要开个臃肿的IDE我是很不爽的，今天折腾了一下在SublimeText中编译/链接使用Boost库的代码。顺便把折腾过程/工具整理了出来，如果别人有这样的需求而且恰好能看到这篇文章的话，就能少浪费时间了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016.11.01 Update&lt;/strong&gt;&lt;br&gt;使用最新版本MinGW64-GCC6.2(x86_64-6.2.0-posix-seh-rt_v5-rev1)来编译出LLVM/Clang 3.9，再使用编译出来的Clang编译Boost1.62，之前在Clang中链接编译出来的Boost库出现的报错情况消失了。&lt;br&gt;&lt;strong&gt;注意：使用Clang编译Boost时，最好确保当前的clang版本是由当前系统中gcc的版本编译而来的，不然使用clang链接编译出来的静态链接库时会出现奇怪的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在这里下载我编译好的版本：&lt;a href=&quot;http://pan.baidu.com/s/1i5PpoB7&quot;&gt;MinGW62-GCC6.2(x86_64-6.2.0-posix-seh-rt_v5-rev1)&lt;/a&gt;，使用GCC6.2(上面的MinGW版本)编译的&lt;a href=&quot;http://pan.baidu.com/s/1pKLyZ7H&quot;&gt;LLVM/Clang3.9&lt;/a&gt;，以及&lt;a href=&quot;http://pan.baidu.com/s/1eRZU26u&quot;&gt;Boost(MinGW64-GCC6.2/LLVM3.9/VC14-ALL)&lt;/a&gt;，需要的链接库版本(debug/release/static等)可以自行选择。&lt;br&gt;完整的编译工具链可以&lt;a href=&quot;http://pan.baidu.com/s/1pKN0TPh&quot;&gt;点此下载&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/SublimeText/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/tags/SublimeText/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Boost" scheme="https://imzlp.com/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署shadowsocks服务</title>
    <link href="https://imzlp.com/posts/354/"/>
    <id>https://imzlp.com/posts/354/</id>
    <published>2016-10-10T22:10:01.000Z</published>
    <updated>2016-10-10T22:10:01.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://app.arukas.io/&quot;&gt;Arukas&lt;/a&gt;是日本的一家&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;服务供应商，目前属于测试阶段，可以免费使用。我们可以用&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;很方便的来做一些很有趣(好用)的事，比如部署自己的博客或者shadowsocks服务器。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://imzlp.com/categories/Docker/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Docker" scheme="https://imzlp.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在UE中使用Git进行版本控制</title>
    <link href="https://imzlp.com/posts/7647/"/>
    <id>https://imzlp.com/posts/7647/</id>
    <published>2016-10-07T23:31:01.000Z</published>
    <updated>2016-10-07T23:31:01.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Unreal Editor中提供的Source Control可以通过Git实现蓝图项目的&lt;strong&gt;版本提交/版本比对/撤销修改&lt;/strong&gt;等一些基本功能，远远比不上Git Bash强大，但是BluePrint间的Diff还是很好用的。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    <category term="Git" scheme="https://imzlp.com/categories/UnrealEngine/Git/"/>
    
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="SourceControl" scheme="https://imzlp.com/tags/SourceControl/"/>
    
    <category term="版本控制" scheme="https://imzlp.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git快速上手指南</title>
    <link href="https://imzlp.com/posts/53696/"/>
    <id>https://imzlp.com/posts/53696/</id>
    <published>2016-09-29T22:19:37.000Z</published>
    <updated>2018-08-15T00:57:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;我司最近搭建了内网服务器，以后再做项目时都要用git来进行版本控制了，我在这里把一些常用的操作写下来方便查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="版本控制" scheme="https://imzlp.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Git" scheme="https://imzlp.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
    <category term="SourceControl" scheme="https://imzlp.com/tags/SourceControl/"/>
    
    <category term="版本控制" scheme="https://imzlp.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>为C++的switch添加case的字符串匹配</title>
    <link href="https://imzlp.com/posts/1494/"/>
    <id>https://imzlp.com/posts/1494/</id>
    <published>2016-09-24T22:43:23.000Z</published>
    <updated>2016-09-24T22:43:23.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++标准中的&lt;code&gt;switch&lt;/code&gt;是不能够实现字符串的case匹配的，但是往往我们也有这个需求，来实现一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>总结一下编码的几个习惯</title>
    <link href="https://imzlp.com/posts/35673/"/>
    <id>https://imzlp.com/posts/35673/</id>
    <published>2016-09-13T07:26:09.000Z</published>
    <updated>2016-09-13T07:26:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最开始写代码的时候总是拿到一个问题就捋起袖子开干，基本上就是属于边写代码边排错顺便在写代码中设计解决问题的流程，但是这样效率实在是太慢，有很大的可能就是边写边删，等同于设计出来的蹩脚的就重构了，浪费了很多时间。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>读《C++语言的设计与演化》及一些疑问的解答</title>
    <link href="https://imzlp.com/posts/30227/"/>
    <id>https://imzlp.com/posts/30227/</id>
    <published>2016-09-09T08:15:46.000Z</published>
    <updated>2016-09-09T08:15:46.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1096216/&quot;&gt;C++语言的设计与演化&lt;/a&gt;是C++作者Bjarne Stroustrup撰写的一本关于C++从构思设计到实际实现中思考权衡的过程的书，也(应该)是市面上唯一一本语言设计者站在&lt;strong&gt;语言设计&lt;/strong&gt;的视角所写的书。&lt;/p&gt;
&lt;p&gt;有很多问题我们不应该只知道&lt;strong&gt;How&lt;/strong&gt;，更应该知道&lt;strong&gt;Why&lt;/strong&gt;，因为这样可以从更深层次地理解这个东西。所幸的是《C++语言的设计与演化》就是这么一本书。最近在读期间明白了很多之前在C++中只知道&lt;strong&gt;How&lt;/strong&gt;而不知道&lt;strong&gt;Why&lt;/strong&gt;的东西(为了与C兼容C++真是割舍了太多)，这篇文章算是一篇读书笔记和关于&lt;strong&gt;Why&lt;/strong&gt;的记录，我会逐步整理出来。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Unreal Engine 4采集360°全景视频</title>
    <link href="https://imzlp.com/posts/64044/"/>
    <id>https://imzlp.com/posts/64044/</id>
    <published>2016-09-05T19:44:11.000Z</published>
    <updated>2016-09-05T19:44:11.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文部分内容摘自Unreal Engine的官方博客文章：&lt;a href=&quot;https://www.unrealengine.com/zh-CN/blog/capturing-stereoscopic-360-screenshots-videos-movies-unreal-engine-4&quot;&gt;从虚幻4中采集360度立体电影&lt;/a&gt;，其余部分为修正该文章错误和提供一个现成可行的解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="UnrealEngine" scheme="https://imzlp.com/categories/UnrealEngine/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="全景视频" scheme="https://imzlp.com/tags/%E5%85%A8%E6%99%AF%E8%A7%86%E9%A2%91/"/>
    
    <category term="UnrealEngine" scheme="https://imzlp.com/tags/UnrealEngine/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
    <category term="虚拟现实" scheme="https://imzlp.com/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>读CSAPP：与《现代操作系统》的比较</title>
    <link href="https://imzlp.com/posts/33213/"/>
    <id>https://imzlp.com/posts/33213/</id>
    <published>2016-08-30T01:32:15.000Z</published>
    <updated>2016-08-30T01:32:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天读&lt;strong&gt;CSAPP&lt;/strong&gt;读的兴起，昨天还发了条动态说读&lt;strong&gt;CSAPP&lt;/strong&gt;比&lt;strong&gt;现代操作系统&lt;/strong&gt;读着爽(哈哈)。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态内存和智能指针</title>
    <link href="https://imzlp.com/posts/4280/"/>
    <id>https://imzlp.com/posts/4280/</id>
    <published>2016-08-25T08:18:53.000Z</published>
    <updated>2016-08-25T08:18:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;智能指针作为C++11最重要的特性之一，相关的内容本来是辑录在&lt;a href=&quot;https://imzlp.com/2016/05/12/cpp11-new-features/&quot;&gt;C++11的语法糖&lt;/a&gt;中，但是这部分太重要而我最近又比较闲(逃)，就单独列出来详细地总结一下咯。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Source Insight插件与配置</title>
    <link href="https://imzlp.com/posts/42068/"/>
    <id>https://imzlp.com/posts/42068/</id>
    <published>2016-08-14T08:08:31.000Z</published>
    <updated>2016-08-14T08:08:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近折腾上了几款开发相关的工具堪称神器，工欲善其事必先利其器也。有时间来整理一下写出来。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="CodeReview" scheme="https://imzlp.com/tags/CodeReview/"/>
    
  </entry>
  
  <entry>
    <title>使用VisualGDB在VS上编写Linux程序</title>
    <link href="https://imzlp.com/posts/9932/"/>
    <id>https://imzlp.com/posts/9932/</id>
    <published>2016-08-08T00:53:42.000Z</published>
    <updated>2016-08-08T00:53:42.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;作为一个cpper和Linuxer，经常在Linux上写代码，最近发现了VisualGDB(VS的插件)这个神器，从此也可以在Windows上直接写跑在Linux的程序了！调试起来更爽！&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="VisualGDB" scheme="https://imzlp.com/tags/VisualGDB/"/>
    
    <category term="VisualStudio" scheme="https://imzlp.com/tags/VisualStudio/"/>
    
  </entry>
  
  <entry>
    <title>在VPS上部署shadowsocks服务</title>
    <link href="https://imzlp.com/posts/31145/"/>
    <id>https://imzlp.com/posts/31145/</id>
    <published>2016-07-27T20:34:32.000Z</published>
    <updated>2016-07-27T20:34:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天帮同事搭了一台用作代理的VPS，顺道把这些东西整理了一下。&lt;br&gt;本文不是面向零基础读者的，在阅读下面的东西之前，你首先应该有一台可以访问外网(国外网络)的VPS，其次你也应该具有一些基本的Linux操作的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    <category term="Shadowsocks" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/Shadowsocks/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="VPS" scheme="https://imzlp.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>学习C/C++的一些书籍和工具</title>
    <link href="https://imzlp.com/posts/64054/"/>
    <id>https://imzlp.com/posts/64054/</id>
    <published>2016-06-12T12:08:43.000Z</published>
    <updated>2016-06-12T12:08:43.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;从开始学C语言到现在也有五六年的时间了，也看了不少的好书和烂书，折腾了很多工具(编译器/编辑器圣战)，在这里详细汇总一下。折腾久了能够得到一种思想，这种思想不同于那种“拿来主义”，而是“自己去做”的经验。&lt;/p&gt;</summary>
    
    
    
    <category term="资源分享" scheme="https://imzlp.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>未来计划</title>
    <link href="https://imzlp.com/posts/52122/"/>
    <id>https://imzlp.com/posts/52122/</id>
    <published>2016-06-10T09:52:32.000Z</published>
    <updated>2016-06-10T09:52:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/52122/future-plans.webp&quot;&gt;&lt;br&gt;转眼大学即将毕业了，虽然大学期间学了(折腾)了不少东西，但是还是觉得很菜啊，还要继续努力。&lt;br&gt;对于未来我有几点想法，在这个当口写下来吧。督促勉励自己。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈高考</title>
    <link href="https://imzlp.com/posts/27665/"/>
    <id>https://imzlp.com/posts/27665/</id>
    <published>2016-06-08T07:44:11.000Z</published>
    <updated>2016-06-08T07:44:11.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天是高考的时间，想到了几年之前我参加高考的时候，那个时候还是too young，觉得有自己追求的东西就要去做，浪费了很多时间在学习编程上。可是现在看来高中的时候还是要好好学习的，因为学历就刚毕业而言确实是门槛。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pthread多线程编程</title>
    <link href="https://imzlp.com/posts/58408/"/>
    <id>https://imzlp.com/posts/58408/</id>
    <published>2016-06-04T17:08:48.000Z</published>
    <updated>2016-06-04T17:08:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B&quot;&gt;POSIX线程&lt;/a&gt;（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX" scheme="https://imzlp.com/categories/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/categories/UNIX/POSIX/"/>
    
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="多线程" scheme="https://imzlp.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Pthread" scheme="https://imzlp.com/tags/Pthread/"/>
    
  </entry>
  
  <entry>
    <title>删除void*指针引发的内存泄露</title>
    <link href="https://imzlp.com/posts/6978/"/>
    <id>https://imzlp.com/posts/6978/</id>
    <published>2016-06-04T10:51:47.000Z</published>
    <updated>2016-06-04T10:51:47.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;当一个void*指向一个class object时，我们对其执行&lt;code&gt;delete&lt;/code&gt;操作，会引发未定义行为——可以确定的是该delete操作不会执行object的析构函数，会导致内存泄露。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>结构体成员内存对齐问题</title>
    <link href="https://imzlp.com/posts/61962/"/>
    <id>https://imzlp.com/posts/61962/</id>
    <published>2016-06-02T10:12:34.000Z</published>
    <updated>2016-06-02T10:12:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在讲内存对齐之前，先介绍一个相关的概念——&lt;a href=&quot;http://www.baike.com/wiki/%E5%81%8F%E7%A7%BB%E9%87%8F&amp;prd=so_1_doc&quot;&gt;偏移量&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为“有效地址或偏移量”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，在结构体中偏移量指的是结构体变量中成员的地址和结构体地址的差。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言中不具有原生bool类型</title>
    <link href="https://imzlp.com/posts/20582/"/>
    <id>https://imzlp.com/posts/20582/</id>
    <published>2016-06-01T19:46:55.000Z</published>
    <updated>2016-06-01T19:46:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;有点标题党了，准确的说是C语言标准中并无&lt;code&gt;bool&lt;/code&gt;这个关键字来表示布尔类型。&lt;br&gt;在C++中我们通常使用&lt;code&gt;bool&lt;/code&gt;变量存储逻辑值。&lt;br&gt;但是，C语言中是没有&lt;code&gt;bool&lt;/code&gt;类型的，C语言中只有&lt;code&gt;_Bool&lt;/code&gt;类型。&lt;br&gt;今天和人聊到这个问题，确实容易搞混淆，写出来记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>将树莓派打造成便携的Linux编译环境</title>
    <link href="https://imzlp.com/posts/15989/"/>
    <id>https://imzlp.com/posts/15989/</id>
    <published>2016-05-25T09:04:52.000Z</published>
    <updated>2016-05-25T09:04:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;手头有块Rspberry 2B+，吃灰挺长时间了，由于一直在学校老是停电也就没拿它来跑脚本或者下载机。也正是因为最近学校SSH连接VPS的时候老是断电/网，很郁闷，所以折腾一下把树莓派搞成一个便携的编译环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="树莓派" scheme="https://imzlp.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于编译器生成默认构造函数的一些误区</title>
    <link href="https://imzlp.com/posts/7666/"/>
    <id>https://imzlp.com/posts/7666/</id>
    <published>2016-05-18T19:38:50.000Z</published>
    <updated>2016-05-18T19:38:50.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们编写的一个类没有显式提供构造函数但&lt;code&gt;编译器需要构造函数时&lt;/code&gt;(一定要注意这句话)，编译器会为我们生成一个。&lt;br&gt;但是编译器生成的默认构造函数与我们假想其可以完成的行为并不一致。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++对象模型" scheme="https://imzlp.com/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://imzlp.com/posts/58483/"/>
    <id>https://imzlp.com/posts/58483/</id>
    <published>2016-05-17T19:48:04.000Z</published>
    <updated>2016-05-17T19:48:04.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;实现进程/线程间通信的方法有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程间通信方法有：文件映射、共享内存、匿名管道、命名管道、邮件槽、剪切板、动态数据交换、对象连接与嵌入、动态连接库、远程过程调用等&lt;/li&gt;
&lt;li&gt;线程同步的方法有：事件、临界区、互斥量、信号量&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="进程间通信" scheme="https://imzlp.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
    <category term="操作系统" scheme="https://imzlp.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++11的语法糖</title>
    <link href="https://imzlp.com/posts/2441/"/>
    <id>https://imzlp.com/posts/2441/</id>
    <published>2016-05-12T22:30:19.000Z</published>
    <updated>2016-05-12T22:30:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;从C语言过来觉得C++03和OO的特性简直不能更爽，最近着重看了一下C++11的新特性，觉得有好多很棒的语法糖啊！用起来也很爽啊。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++11" scheme="https://imzlp.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>STL释放指针元素时造成的内存泄露</title>
    <link href="https://imzlp.com/posts/50773/"/>
    <id>https://imzlp.com/posts/50773/</id>
    <published>2016-05-08T13:51:13.000Z</published>
    <updated>2016-05-08T13:51:13.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们删除一个指针时，会删除该指针所指向的对象。但是当STL容器中存放指针对象时却不会这样。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Gprof分析代码性能瓶颈</title>
    <link href="https://imzlp.com/posts/34573/"/>
    <id>https://imzlp.com/posts/34573/</id>
    <published>2016-05-07T13:32:34.000Z</published>
    <updated>2016-05-07T13:32:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用&lt;strong&gt;profiler&lt;/strong&gt;来分析代码的性能比纯脑补分析起来更省力更详细也更直观。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Profiler" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Profiler/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Gprof" scheme="https://imzlp.com/tags/Gprof/"/>
    
    <category term="Profiler" scheme="https://imzlp.com/tags/Profiler/"/>
    
  </entry>
  
  <entry>
    <title>详细分析下C++中的类型转换</title>
    <link href="https://imzlp.com/posts/27258/"/>
    <id>https://imzlp.com/posts/27258/</id>
    <published>2016-05-04T19:35:17.000Z</published>
    <updated>2016-05-04T19:35:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++中，如果一个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。&lt;br&gt;类型转换分为&lt;strong&gt;隐式转换&lt;/strong&gt;、和&lt;strong&gt;显式转换&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中面向对象部分知识整理</title>
    <link href="https://imzlp.com/posts/34569/"/>
    <id>https://imzlp.com/posts/34569/</id>
    <published>2016-04-16T17:31:49.000Z</published>
    <updated>2016-04-16T17:31:49.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;近期准备求职面试。&lt;br&gt;将C++中面向对象部分的基础知识复习整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>选择操作符重载的成员和非成员实现</title>
    <link href="https://imzlp.com/posts/34001/"/>
    <id>https://imzlp.com/posts/34001/</id>
    <published>2016-03-21T16:54:58.000Z</published>
    <updated>2016-03-21T16:54:58.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;为类设计重载操作符的时候，必须选择是将操作符设置为类成员还是普通非成员函数。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读《人生》，谈谈面临的选择</title>
    <link href="https://imzlp.com/posts/54010/"/>
    <id>https://imzlp.com/posts/54010/</id>
    <published>2016-03-20T14:07:26.000Z</published>
    <updated>2016-03-20T14:07:26.000Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中占位修饰符*的用法</title>
    <link href="https://imzlp.com/posts/16506/"/>
    <id>https://imzlp.com/posts/16506/</id>
    <published>2016-03-19T11:49:16.000Z</published>
    <updated>2016-03-19T11:49:16.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在刷题的时候碰到的代码填空看到输出格式中的这段代码：&lt;code&gt;printf(&amp;quot;%*s%s%*s&#92;n&amp;quot;,__________);&lt;/code&gt;&lt;br&gt;需要输出的格式为：&lt;code&gt;________123456________&lt;/code&gt;//下划线为空格&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中错用宏定义造成的二义性</title>
    <link href="https://imzlp.com/posts/38656/"/>
    <id>https://imzlp.com/posts/38656/</id>
    <published>2016-03-14T19:07:46.000Z</published>
    <updated>2016-03-14T19:07:46.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在写代码的时候经常会用到宏(#define)命令，最近我遇到了这两个错用宏的地方，写出来分析一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>配置SublimeText为C/C++的轻量级IDE</title>
    <link href="https://imzlp.com/posts/14596/"/>
    <id>https://imzlp.com/posts/14596/</id>
    <published>2015-12-26T21:54:01.000Z</published>
    <updated>2017-04-10T18:18:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;作为一个cpper，其实早就用惯了GCC这样的工具，不过不得不说啊，GCC的错误信息是真烂啊，虽然有错误提示，但是也经常需要自己肉眼Debug才能搞明白…现在福音来了，&lt;code&gt;Clang&lt;/code&gt;的信息精准度不知道比GCC高到哪里去了。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/SublimeText/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/tags/SublimeText/"/>
    
    <category term="Clang" scheme="https://imzlp.com/tags/Clang/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Wolfram|Alpha求积分</title>
    <link href="https://imzlp.com/posts/8531/"/>
    <id>https://imzlp.com/posts/8531/</id>
    <published>2015-12-24T20:52:35.000Z</published>
    <updated>2015-12-24T20:52:35.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;其实使用&lt;a href=&quot;http://www.wolframalpha.com/&quot;&gt;WolframAlpha&lt;/a&gt;求积分，简直就是大材小用啊(不过这也是硬性的偷懒需求啊)。&lt;br&gt;最近一直在研究Wolfram Language，慢慢发掘新玩法咯。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="Wolfram|Alpha" scheme="https://imzlp.com/tags/Wolfram-Alpha/"/>
    
    <category term="数学" scheme="https://imzlp.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用Koding在线管理静态博客</title>
    <link href="https://imzlp.com/posts/58862/"/>
    <id>https://imzlp.com/posts/58862/</id>
    <published>2015-11-27T13:16:33.000Z</published>
    <updated>2015-11-27T13:16:33.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前都是在local写完文章之后发布上来，在自己电脑上都折腾好了node.js 、hexo、git等一大堆东西。&lt;br&gt;所以在自己电脑上用起来很方便，但是如果换台电脑的话就悲剧了，所有的东西都要自己配置，所以几乎换了台电脑就处于不能用的状态。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Koding" scheme="https://imzlp.com/tags/Koding/"/>
    
  </entry>
  
  <entry>
    <title>读《数学之美》</title>
    <link href="https://imzlp.com/posts/19425/"/>
    <id>https://imzlp.com/posts/19425/</id>
    <published>2015-10-24T18:22:02.000Z</published>
    <updated>2015-10-24T18:22:02.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;到手《数学之美》也有一段的时间了，作为这段时间内我茶余饭后的书籍，确实引起了我极大的兴趣，因为时间分配的不多一天只有阅读一两章左右，昨天看完了所有的章节，意犹未尽啊。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="数学之美" scheme="https://imzlp.com/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>分析密码学中的数学原理</title>
    <link href="https://imzlp.com/posts/30891/"/>
    <id>https://imzlp.com/posts/30891/</id>
    <published>2015-09-09T18:19:26.000Z</published>
    <updated>2015-09-09T18:19:26.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天看到《数学之美》中讲到的计算机中的数学模型，以及《What is Mathematics》的&lt;code&gt;数论&lt;/code&gt;，看的心痒痒。今天懒癌暂时被抑制住了，我就要分析一下，密码学中的数学模型！&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="循迹研究" scheme="https://imzlp.com/tags/%E5%BE%AA%E8%BF%B9%E7%A0%94%E7%A9%B6/"/>
    
    <category term="算法" scheme="https://imzlp.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="密码学" scheme="https://imzlp.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux下使用Shadowsocks服务</title>
    <link href="https://imzlp.com/posts/23429/"/>
    <id>https://imzlp.com/posts/23429/</id>
    <published>2015-08-26T17:31:57.000Z</published>
    <updated>2015-08-26T17:31:57.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天重装了Linux，又不想再用GUI的SS，网上的资料都不怎么好用，自己动手折腾了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    <category term="Shadowsocks" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/Shadowsocks/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>提取优酷订阅视频的RSS源</title>
    <link href="https://imzlp.com/posts/23354/"/>
    <id>https://imzlp.com/posts/23354/</id>
    <published>2015-08-19T14:56:12.000Z</published>
    <updated>2015-08-19T14:56:12.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天在折腾RSS，收集了不少RSS源，对于我等懒人来说，不开网页尽知消息RSS才是真正的利器，这两天搞定了QQ空间的RSS输出（没什么实用性…）还有新浪微博和新浪博客的RSS输出，但是我还比较喜欢的逻辑思维（在优酷），优酷并不提供RSS订阅，目前网内还没有发现什么特别有效的提取优酷订阅RSS源的方法，各种在线转换的网站基本没用，这等还要打开网页才能干的麻烦不能忍，所以动手研究了一下怎么把优酷订阅搞成RSS源，成功了，非常爽。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="RSS" scheme="https://imzlp.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>Windows下自定义Dvorak键盘布局</title>
    <link href="https://imzlp.com/posts/50343/"/>
    <id>https://imzlp.com/posts/50343/</id>
    <published>2015-08-19T11:01:32.000Z</published>
    <updated>2015-08-19T11:01:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;几经波折总算是搞定了windows下的Dvorak布局（不过稍有修改）&lt;br&gt;先从Dvorak的布局图开始说吧&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/50343/dvorakpsb.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="折腾记录" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="Dvorak" scheme="https://imzlp.com/tags/Dvorak/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件推荐</title>
    <link href="https://imzlp.com/posts/841/"/>
    <id>https://imzlp.com/posts/841/</id>
    <published>2015-08-18T14:50:26.000Z</published>
    <updated>2015-08-18T14:50:26.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;LastPass&lt;/code&gt;: Free Password Manager&lt;br&gt;强大的密码管理器，从此以后只记住一个密码就好了。&lt;br&gt;&lt;code&gt;Momentum&lt;/code&gt;&lt;br&gt;论如何优雅的使用Chorme，每天一张好看的壁纸。&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/841/Momentum.webp&quot;&gt;&lt;br&gt;&lt;code&gt;Pocket&lt;/code&gt;&lt;br&gt;稍后阅读，手机端扫货电脑端整理效果更佳。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
  </entry>
  
  <entry>
    <title>STL中容器的构造函数</title>
    <link href="https://imzlp.com/posts/42105/"/>
    <id>https://imzlp.com/posts/42105/</id>
    <published>2015-08-18T12:44:55.000Z</published>
    <updated>2015-08-18T12:44:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/strong&gt;:此文档中所有的初始化皆依据以下容器&lt;/p&gt;
&lt;figure class=&quot;highlight cc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建vector&amp;lt;int&amp;gt;容器test,并为其赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	test.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>两个迭代器初始化容器出现浮点数舍入</title>
    <link href="https://imzlp.com/posts/15409/"/>
    <id>https://imzlp.com/posts/15409/</id>
    <published>2015-08-18T12:39:17.000Z</published>
    <updated>2015-08-18T12:39:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在整理笔记的时候发现了个奇怪的问题：&lt;br&gt;&lt;img src=&quot;https://img.imzlp.com/imgs/zlp/blog/posts/15409/1.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>创业维艰·如何完成比难更难的事</title>
    <link href="https://imzlp.com/posts/39435/"/>
    <id>https://imzlp.com/posts/39435/</id>
    <published>2015-08-18T11:15:13.000Z</published>
    <updated>2015-08-18T11:15:13.000Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>顺序容器与关联容器</title>
    <link href="https://imzlp.com/posts/33878/"/>
    <id>https://imzlp.com/posts/33878/</id>
    <published>2015-02-18T13:26:31.000Z</published>
    <updated>2015-02-18T13:26:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ STL中的顺序容器和关联容器概念和用法整理。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++的基础语法整理</title>
    <link href="https://imzlp.com/posts/42362/"/>
    <id>https://imzlp.com/posts/42362/</id>
    <published>2015-01-20T11:50:59.000Z</published>
    <updated>2015-01-20T11:50:59.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++的基本语法概念整理。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C/C++速查表</title>
    <link href="https://imzlp.com/posts/14660/"/>
    <id>https://imzlp.com/posts/14660/</id>
    <published>2015-01-15T23:56:13.000Z</published>
    <updated>2015-01-15T23:56:13.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;整理的一份C/C++的速查表，平时整理下放到这里来，供方便查询。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="语言" scheme="https://imzlp.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>写点自己的感悟，我的软件专业</title>
    <link href="https://imzlp.com/posts/44216/"/>
    <id>https://imzlp.com/posts/44216/</id>
    <published>2015-01-04T22:32:01.000Z</published>
    <updated>2015-01-04T22:32:01.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文是之前发表在我校的一个帖子，涉及自己以往学习编程的一些经历和看法，为软件专业的学弟学妹的科普解惑之用，最近被挖出来，我都快忘了，顺便整理一下，在此贴出。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用Github来管理博客源文件</title>
    <link href="https://imzlp.com/posts/55550/"/>
    <id>https://imzlp.com/posts/55550/</id>
    <published>2014-11-20T23:52:01.000Z</published>
    <updated>2014-11-20T23:52:01.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;将博客的源文件(非hexo生成的文件)托管到Github上，方便同步和控制版本。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages+Hexo博客搭建</title>
    <link href="https://imzlp.com/posts/58952/"/>
    <id>https://imzlp.com/posts/58952/</id>
    <published>2014-11-18T11:11:11.000Z</published>
    <updated>2014-11-18T11:11:11.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前使用博客园，总觉得不爽，也试过自己搭建博客。&lt;br&gt;wordpress太臃肿，其他的功能不强大(界面不好看)，仔细想来想去还是用Github Pages+Hexo搭建一个静态blog吧，专注于写作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;截至到2021.03.23，我已经持续用Hexo部署博客快要有六年的时间了，六年间写了一百多篇文章，使用Hexo部署的方式也经过了很多变化，写博客也逐渐变成了一种习惯。依稀记得在大学的某一天，我想要自己搭建一个博客，于是折腾了一天写了这篇文章，本站的历史就从那里开始了，希望我能继续用Hexo写到十年、二十年！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
  </entry>
  
</feed>
