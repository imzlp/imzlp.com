<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="“指向类成员的指针(Pointers to members)”，是一种在C++不常用的特性，但是这里使用术语“指针”略有不妥，因为它们并不包含地址，行为也不像指针。本篇文章会通过LLVM-IR来分析clang中对于“指向类成员的指针”的实现方式，以及穿插C++14标准内定义的相关内容和涉及到的LLVM-IR的语法。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++中指向类成员的指针并非指针">
<meta property="og:url" content="https://imzlp.com/posts/27615/index.html">
<meta property="og:site_name" content="循迹研究室">
<meta property="og:description" content="“指向类成员的指针(Pointers to members)”，是一种在C++不常用的特性，但是这里使用术语“指针”略有不妥，因为它们并不包含地址，行为也不像指针。本篇文章会通过LLVM-IR来分析clang中对于“指向类成员的指针”的实现方式，以及穿插C++14标准内定义的相关内容和涉及到的LLVM-IR的语法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp">
<meta property="article:published_time" content="2017-04-29T21:28:17.000Z">
<meta property="article:modified_time" content="2019-04-22T00:38:56.000Z">
<meta property="article:author" content="查利鹏">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="技术笔记">
<meta property="article:tag" content="编程笔记">
<meta property="article:tag" content="C++标准">
<meta property="article:tag" content="中间代码">
<meta property="article:tag" content="LLVM-IR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp">

<link rel="canonical" href="https://imzlp.com/posts/27615/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++中指向类成员的指针并非指针 | 循迹研究室</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="循迹研究室" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">循迹研究室</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>笔记</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>随笔</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>资源</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>友链</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>展示柜</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>站点日志</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>开源项目</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>虚幻知识库</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>站内搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='aW16bHAuY29t';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"
  >
    <link itemprop="mainEntityOfPage" href="https://imzlp.com/posts/27615/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="查利鹏">
      <meta itemprop="description" content="唯有热爱可抵岁月漫长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循迹研究室">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++中指向类成员的指针并非指针<a href="https://github.com/imzlp/blog-md/blob/master/_posts/2017-04-29-27615.md" class="post-edit-link" title="编辑" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-29 21:28 21:28:17:28" itemprop="dateCreated datePublished" datetime="2017-04-29T21:28:17+00:00">2017-04-29 21:28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-22 00:38 00:38:56:38" itemprop="dateModified" datetime="2019-04-22T00:38:56+00:00">2019-04-22 00:38</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/posts/27615/" class="post-meta-item leancloud_visitors" data-flag-title="C++中指向类成员的指针并非指针" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>“指向类成员的指针(Pointers to members)”，是一种在C++不常用的特性，但是这里使用术语“指针”略有不妥，因为它们并不包含地址，行为也不像指针。<br>本篇文章会通过LLVM-IR来分析clang中对于“指向类成员的指针”的实现方式，以及穿插C++14标准内定义的相关内容和涉及到的LLVM-IR的语法。</p>
<span id="more"></span>
<p>首先，C++标准中对于“指向类成员的指针”应该如何实现并没有要求，同样是依赖于编译器的实现。但是标准指明了“指向成员的指针”是明显区别于普通指针的。</p>
<blockquote>
<p>The type “pointer to member” is distinct from the type “pointer”, that is, a pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer declarator syntax. There is no “reference-to-member” type in C++.</p>
</blockquote>
<p>对于普通的指针而言，其包含一个地址，可以对其进行解引用来间接访问所指向的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> *xp=&amp;x;</span><br><span class="line">*xp=<span class="number">456</span>;</span><br></pre></td></tr></table></figure>
<p>但是一个指向成员的指针并不指向某一个具体对象的内存地址。它指向的是一个类的特定成员，而不是指定某一个特定对象的成员。<br>下面我们从编译器Clang的实现来分析一下“指向成员的指针”究竟是什么东西。假定我们具有以下类类型：</p>
<h2 id="指向类数据成员的指针"><a href="#指向类数据成员的指针" class="headerlink" title="指向类数据成员的指针"></a>指向类数据成员的指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">double</span> y=<span class="number">0.0</span>,<span class="type">char</span> z=<span class="string">&#x27;\0&#x27;</span>):a&#123;x&#125;,b&#123;y&#125;,c&#123;z&#125;&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;void A::func()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们通过以下代码来创建一个“指向类成员的指针”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-initielizer</span></span><br><span class="line"><span class="type">int</span> A::*ap;</span><br><span class="line"><span class="type">double</span> A::*bp;</span><br><span class="line"><span class="type">char</span> A::*cp;</span><br></pre></td></tr></table></figure>
<p>以上是并没有初始化的版本，再写一份具有初始化的版本，稍后通过LLVM-IR的对比来看“指向类数据成员的指针”究竟被初始化为了什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initializer</span></span><br><span class="line"><span class="type">int</span> A::*ap=&amp;A::a;</span><br><span class="line"><span class="type">double</span> A::*bp=&amp;A::b;</span><br><span class="line"><span class="type">char</span> A::*cp=&amp;A::c;</span><br></pre></td></tr></table></figure>
<p>通过diff可以看到两者LLVM-IR代码的区别：<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp"><br>可以看到，具有初始化的并非是将某种地址存储到“指向类数据成员的指针”中，而其实际上是一种整数类型。<br>而clang这里实现的，恰好他们均等于该数据成员各自在类中的偏移值，关于类内偏移值的内容详情可看我的另一篇文章：<a href="https://imzlp.com/posts/61962/">结构体成员内存对齐问题</a>。<br>这意味着“指向类成员的指针”的实现方式是获取该类成员在类中的偏移值，这也同样印证了“指向类成员的指针”不可以单独访问(依赖于某一特定对象)的原因——它只是偏移值，需要通过特定的对象来访问该对象此偏移值处的子对象。<br>我们来尝试通过一个类对象和“指向数据成员的指针”来访问特定的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A x&#123;<span class="number">123</span>&#125;;</span><br><span class="line"><span class="type">int</span> A::*ap=&amp;A::a;</span><br><span class="line">x.*ap=<span class="number">888</span>;</span><br></pre></td></tr></table></figure>
<p>依然查看其的LLVM-IR代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建A类对象x并调用A的构造函数</span><br><span class="line">%2 = alloca %struct.A, align 8</span><br><span class="line">call void @_ZN1AC2Eidc(%struct.A* %2, i32 123, double 0.000000e+00, i8 0)</span><br><span class="line"># 初始化“指向类的数据成员的指针”ap(获取其偏移值)</span><br><span class="line">%3 = alloca i64, align 8</span><br><span class="line">store i64 0, i64* %3, align 8</span><br><span class="line"></span><br><span class="line">%4 = load i64, i64* %3, align 8</span><br><span class="line">%5 = bitcast %struct.A* %2 to i8*</span><br><span class="line"># 通过特定对象的指针和偏移量来访问类的子对象(数据成员)</span><br><span class="line">%6 = getelementptr inbounds i8, i8* %5, i64 %4</span><br><span class="line">%7 = bitcast i8* %6 to i32*</span><br><span class="line">store i32 888, i32* %7, align 4</span><br></pre></td></tr></table></figure>
<p>可以在<a target="_blank" rel="noopener" href="http://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a>查看LLVM-IR的语法。<br>这里比较繁琐的部分为<code>getelementptr inbounds</code>的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Syntax</span><br><span class="line">&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;* </span><br><span class="line">&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;* </span><br><span class="line">&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>The <code>getelementptr</code> instruction is used to get the address of a subelement of an aggregate data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses.</p>
</blockquote>
<ul>
<li>The first argument is always a type used as the basis for the calculations.</li>
<li>The second argument is always a pointer or a vector of pointers, and is the base address to start from.</li>
<li>The remaining arguments are indices that indicate which of the elements of the aggregate object are indexed.</li>
</ul>
<blockquote>
<p>The interpretation of each index is dependent on the type being indexed into. The first index always indexes the pointer value given as the first argument, the second index indexes a value of the type pointed to (not necessarily the value directly pointed to, since the first index can be non-zero), etc. The first type indexed into must be a pointer value, subsequent types can be arrays, vectors, and structs. Note that subsequent types being indexed into can never be pointers, since that would require loading the pointer before continuing calculation.</p>
</blockquote>
<p>更多LLVM-IR的东西不再赘述，言归正传继续来分析“指向数据成员的指针”。</p>
<p>在我们对一个“指向类内数据成员的指针”赋予初始值，实际上是获得了该数据成员在类内的偏移量。除非是对一个类内的static数据成员进行<code>&amp;</code>操作，否则不会带来一个实际的地址，而是一个偏移量。<br>这也应该是C++标准规定“指向类成员的指针”不能指向static成员：</p>
<blockquote>
<p>**[ISO/IEC 14882:2014]**A pointer to member shall not point to a static member of a class (9.4), a member with reference type, or “cv void.”</p>
</blockquote>
<p>上面已经简单提到了“指向成员的指针”不能单独访问——需要依赖于某一特定的类A对象。<br>这是由于“指向成员的指针”只是该成员在类内的偏移量，为了访问位于那个偏移量的子对象(数据成员)，则我们需要该类(A)的一个对象的地址。<br>当我们使用<code>.*</code>或者<code>-&gt;*</code>通过一个类对象或者类指针来访问一个偏移量时，执行的即是上面列出的LLVM-IR代码里<code>getelementptr inbounds</code>部分，通过调用的对象的地址和偏移量计算出位于该偏移量的数据成员的地址。</p>
<h2 id="指向类成员函数的指针"><a href="#指向类成员函数的指针" class="headerlink" title="指向类成员函数的指针"></a>指向类成员函数的指针</h2><p>上面的部分写到了“指向类数据成员的指针”，以及其在clang中的实现方式，而“指向类成员函数的指针”与“指向类数据成员的指针”略有不同。<br>一个指向成员函数指针的实现自身必须存储一些信息，比如它所指向的函数是虚函数还是非虚函数，如何找到适当的虚函数表指针，所以通常指向类成员函数的指针的实现为一个小型的结构来存储这些关键的信息。</p>
<blockquote>
<p>注意：并没有什么指向虚函数的指针，虚函数是函数本身的属性，而不是指向类成员函数的属性。</p>
</blockquote>
<p>同样按照上一部分相同的逻辑：首先先创建一个“指向类成员函数的指针”，不同于普通的函数指针，对于“指向类成员函数的指针”初始化必须对类内的成员函数使用取地址符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*funcp)();</span><br></pre></td></tr></table></figure>
<p>其LLVM-IR代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看到，clang中对于<strong>指向类成员函数的指针</strong>不同于<strong>指向类数据成员的指针</strong>，“指向类成员函数的指针”是具有两个<code>i64</code>对象的结构。<br>尝试对其进行初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*funcp)()=&amp;A::func;</span><br></pre></td></tr></table></figure>
<p>然后再查看其LLVM-IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里是把A::func的函数地址(接收一个类A的指针并没有返回)转换为了i64之后存入到了该成员指针的结构中，第二个参数是对this指针的偏移修饰，因为在类的继承层次里，数据成员的位置并不是绝对的，而是相对于基类的相对位置，该偏移可以使用<code>ptrdiff_t</code>类型来表示，可以看如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;A::func&quot;</span>&lt;&lt;<span class="string">&quot;,this ptr address is &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> pad16[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;B::Bar&quot;</span>&lt;&lt;<span class="string">&quot;,this ptr address is &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> pad8[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C cobj;</span><br><span class="line">	<span class="built_in">void</span>(C::*Afunc)()=&amp;C::func;</span><br><span class="line">	<span class="built_in">void</span>(C::*Bbar)()=&amp;C::bar;</span><br><span class="line"></span><br><span class="line">	(cobj.*Afunc)();</span><br><span class="line">	(cobj.*Bbar)();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">A::func,<span class="keyword">this</span> ptr address is <span class="number">0x61fe30</span></span><br><span class="line">B::Bar,<span class="keyword">this</span> ptr address is <span class="number">0x61fe40</span></span><br></pre></td></tr></table></figure>

<p>可以看到两个this地址的差值就是A类对象的内存布局大小，再来看一下其对成员函数指针赋值部分的IR代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.C, align <span class="number">1</span></span><br><span class="line">  %<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">  store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">class</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">class</span>.B*)* @_ZN1B3barEv to i64), i64 <span class="number">16</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是分配了两个成员函数的结构——两个int64，该结构的第一个成员用来存储成员函数函数指针，第二个用来存储this指针的偏移。<br>得到这个规律，就可以直接萃取出成员函数指针的真实函数指针地址了(取出其结构的第一个元素)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;HellowWorld,&quot;</span>&lt;&lt;<span class="string">&quot;ival = &quot;</span>&lt;&lt;ival&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="built_in">void</span>(A::*Afunc)(<span class="type">int</span>);</span><br><span class="line">		<span class="built_in">void</span>(*realAfunc[<span class="number">2</span>])(A*,<span class="type">int</span>);</span><br><span class="line">	&#125;AfuncAddr;</span><br><span class="line">	AfuncAddr.Afunc=&amp;A::func;</span><br><span class="line"></span><br><span class="line">	AfuncAddr.realAfunc[<span class="number">0</span>](<span class="literal">NULL</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">HellowWorld,ival = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>不过，使用这种方式是<strong>未定义行为</strong>，因为我传入的this是<code>NULL</code>而且该成员函数中,如果有依赖this的操作(比如多态、访问成员变量)，会崩掉。</p>
<p>综上，当我们在使用成员函数指针的时候需要用一个类A对象对其进行调用(因为<code>.*</code>以及<code>-&gt;*</code>的优先级低于<code>()</code>，所以对<code>x.*funcp</code>要加上括号)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">x</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (A::*funcp)()=&amp;A::func;</span><br><span class="line">(x.*funcp)();</span><br></pre></td></tr></table></figure>
<p>其LLVM-IR代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">2</span> = alloca %<span class="keyword">struct</span>.A, align <span class="number">8</span></span><br><span class="line">call <span class="type">void</span> @_ZN1AC2Eidc(%<span class="keyword">struct</span>.A* %<span class="number">2</span>, i3 <span class="number">123</span>, <span class="type">double</span> <span class="number">0.000000e+00</span>, i8 <span class="number">0</span>)</span><br><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line"># 将成员函数地址存放到分配的空间中(%<span class="number">3</span>)</span><br><span class="line">store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line"></span><br><span class="line">%<span class="number">4</span> = load &#123; i64, i64 &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line"># 取出结构中的第二个i64数据，并放到%<span class="number">5</span>中</span><br><span class="line">%<span class="number">5</span> = extractvalue &#123; i64, i64 &#125; %<span class="number">4</span>, <span class="number">1</span></span><br><span class="line">%<span class="number">6</span> = bitcast %<span class="keyword">struct</span>.A* %<span class="number">2</span> to i8*</span><br><span class="line"># 访问该对象偏移的第%<span class="number">5</span>个对象</span><br><span class="line">%<span class="number">7</span> = getelementptr inbounds i8, i8* %<span class="number">6</span>, i64 %<span class="number">5</span></span><br><span class="line">%<span class="number">8</span> = bitcast i8* %<span class="number">7</span> to %<span class="keyword">struct</span>.A*</span><br><span class="line"># 取出结构中的第一个i64数据，并放到%<span class="number">9</span>中</span><br><span class="line">%<span class="number">9</span> = extractvalue &#123; i64, i64 &#125; %<span class="number">4</span>, <span class="number">0</span></span><br><span class="line"># 对%<span class="number">9</span>与<span class="number">1</span>执行位与(&amp;)运算</span><br><span class="line">%<span class="number">10</span> = <span class="keyword">and</span> i64 %<span class="number">9</span>, <span class="number">1</span></span><br><span class="line"># 判断%<span class="number">10</span>是否不等于<span class="number">0</span>(ne为<span class="keyword">not</span> equal)</span><br><span class="line">%<span class="number">11</span> = icmp ne i64 %<span class="number">10</span>, <span class="number">0</span></span><br><span class="line"># 根据上面判断的结果执行不同的分支</span><br><span class="line">br i1 %<span class="number">11</span>, label %<span class="number">12</span>, label %<span class="number">19</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">12</span>:                                     ; preds = %<span class="number">0</span></span><br><span class="line">%<span class="number">13</span> = bitcast %<span class="keyword">struct</span>.A* %<span class="number">8</span> to i8**</span><br><span class="line">%<span class="number">14</span> = load i8*, i8** %<span class="number">13</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">15</span> = sub i64 %<span class="number">9</span>, <span class="number">1</span></span><br><span class="line">%<span class="number">16</span> = getelementptr i8, i8* %<span class="number">14</span>, i64 %<span class="number">15</span></span><br><span class="line">%<span class="number">17</span> = bitcast i8* %<span class="number">16</span> to <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)**</span><br><span class="line">%<span class="number">18</span> = load <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)*, <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)** %<span class="number">17</span>, align <span class="number">8</span></span><br><span class="line">br label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">19</span>:                                     ; preds = %<span class="number">0</span></span><br><span class="line">%<span class="number">20</span> = inttoptr i64 %<span class="number">9</span> to <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)*</span><br><span class="line">br label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">21</span>:                                     ; preds = %<span class="number">19</span>, %<span class="number">12</span></span><br><span class="line">%<span class="number">22</span> = phi <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* [ %<span class="number">18</span>, %<span class="number">12</span> ], [ %<span class="number">20</span>, %<span class="number">19</span> ]</span><br><span class="line"></span><br><span class="line"># 通过类指针来调用成员函数(类似于类内成员函数具有<span class="keyword">this</span>指针)</span><br><span class="line"># 成员函数指针必须需要对象或指针调用的原因就在于需要在这里补上单独的成员函数指针所需要的<span class="keyword">this</span>指针</span><br><span class="line">call <span class="type">void</span> %<span class="number">22</span>(%<span class="keyword">struct</span>.A* %<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>而且，指向成员函数的指针表现出一种逆变性：存在指向基类成员函数指针到指向派生类成员函数指针的转换，反之则不行。<br>如我们具有以下类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;base::func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;A::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以从指向基类成员函数指针到指向派生类成员函数指针的转换(具有多态性)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*AfuncP)()=&amp;base::func;</span><br><span class="line">A aobj;</span><br><span class="line">(aobj.*AfuncP)(); <span class="comment">// output:A::func()</span></span><br></pre></td></tr></table></figure>
<p>而反之则是编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: cannot initialize a variable of type &#x27;void (base::*)()&#x27; with an rvalue of type &#x27;void (A::*)()&#x27;:different classes (&#x27;base&#x27; vs &#x27;A&#x27;)</span></span><br><span class="line"><span class="built_in">void</span> (base::*baseFuncp)()=&amp;A::func;</span><br></pre></td></tr></table></figure>

<h3 id="与STL的组合"><a href="#与STL的组合" class="headerlink" title="与STL的组合"></a>与STL的组合</h3><p>指向成员函数的指针可以通过标准库的<code>mem_func</code>适配器实现类似于函数对象(仿函数)，使其可以应用在相关算法中(若容器中是指针用<code>std::mem_fun</code>，若是引用则用<code>std::mem_fun_ref</code>)。<br>比如：对容器中存储的所有对象执行其成员函数的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;C::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;C&gt; x;</span><br><span class="line">	x.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	std::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),std::<span class="built_in">mem_fun_ref</span>(&amp;C::func));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>来看一下<code>std::mem_fun</code>的一个实现(SGISTL，有些老了)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_ref_t</span> : <span class="keyword">public</span> unary_function&lt;_Tp,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(_Ret (_Tp::*__pf)())</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">  <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp&amp; __r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Ret (_Tp::*_M_f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_ref_t</span>&lt;_Ret,_Tp&gt; <span class="title">mem_fun_ref</span><span class="params">(_Ret (_Tp::*__f)())</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">mem_fun_ref_t</span>&lt;_Ret,_Tp&gt;(__f); &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，SGISTL中实现的是，通过<code>std::mem_fun</code>创建一个包裹该成员函数的函数对象，该函数对象接收一个传入成员函数类的实参(指针或引用，这里只列出了<code>std::mem_fun_ref</code>的实现，而<code>std::mem_fun</code>则大同小异)，通过该参数来调用成员函数指针。</p>
<p>通过上面的SGISTL实现可以看到，它有很大的局限性——只能调用无参的成员函数(这个要依赖于不同的STL实现)。<br>如果想要调用有参的成员函数呢？可以使用<code>std::bind</code>！不同于C++11之前的<code>std::bind1st</code>和<code>std::bind2st</code>那么蹩脚，C++11中的<code>std::bind</code>不限定参数个数才是真神器！<br>来将上面的类C稍微改动一下，使其接收一个参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">const</span> <span class="type">int</span>&amp; x):ival&#123;x&#125;&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; iArg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ival+=iArg;</span><br><span class="line">		std::cout&lt;&lt;<span class="keyword">this</span>-&gt;ival&lt;&lt;std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ival;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果此时再使用<code>std::mem_fun</code>来适配会提示<strong>没有匹配的函数</strong>，我们可以使用<code>std::bind</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;C&gt; c&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),std::<span class="built_in">bind</span>(&amp;C::func,_1,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>因为成员函数指针需要通过类指针或者类对象访问，所以要将其第一个参数传递给bind绑定的成员函数指针。<br>前面提到<code>for_each</code></p>
<h3 id="从成员函数指针到普通函数指针的转换"><a href="#从成员函数指针到普通函数指针的转换" class="headerlink" title="从成员函数指针到普通函数指针的转换"></a>从成员函数指针到普通函数指针的转换</h3><p>通过上面可以了解到，成员函数指针是一个结构，其第一个元素存储着成员函数的函数指针，第二个元素存储着对this指针的偏移。<br>它们两个构成了成员函数指针，其实你肯定也想到了，类的成员函数就是带有this指针的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其成员函数func的函数指针则是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(*)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br></pre></td></tr></table></figure>
<p>那么，如果我们想要把一个成员函数指针转换为函数指针的形式，只需要取成员函数指针结构的第一个元素即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*)</span></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A::func\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gfunc</span><span class="params">(<span class="type">void</span>(*pfunc)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A obj;</span><br><span class="line">	<span class="comment">// (obj.*pfunc)();</span></span><br><span class="line">	<span class="built_in">pfunc</span>(&amp;obj,<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(A::*func)(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br><span class="line">	<span class="built_in">void</span>(*pure_func)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	U unionObj;</span><br><span class="line">	unionObj.func=&amp;A::func;</span><br><span class="line">	<span class="built_in">gfunc</span>(unionObj.pure_func);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以从成员函数指针到普通的函数指针赋值了。直接转换是不允许的(看编译器)。用union可以骗过编译器，这个方法比较通用。</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p><strong>2017.05.11</strong></p>
<ul>
<li>增加标准库组合使用指向成员函数指针的内容</li>
</ul>
<p><strong>2018.09.25</strong></p>
<ul>
<li>补充成员函数指针的结构初始化部分内容</li>
</ul>
<p><strong>2018.11.06</strong></p>
<ul>
<li>增加从成员函数指针到普通函数指针的转换</li>
</ul>
<p>*<em>2019.04.22</em></p>
<ul>
<li>增加从成员函数指针结构中萃取出原始函数指针</li>
</ul>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                全文完，若有不足之处请评论指正。
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>微信扫描二维码，关注我的公众号。</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>本文标题:</span><a href="/posts/27615/" target="_blank">C++中指向类成员的指针并非指针</a><br/>
             <span>文章作者:</span><a href="/about" target="_blank" title="查看 查利鹏 的资料">查利鹏</a><br/>
             <span>发布时间:</span>2017年04月29日 21时28分<br/>
             
              <span>更新时间:</span>2019年04月22日 00时38分<br/>
             
             <span>本文字数:</span><span class="page-count">本文一共有4.4k字</span><br/>
             
             <span>原始链接:</span><a href="/posts/27615/" target="_blank" title="C++中指向类成员的指针并非指针">https://imzlp.com/posts/27615/</a>
             <span class="copy-path" data-clipboard-text="原文链接: https://imzlp.com/posts/27615/ 作者: 查利鹏" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>文章禁止全文转载，摘要转发请保留原文链接及作者信息，谢谢！</span>
          </div>
        
    
        
  <div class="reward-container">
    <div>您的捐赠将鼓励我继续创作！</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      打赏
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="查利鹏 微信支付">
          <p>微信支付</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" rel="tag"># 技术笔记</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"># 编程笔记</a>
              <a href="/tags/C-%E6%A0%87%E5%87%86/" rel="tag"># C++标准</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/" rel="tag"># 中间代码</a>
              <a href="/tags/LLVM-IR/" rel="tag"># LLVM-IR</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/10380/" rel="prev" title="函数模板的特化和重载">
      <i class="fa fa-chevron-left"></i> 函数模板的特化和重载
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/5392/" rel="next" title="为什么需要extern "C"?">
      为什么需要extern "C"? <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">指向类数据成员的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">2.</span> <span class="nav-text">指向类成员函数的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8ESTL%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">2.1.</span> <span class="nav-text">与STL的组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%88%B0%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">从成员函数指针到普通函数指针的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97"><span class="nav-number">3.</span> <span class="nav-text">更新日志</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="查利鹏"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">查利鹏</p>
  <div class="site-description" itemprop="description">唯有热爱可抵岁月漫长。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021027036号 </a>
      <img src="/images/beian_logo.webp" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502007298" rel="noopener" target="_blank">粤公网安备44030502007298号 </a>
  </div>

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">查利鹏</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">747k</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imzlp.com/posts/27615/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "留下点什么吧~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
