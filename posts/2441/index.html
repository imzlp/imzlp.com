<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="从C语言过来觉得C++03和OO的特性简直不能更爽，最近着重看了一下C++11的新特性，觉得有好多很棒的语法糖啊！用起来也很爽啊。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11的语法糖">
<meta property="og:url" content="https://imzlp.com/posts/2441/index.html">
<meta property="og:site_name" content="循迹研究室">
<meta property="og:description" content="从C语言过来觉得C++03和OO的特性简直不能更爽，最近着重看了一下C++11的新特性，觉得有好多很棒的语法糖啊！用起来也很爽啊。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/02.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/03.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/04.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/06.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/05.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/07.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/08.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/09.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/10.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/11.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/12.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/13.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/14.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/15.webp">
<meta property="article:published_time" content="2016-05-12T22:30:19.000Z">
<meta property="article:modified_time" content="2016-05-12T22:30:19.000Z">
<meta property="article:author" content="查利鹏">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++11">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp">

<link rel="canonical" href="https://imzlp.com/posts/2441/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++11的语法糖 | 循迹研究室</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="循迹研究室" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">循迹研究室</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>笔记</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>随笔</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>资源</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>友链</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>展示柜</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>站点日志</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>开源项目</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>虚幻知识库</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>站内搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='aW16bHAuY29t';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"
  >
    <link itemprop="mainEntityOfPage" href="https://imzlp.com/posts/2441/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="查利鹏">
      <meta itemprop="description" content="唯有热爱可抵岁月漫长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循迹研究室">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++11的语法糖<a href="https://github.com/imzlp/blog-md/blob/master/_posts/2016-05-12-2441.md" class="post-edit-link" title="编辑" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-12 22:30 22:30:19:30" itemprop="dateCreated datePublished" datetime="2016-05-12T22:30:19+00:00">2016-05-12 22:30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/posts/2441/" class="post-meta-item leancloud_visitors" data-flag-title="C++11的语法糖" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>57 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>从C语言过来觉得C++03和OO的特性简直不能更爽，最近着重看了一下C++11的新特性，觉得有好多很棒的语法糖啊！用起来也很爽啊。</p>
<span id="more"></span>

<h3 id="列表值序列"><a href="#列表值序列" class="headerlink" title="列表值序列"></a>列表值序列</h3><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>作为C++11新标准的一部分，**列表初始化(用花括号来初始化变量)**得到了全面应用。这种方式用起来确实是非常非常舒服的，比如vector模板想要初始化，要么使用一个容器初始化它，要么将其初始化为N个元素的值()。</p>
<p>列表初始化能够防止<code>窄化转换</code>，其含义是：</p>
<ul>
<li>如果一个整型存不下另一种整型的值，则后者不会转换为前者。例如char可以转换到int，但int不能转换到char</li>
<li>如果一个浮点型存不下另一个浮点型的值，则后者不会转换为前者。例如float可以转换为double，但double不能转换到float</li>
<li>浮点值不能转换为整型值</li>
<li>整型值不能转换为浮点值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++03标准，容器的构造函数</span></span><br><span class="line">C&lt;T&gt; C; 	<span class="comment">//创建一个空的容器，调用默认构造函数</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(c2)</span></span>;	<span class="comment">//创建一个容器的副本，c和c2必须具有相同的容器类型</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b,e)</span></span>;	<span class="comment">//创建容器，接收两个迭代器参数，用于将另外一个容器的一部分(b,e迭代器标示的范围)初始化c</span></span><br><span class="line"><span class="comment">// 以下构造方式只适用于顺序容器</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(n,t)</span></span>;	<span class="comment">//创建n个元素且值均为t的容器，值t必须为容器类型c的元素类型的值，或是可转换为该类型的值</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(n)</span></span>;		<span class="comment">//创建n个值初始化元素的容器。</span></span><br></pre></td></tr></table></figure>

<p>C++11标准支持的<strong>列表初始化</strong>方式：</p>
<p>列表初始化的形式为<code>C c&#123;element-List&#125;;</code>或者<code>C c=&#123;element-List&#125;;</code></p>
<p><strong>注意：一定要使用花括号，使用圆括号来进行初始化是另一种完全不同的含义。</strong></p>
<p>当我们使用<code>auto</code>关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是<code>&#123;&#125;</code>列表，则推断到的数据类型肯定不是我们想要的结果。</p>
<blockquote>
<p>当使用auto时，不要使用列表初始化，在auto中=是更好的选择，除非你明确知道得到的是你想要的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> z1&#123;<span class="number">99</span>&#125;;	<span class="comment">// z1 的类型是initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> z2=<span class="number">99</span>;	<span class="comment">// z2 的类型是int</span></span><br></pre></td></tr></table></figure>
<p>另外，当我们构建某些类的对象时，可能有两种形式：</p>
<ol>
<li>提供一组初始值</li>
<li>提供几个实参</li>
</ol>
<p>注意区分下面两个表达式的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一定要完全区分这两种含义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intVec_1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//intVec_1有10个元素，每个值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intVec_2&#123;<span class="number">10</span>&#125;;<span class="comment">//intVec_2有一个元素，其值为10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 容器的列表初始化</span></span><br><span class="line">vector&lt;string&gt; strvec&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">list&lt;string&gt; strlist=&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码编译时如果不加<code>std=c++11</code>会产生四个错误:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp"></p>
<p>使用C++11的标准就要加上<code>std=c++11</code>，在编译就不会出错了。</p>
<p>运行并输出上面初始化的对象和容器：</p>
<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/02.webp"></p>
<h4 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h4><p>C++新标准规定使用花括号括起来的初始值列表作为赋值运算语句的右侧运算对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; intVec;</span><br><span class="line">intVec=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>列表赋值语句不能用于窄化转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="comment">// error: type &#x27;double&#x27; cannot be narrowed to &#x27;int&#x27; in initializer list</span></span><br><span class="line">k=&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="comment">// 值初始化ivalInit</span></span><br><span class="line"><span class="type">int</span> ivalInit=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果左侧运算对象是内置类型，那么初始值列表最多只能包含最多只能包含一个值，而且该值即使转换的话其所占空间也不应大于目标类型空间。类型转换还是参照<a href="https://imzlp.com/2016/05/04/type-convert-in-cpp/">详细分析下C++中的类型转换</a> </p>
<p>无论左侧对象的类型是什么，初始值列表都可以为空。此时编译器创建一个值初始化的临时变量并将其赋值给左侧运算对象。</p>
<p>一个由<code>&#123;&#125;</code>限定的列表可以作为下述形参的实参：</p>
<ol>
<li>类型<code>std::initializer_list&lt;T&gt;</code>，其中列表的值能隐式地转换成T</li>
<li>能用列表中的值初始化的类型</li>
<li>T类型数组的引用，其中列表的值能隐式地转换成T</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(initializer_list&lt;T&gt;;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> S&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> a;</span></span></span><br><span class="line"><span class="params"><span class="function">  string s;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> f2(S);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="type">int</span> N&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> f3(T (&amp;r)[N]);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> f4(<span class="type">int</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> g()</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  f1(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);  <span class="comment">// T是int,initializer_list大小是4</span></span></span></span><br><span class="line"><span class="params"><span class="function">  f2(&#123;<span class="number">1</span>,<span class="string">&quot;MKS&quot;</span>&#125;);  <span class="comment">// f2(S&#123;1,&quot;MKS&quot;&#125;);</span></span></span></span><br><span class="line"><span class="params"><span class="function">  f3(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);  <span class="comment">// T是int，N是4</span></span></span></span><br><span class="line"><span class="params"><span class="function">  f4(&#123;<span class="number">1</span>&#125;);  <span class="comment">// f(int(1))</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>如果存在歧义性，则<code>initializer_list</code>参数的函数被优先考虑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(initializer_list&lt;T&gt;;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> f(<span class="type">int</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> g()</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  f1(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);  <span class="comment">// T是int,initializer_list大小是4</span></span></span></span><br><span class="line"><span class="params"><span class="function">  f4(&#123;<span class="number">1</span>&#125;);  <span class="comment">// T是int,initializer_list大小是1</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>之所以优先选择具有<code>initializer_list</code>参数的函数，是因为如果根据列表的元素数量选择函数的话会让选择的过程显得非常混论。在重载解析额时候，很难把所有可能引起混淆的形式都排除干净，但是当遇到{}列表的参数时给<code>initializer_list</code>参数最高的优先级能最大限度地避免混淆。</p>
<h4 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h4><p>C++11规定函数可以返回花括号包围的值的列表。</p>
<p>由<code>初始值列表</code>的概念可得，列表为空，对内置类型进行值初始化，否则返回的值由函数的返回类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;X &gt; 0&quot;</span>,<span class="string">&quot;Yes&quot;</span>&#125;;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;X &lt; 0&quot;</span>,<span class="string">&quot;NO&quot;</span>&#125;;</span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="string">&quot;X = 0&quot;</span>,<span class="string">&quot;ZERO&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们调用process可得</span></span><br><span class="line">vector&lt;string&gt; test=<span class="built_in">process</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:test)</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果为：<code>X &gt; 0,Yes</code></p>
<h4 id="关联容器的列表初始化"><a href="#关联容器的列表初始化" class="headerlink" title="关联容器的列表初始化"></a>关联容器的列表初始化</h4><p>当定义一个map时，必须既指明关键字类型又指明值类型；而定义一个set时，只需指明关键字类型，因为set中没有值。</p>
<p>每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。</p>
<p>在新标准下，我们可以对关联容器进行值初始化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空容器</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt;  word_count;</span><br><span class="line"><span class="comment">// 列表初始化</span></span><br><span class="line">set&lt;string&gt; exclude=&#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;but&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;or&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;The&quot;</span>,<span class="string">&quot;But&quot;</span>,<span class="string">&quot;And&quot;</span>,<span class="string">&quot;Or,&quot;</span>An<span class="string">&quot;,&quot;</span>a<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">// 三个元素；authors将姓映射为名</span></span><br><span class="line"><span class="string">map&lt;string,string&gt; authors=&#123;&#123;&quot;</span>Joyce<span class="string">&quot;,&quot;</span>James<span class="string">&quot;&#125;,&#123;&quot;</span>Austen<span class="string">&quot;,&quot;</span>Jane<span class="string">&quot;&#125;,&#123;&quot;</span>Dickens<span class="string">&quot;,&quot;</span>Charles<span class="string">&quot;&#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="列表初始化pair的返回类型"><a href="#列表初始化pair的返回类型" class="headerlink" title="列表初始化pair的返回类型"></a>列表初始化pair的返回类型</h4><p>想象有一个函数需要返回pari。在新标准(C++11)下，我们可以对返回值进行列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 处理v</span></span><br><span class="line">  	<span class="keyword">if</span>(!v.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      	<span class="comment">//back成员函数返回该容器最后一个元素的引用，front则返回第一个</span></span><br><span class="line">  		<span class="keyword">return</span> &#123;b.<span class="built_in">back</span>(),v.back.<span class="built_in">size</span>()&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="comment">// 隐式构造返回值</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若v不为空，我们返回一个有v中最后一个string及其大小组成的pair。否则，隐式构造一个空的pair并返回它。</p>
<p>在较早的C++版本中，不允许花括号包围的初始化器来返回pair这种类型的对象，必须显式地构造返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(v.<span class="built_in">back</span>(),v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以使用make_pair来生成pair对象，pair对象额两个类型来自于make_pair的参数</span></span><br><span class="line"><span class="keyword">if</span>(!v.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">make_pair</span>(v.<span class="built_in">back</span>(),v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nullptr常量"><a href="#nullptr常量" class="headerlink" title="nullptr常量"></a>nullptr常量</h3><p>在C++11之前，都是使用字面值0或者NULL来将指针<strong>初始化/赋值</strong>为<strong>空指针</strong>。</p>
<p>其中<strong>NULL</strong>是定义在cstdlib中的预处理器变量，其值为0，当用到一个预处理器变量时，预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。</p>
<p><strong>把int型变量赋值给指针是错误的操作，即使该变量的值恰好为0也不行。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1=<span class="number">0</span>;	<span class="comment">// 将p1初始化为字面值常量0</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="literal">NULL</span>;	<span class="comment">//等价于int *p2=0;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++11标准引入了nullptr字面值常量可以用来将指针初始化为空指针。</p>
<p>nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。</p>
</blockquote>
<p>使用nullptr来初始化指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="literal">nullptr</span>;	<span class="comment">//等价于int *p=0;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：使用未初始化的指针是运行错误的重要原因之一。应该初始化所有的指针，并且将一个指针delete之后应该立即将其置为空指针，否则再对其访问有可能会造成错误(悬垂指针)。</strong></p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><h4 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h4><p><strong>常量表达式(const expression)**是指值不会改并且</strong>在编译过程**就能得到计算结果的表达式。</p>
<p>很显然，<strong>字面值</strong>属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>一个对象或表达式是不是常量表达式<strong>由它的数据类型和初始值</strong>共同决定的。</p>
<p>当constexpr出现在函数定义中时，它的含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。而当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NUM=<span class="number">20</span>; <span class="comment">//MAX_NUM是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=MAX_NUM+<span class="number">1</span>; <span class="comment">//MAX为常量表达式</span></span><br><span class="line"><span class="type">int</span> ival=<span class="number">20</span>; <span class="comment">//ival不是常量表达式，是个变量</span></span><br></pre></td></tr></table></figure>

<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器验证变量的值是否是一个常量表达式。</p>
<p>声明为<code>constexpr</code>的变量必须是一个常量，并且必须用常量表达式初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ival=<span class="number">20</span>; <span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit=ival+<span class="number">1</span>; <span class="comment">//ival+1是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival_2=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> =ival_2;	<span class="comment">//会产生错误，只有当等号右边的值为constexpr时才是一条正确的语句</span></span><br></pre></td></tr></table></figure>

<h4 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a>constexpr指针</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关。</p>
<p>constexpr把它所定义的指针对象置为<strong>顶层const</strong>(指针不可修改，指向对象可修改)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p是一个指向整型常量的指针，指针可修改，指向对象不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// q是一个指向整数的常量指针，指针不可修改，指向对象可修改。</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p><code>constexpr函数(constexpr function)</code>是指能用于常量表达式的函数，函数必须足够简单才能在编译时求值。</p>
<p>定义constexpr函数的方法与其他类似，不过需要遵循几项规定:</p>
<ul>
<li>函数的<strong>返回类型</strong>以及<strong>所有形参</strong>的类型都得是<strong>字面值</strong></li>
<li>函数体中<strong>必须只有一条return语句</strong></li>
<li>没有循环也没有局部变量</li>
<li>constexpr不能有副作用(不能向非局部对象写入内容)</li>
<li>允许递归和条件表达式</li>
</ul>
<p>也就是说constexpr函数应该是一个纯函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> glob;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">bad1</span><span class="params">(<span class="type">int</span> a)</span> <span class="comment">//error : constexpr function cannot be void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  glob = a; <span class="comment">// error : side effect in constexpr function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a&gt;=<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> −a; <span class="comment">//error : if-statement in constexpr function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad3</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>; <span class="comment">// error : local var iable in constexpr function</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;a; +=i) sum +=<span class="built_in">fac</span>(i); <span class="comment">// error : loop in constexpr function</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz=<span class="built_in">new_sz</span>(); <span class="comment">// 正确，sz是一个常量表达式</span></span><br></pre></td></tr></table></figure>

<p>编译器把constexpr函数的调用替换成其结果值。为了能在编译过程随时展开，<code>constexpr函数</code>被隐式地指定为<code>内联函数</code>。</p>
<p><code>constexpr</code>函数体内也可以包含其他的语句，只要这些语句在运行时不执行任何操作就行。</p>
<p>constexpr函数中可以有空语句、类型别名以及using声明。</p>
<p>我们允许constexpr函数的返回值并非一个常量:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果scale接收的参数是一个常量表达式，则scale(const-parameter)也是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>()*xnt;&#125;</span><br></pre></td></tr></table></figure>

<p>当scale的实参常量表达式时，它的返回值是常量表达式，反之则不然。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，scale(2)的返回值是常量表达式,编译器用相应的结果值替换对scale函数的调用</span></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)]; <span class="comment">//错误，scale(i)的返回值不是常量表达式</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>constexpr函数不一定返回常量表达式。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x=<span class="built_in">scale</span>(i); <span class="comment">//错误，参数为i的scale调用返回值不是constexpr</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/03.webp"></p>
<p>constexpr可以返回一个引用或指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>* <span class="title">addr</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; r)</span></span>&#123;<span class="keyword">return</span> &amp;r;&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>但是这违背了constexpr函数作为常量表达式求值要求的初衷。</p>
<p>constexpr函数之外的条件表达式不会再编译时求值，这意味着他可以请求运行时求值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (low&lt;=i&amp;&amp;i&lt;high)?i:<span class="keyword">throw</span> <span class="built_in">out_of_range</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> high=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ival=<span class="built_in">check</span>(<span class="built_in">f</span>(x,y,z));</span><br></pre></td></tr></table></figure>

<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><p>与普通的constexpr函数相比，constexpr构造函数有所区别：只允许简单地执行成员初始化操作。</p>
<p>尽管构造函数不能为const（如果成员函数为const则意味着不能修改类内数据成员的值），但是<code>字面值常量类的构造函数</code>可以使constexpr函数。</p>
<p>一个字面值常量类必须至少提供一个constexpr构造函数，构造函数必须足够简单才能生命成constexpr，其中“简单”的的含义是<strong>它的函数体必须为空且所有成员都是潜在的常量表达式初始化</strong>。</p>
<p>constexpr构造函数可以声明成<code>=default函数</code>(编译器合成默认构造函数)的形式或者是<code>=delete</code>(删除函数)的形式。<strong>否则constexpr构造函数就必须既符合构造函数的要求(意味着不能包含返回语句)，又符合constexpr函数的要求(意味着它能够拥有的唯一可执行语句就是返回语句)。</strong></p>
<p>综上所述，constexpr构造函数体必须是空的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b=<span class="literal">true</span>)</span>:hw(b),io(b),other(b)&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h,<span class="type">bool</span> i,<span class="type">bool</span> o)</span>:hw(h),io(i),other(o)&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">const</span> Debug&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;io=b;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;other=b;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> hw;	<span class="comment">//硬件错误</span></span><br><span class="line">	<span class="type">bool</span> io;	<span class="comment">//io错误</span></span><br><span class="line">	<span class="type">bool</span> other;	<span class="comment">//其他错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>constexpr必须初始化所有的数据成员，初始值使用constexpr构造函数或是一条常量表达式。</strong></p>
<p>constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>)</span></span>;	<span class="comment">//调试io</span></span><br><span class="line"><span class="keyword">if</span>(io_sub.<span class="built_in">any</span>())&#123;	<span class="comment">//等价于if(true)</span></span><br><span class="line">	cerr&lt;&lt;<span class="string">&quot;print appropriate error messages&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;	<span class="comment">//无调试</span></span><br><span class="line"><span class="keyword">if</span>(prod.<span class="built_in">any</span>())&#123;		<span class="comment">// 等价于if(false)</span></span><br><span class="line">	cerr&lt;&lt;<span class="string">&quot;print an error messages&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于成员函数来说，constexpr隐含了const的意思。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const没有显式写的必要</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Debug::max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地址常量表达式"><a href="#地址常量表达式" class="headerlink" title="地址常量表达式"></a>地址常量表达式</h4><p>全局变量等静态分配的对象的地址是一个常量。而该地址是由<code>链接器</code>赋值的，而非编译器。因此编译器并不知道这类地址常量的值是多少，这就限制了指针或者引用类型的常量表达式的使用范围。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p1=<span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p2=p1;  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p3=p1+<span class="number">2</span>;  <span class="comment">//错误,编译器不知道p1本身的值是多少。</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> c=p1[<span class="number">2</span>]; <span class="comment">//ok,c==&#x27;l&#x27;,编译器知道p1所值的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>C++11引入了两种类型推导方式——<strong>auto和decltype</strong>，不过他们具有不同的作用。</p>
<p><strong>auto的作用：</strong>推导等号右侧表达式(结果)的类型。</p>
<p><strong>decltype的作用：</strong>通过现有的表达式来获取其类型。</p>
<p><strong>decltype和auto</strong>的重要区别：</p>
<ul>
<li>decltype使用的表达式是一个变量时返回该变量的类型(包括const和引用在内)，而auto返回的是表达式的最终结果的类型(类型转换和忽略顶层const属性)</li>
<li>decltype的结果类型与表达式形式密切联系。<h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4></li>
</ul>
<p>C++作为一个静态类型语言，需要在定义变量时明确知道变量的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> dval=<span class="number">11.11</span>;</span><br></pre></td></tr></table></figure>

<p>C++11引入了新的类型说明符<strong>auto</strong>，用它能够让编译器替我们去分析表达式所属的类型。</p>
<p>与原来那些只对应一种特定类型的说明符不同，<code>auto</code>让编译器通过初始值来推算变量的类型。</p>
<p><strong>注意：auto定义的变量必须有初始值。</strong></p>
<p>使用auto说明符推断类型时有时候和初始类型并不完全一致，编译器会适当地改变结果来使其更符合初始化规则。参照我的这篇博文<a href="https://imzlp.com/2016/05/04/type-convert-in-cpp/">详细分析下C++中的类型转换</a> </p>
<p><strong>注意：使用引用类型实际上是使用引用的对象，特别是当做初始值的时候，真正参与初始化的其实是引用对象的值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival_1=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// ival2是int类型</span></span><br><span class="line"><span class="keyword">auto</span> ival_2=ival_1;</span><br></pre></td></tr></table></figure>

<p>auto一般会忽略掉顶层const属性，同时底层const则会保留下来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=i,&amp;cr=ci;</span><br><span class="line"><span class="keyword">auto</span> b=ci;	<span class="comment">// b是一个整数，ci的const属性被忽略掉了。</span></span><br><span class="line"><span class="keyword">auto</span> c=cr;	<span class="comment">// c是一个整数，cr是ci的一个别名，ci本身就是一个顶层const</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;i;	<span class="comment">// d是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e=&amp;ci;	<span class="comment">// e是一个指向整型常量的指针</span></span><br></pre></td></tr></table></figure>

<p>如果希望推断出的auto类型是一个顶层const，需要明确指出:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f=ci;</span><br></pre></td></tr></table></figure>

<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g=ci;	<span class="comment">//g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h=<span class="number">42</span>;	<span class="comment">//错误，不能为非常量引用绑定到字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j=<span class="number">42</span>; <span class="comment">//正确，可以为常量引用绑定到字面值</span></span><br></pre></td></tr></table></figure>

<h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>C++11标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是<strong>选择并返回操作数的数据类型</strong>。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum=x; <span class="comment">//sum的类型就是函数f的返回类型</span></span><br><span class="line"><span class="comment">// 编译器不实际调用函数f，而是使用当调用发生f时f的返回值类型作为sum的类型。</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype</strong>处理顶层const和引用的方式与auto有些不同。</p>
<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括const和引用在内)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">0</span>,&amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x=<span class="number">0</span>; <span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y=x; <span class="comment">//y的类型是const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;	  <span class="comment">//错误，z是一个引用，必须要初始化。</span></span><br></pre></td></tr></table></figure>

<h5 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h5><p>如果decltype使用的表达式不是一个变量，则decltype的返回表达式结果对应的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype的结果可以使引用类型</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>,*p=&amp;i,&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;<span class="comment">//正确，加法的结果是int，因此b是一个(未初始化的)int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//错误，*p是int&amp;，必须初始化</span></span><br><span class="line"><span class="comment">//error: declaration of reference variable &#x27;c&#x27; requires an initializer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是解引用操作，则decltype得到的是引用类型。</p>
<p>解引用可以得到指针所指向的对象，而且还能给这个对象赋值。因此decltype(*p)的结果类型是int&amp;而非int.</p>
</blockquote>
<p>对于decltype所用的表达式来说，如果变量名加上一对括号，则得到的类型与加括号时会有所不同。</p>
<p>如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加了一层或多层括号，编译器会把它当做是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确：e是一个(未初始化的)int</span></span><br></pre></td></tr></table></figure>

<h4 id="使用auto和decltype来简化声明"><a href="#使用auto和decltype来简化声明" class="headerlink" title="使用auto和decltype来简化声明"></a>使用auto和decltype来简化声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//下列声明圆括号必不可少</span></span><br><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>]=ia;	<span class="comment">//整型指针数组</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">4</span>]=*ia <span class="comment">//含有四个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>随着auto和decltype的引入，就能够尽可能地避免在数组前面加上一个指针类型了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p=ia;p!=ia+<span class="number">3</span>;++p)&#123;</span><br><span class="line">  <span class="comment">// q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> q=*p+<span class="number">4</span>;++q)</span><br><span class="line">  	cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="using类型别名"><a href="#using类型别名" class="headerlink" title="using类型别名"></a>using类型别名</h3><p>在C++11之前我们使用typedef来定义类型别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> idouble; <span class="comment">//idouble是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> idouble base, *p; <span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>

<p>C++11规定了一种的的别名声明方法<code>using</code>来定义类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> idouble=<span class="type">double</span>;</span><br></pre></td></tr></table></figure>

<p>关键字<code>using</code>作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<p><strong>类型别名简化多维数组的指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array=<span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array *p=ia;p!=ia+<span class="number">3</span>;++p)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> *q=*p;q!=*p+<span class="number">4</span>;++q)</span><br><span class="line">    cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>在c++11之前，如果我们想要遍历一个容器，就需要使用迭代器来遍历容器中的所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 使用迭代器，因为迭代器的本质是指针，所以需要对其解引用</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator index=vecInt.<span class="built_in">begin</span>();index&lt;vecInt.<span class="built_in">end</span>();++index)&#123;</span><br><span class="line">	cout&lt;&lt;*index&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:vecInt)&#123;</span><br><span class="line">  cout&lt;&lt;index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/04.webp"></p>
<p>范围for语句的语法格式为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declration:expression)</span><br><span class="line">  	statement</span><br></pre></td></tr></table></figure>

<p>其中expression部分是一个对象，用于表示一个序列。<strong>declration部分负责定义一个变量，该变量将被用于访问序列中的基础元素</strong>。每次迭代，declration部分的变量会被初始化为expression部分的下一个元素值。</p>
<blockquote>
<p>与上面使用迭代器的做法不同的是，不需要对declration解引用，因为其本身就为一个对象，可以直接访问，但是，其只是expression对象中基础元素的一个副本，修改其值不会改变expression对象中的数据，如果想要修改expression对象中的数据，应该将declration定义为引用。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="comment">//因为我们只是输出容器中所有的值，不需要修改容器中的数据，所以可以不用将index定义为引用类型。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:vecInt)&#123;</span><br><span class="line">  cout&lt;&lt;index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="除法的舍入规则"><a href="#除法的舍入规则" class="headerlink" title="除法的舍入规则"></a>除法的舍入规则</h3><p>C++语言的早期版本允许结果为负值的商向上或者向下取整，C++11新标准规定商一律向0取整(直接切除小数部分)</p>
<p>根据<code>取余运算</code>的定义，如果m和n是整数，且n非0，则表达式(m%n)*n+m%n的求值结果与m相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>((m/n)*n+m%n==m)</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>隐含的含义就是，如果m%n不等于0，则它的符号与m相同。</p>
<p>C++早期版本(C++11之前)，允许m%n的符号匹配n的符号，而且商向负无穷一侧取整，这一方式已经在新标准中禁止使用了。</p>
<p>除了-m导致溢出的情况，其他时候(-m)/n和m/(-n)都等于-(m/n),m%(-n),(-m)%n等于-(m%n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">21%6;	/*结果是3*/	21/6;	/*结果是3*/</span><br><span class="line">21%7;	/*结果是0*/	21/7;	/*结果是3*/</span><br><span class="line">-21%-8;	/*结果是-5*/	-21/-8;	/*结果是2*/</span><br><span class="line">21%-5;	/*结果是1*/	21/-5;	/*结果是-4*/</span><br></pre></td></tr></table></figure>

<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof运算符用来用字节计算右边表达式并返回字节数(constexpr)。</p>
<p>sizeof的两种形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type)	<span class="comment">// 返回该类型在当前系统上的大小(byte)</span></span><br><span class="line"><span class="keyword">sizeof</span> expr		<span class="comment">// 返回表达式的结果类型的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="用于类对象成员"><a href="#用于类对象成员" class="headerlink" title="用于类对象成员"></a>用于类对象成员</h4><blockquote>
<p>C++11新标准允许我们使用作用域操作符(::)来获取类成员的大小。</p>
<p>通常情况下只有通过对象才能访问到类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为要想知道类成员的大小无需真的获取该成员。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取vector&lt;int&gt;的类型大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(vector&lt;<span class="type">int</span>&gt;::iterator);</span><br><span class="line"><span class="comment">// 获取string::size_type的类型大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(string::size_type);</span><br></pre></td></tr></table></figure>

<h4 id="用于不同对象得到的结果"><a href="#用于不同对象得到的结果" class="headerlink" title="用于不同对象得到的结果"></a>用于不同对象得到的结果</h4><p>下面并非C++11的部分，列举一下sizeof对于不同的对象获取的结果：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof结果为1</li>
<li>对引用类型执行sezeof运算得到被引用对象所占空间的大小</li>
<li>对指针执行sezeof运算得到的指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到的是指针指向对象所占空间的大小，指针不需要有效(悬垂指针和野指针也都可以进行sizeof操作)</li>
<li>对数组运算得到的是整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。<strong>注意：sizeof运算不会把数组转换成指针来处理</strong></li>
<li>对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<h3 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h3><p>尾置返回类型跟在形参列表后面并以一个<code>-&gt;</code>符号开头。为了表示函数整整的返回类型在形参列表之后，我们在本应该出现返回类型的地方放置一个auto.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接收一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span>-&gt;<span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

<p>任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数有效，比如返回类型是数组的指针或者数组的引用。</p>
<p>尾置返回类型的必要性源于函数模板的声明，因为其返回类型依赖于参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">product</span><span class="params">(<span class="type">const</span> vector&lt;T&gt;&amp; x,<span class="type">const</span> vector&lt;U&gt;&amp; y)</span>-&gt;<span class="title">decltype</span><span class="params">(x*y)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类的构造"><a href="#类的构造" class="headerlink" title="类的构造"></a>类的构造</h3><h4 id="类内初始化"><a href="#类内初始化" class="headerlink" title="类内初始化"></a>类内初始化</h4><p>C++11标准规定，可以为数据成员提供一个**类内初始值(in-class initializer)**。</p>
<p>创建对象时，类内初始化将用于初始化数据成员。没有初始值的将被默认初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  string book; <span class="comment">//调用默认构造函数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类内初始化必须放在花括号里边，或者放在等号右边，一定不能使用圆括号。因为在类内使用圆括号会有歧义——是data memebr initialization还是member function declaration?</p>
</blockquote>
<h4 id="类对象成员的类内部初始化"><a href="#类对象成员的类内部初始化" class="headerlink" title="类对象成员的类内部初始化"></a>类对象成员的类内部初始化</h4><p>当我们总希望类内的类成员具有默认值的时候，我们可以使用C++11的新标准——把这个默认值声明称一个类内初始值。参照上面的<code>类内初始化</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  string input&#123;<span class="string">&quot;Hello&quot;</span>，<span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-default生成默认构造函数"><a href="#使用-default生成默认构造函数" class="headerlink" title="使用=default生成默认构造函数"></a>使用=default生成默认构造函数</h4><p>在C++11之前的标准中，当我们为类定义了一个构造函数(哪怕不是默认构造函数)，则编译器就不会再为我们生成的一个默认构造函数了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//自己定义了一个构造函数，编译器就不会为我们生成默认构造函数了</span></span><br><span class="line">  <span class="built_in">test</span>(<span class="type">int</span> z):<span class="built_in">x</span>(z)&#123;&#125;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们即需要默认构造函数也需要其他形式的构造函数时，我们必须为默认构造函数显式声明，因为编译器不会为我们合成默认构造函数。</p>
<p>但是在C++11中我们可以使用<code>=default</code>来要求编译器为我们生成一个默认构造函数。</p>
<p>但是不要期望编译器合成的默认构造函数会对数据成员初始化。具体可以参照这篇博文——<a href="https://imzlp.com/2016/05/18/about-the-compiler-to-generate-the-default-constructor/">关于编译器生成默认构造函数的一些误区</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//让编译器为我们合成一个默认构造函数</span></span><br><span class="line">  <span class="built_in">test</span>()=<span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">test</span>(<span class="type">int</span> z):<span class="built_in">x</span>(z)&#123;&#125;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。</p>
</blockquote>
<p>与其他函数一样，如果<code>=default</code>在类的内部，则默认构造函数时内联的，如果它在类的外部，则默认情况下不是内联的。</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><p>C++11新标准扩展了构造函数的初始值功能，使得我们可以定义所谓的<code>委托构造函数(delegating constructor)</code>。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说把它自己的一些(或全部)初始化职责委托给其他构造函数。</p>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员值列表只有一个唯一的入口，就是类名本身。和其他的成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另一个构造函数相匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// 非委托构造函数，接收三个参数来初始化成员</span></span><br><span class="line"> 	<span class="built_in">test</span>(string inputStr,<span class="type">int</span> imath,<span class="type">int</span> ienglish):<span class="built_in">name</span>(inputStr),<span class="built_in">math</span>(imath),<span class="built_in">english</span>(ienglish)&#123;&#125;</span><br><span class="line">	<span class="comment">// 其余的构造函数全部委托给另一个构造函数</span></span><br><span class="line">  	<span class="comment">// 委托接收三个参数的构造函数来执行默认构造函数的职责</span></span><br><span class="line">  	<span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">// 接收一个参数的构造函数委托接收三个参数的构造函数类执行构造职责</span></span><br><span class="line">  	<span class="built_in">test</span>(string inputStr):<span class="built_in">test</span>(inputStr,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> math,english;</span><br><span class="line">  string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在上面的test类中，受委托的函数体恰好是空的。加入函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的代码。</p>
<p>如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// 非委托构造函数，接收三个参数来初始化成员</span></span><br><span class="line"> 	<span class="built_in">test</span>(string inputStr,<span class="type">int</span> imath,<span class="type">int</span> ienglish):<span class="built_in">name</span>(inputStr),<span class="built_in">math</span>(imath),<span class="built_in">english</span>(ienglish)&#123;</span><br><span class="line">  		cout&lt;&lt;<span class="string">&quot;test(string inputStr,int imath,int ienglish)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 其余的构造函数全部委托给另一个构造函数</span></span><br><span class="line">  	<span class="comment">// 委托接收三个参数的构造函数来执行默认构造函数的职责</span></span><br><span class="line">  	<span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Default Constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">    <span class="comment">// 接收一个参数的构造函数委托接收三个参数的构造函数类执行构造职责</span></span><br><span class="line">  	<span class="built_in">test</span>(string inputStr):<span class="built_in">test</span>(inputStr,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> math,english;</span><br><span class="line">  string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们声明一个test的对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test X;</span><br></pre></td></tr></table></figure>

<p>会输出：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/06.webp"></p>
<p>可以看出，是先执行完委托构造函数体中的代码然后才会执行委托者中的代码。</p>
<h3 id="使用string对象当做文件流对象的文件名"><a href="#使用string对象当做文件流对象的文件名" class="headerlink" title="使用string对象当做文件流对象的文件名"></a>使用string对象当做文件流对象的文件名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件，每次写之前定位到文件末尾</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ofstream::app | ofstream::out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在之前的C++标准中，文件名参数(也就是上面代码中的<code>&quot;out.txt&quot;</code>)只允许是C风格数组。</p>
<p>C++11中文件名既可以是C风格数组也可以是string对象。</p>
<p>即，上面的代码也可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">filename</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 打开文件，每次写之前定位到文件末尾</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(filename, ofstream::app | ofstream::out)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="STL容器相关特性"><a href="#STL容器相关特性" class="headerlink" title="STL容器相关特性"></a>STL容器相关特性</h3><h4 id="array和forward-list容器"><a href="#array和forward-list容器" class="headerlink" title="array和forward_list容器"></a>array和forward_list容器</h4><table>
<thead>
<tr>
<th align="center">容器名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">array</td>
<td align="center">固定大小数组。支持快速随机访问。不能添加或删除元素。</td>
</tr>
<tr>
<td align="center">forward_list</td>
<td align="center">单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td>
</tr>
</tbody></table>
<p><code>forward_list</code>和<code>array</code>是C++11标准新增加的容器类型。</p>
<p>与内置数组相比，array是一种更加安全、更容易使用的数组类型。</p>
<p>与内置类型类似，array对象的大小是固定的。因此array不支持添加和删除元素以及改变容器大小的操作。</p>
<p><code>array</code>是个模板，它可以存放任意数量、任意类型的元素。它还可以直接处理异常和const对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,3&gt; x=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>与内置类型相比，<code>std::array</code>有两个明显的优势：</p>
<ol>
<li>它是一种真正的对象类型(可以执行赋值操作)。</li>
<li>不会隐式地转换为指向元素的指针(传递数组退化为指针)。</li>
</ol>
<p>但是<code>stad::array</code>也有不足，我们无法根据初始化器的长度推断元素的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3个元素</span></span><br><span class="line">array&lt;<span class="type">int</span>,3&gt; x=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error,too few template arguments for class template &#x27;array&#x27;</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt; z=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>更多<code>std::array</code>支持的操作可以看这里：<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/array">std::array - cppreference</a></p>
<p><code>forward_list</code>的设计目标是达到最好与最好的<strong>手写单向链表数据结构</strong>相当的性能。</p>
<p>因此,<code>forward_list</code>没有<code>size操作</code>，因为保存或计算其大小就会比手写链表多出额外的开销。</p>
<p>对于其他容器而言，size保证是一个快速的常量时间的操作。</p>
<ul>
<li>forward_list有自己专门的<code>emplace</code>和<code>insert</code></li>
<li>forward_list不支持<code>push_back</code>和<code>emplace_back</code>操作</li>
</ul>
<h4 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a>initializer_list形参</h4><p>如果函数的实参数量未知，但是<strong>全部实参的类型都相同</strong>，那么就可以使用<code>initializer_list类型</code>的形参。</p>
<p><code>initializer_list</code>是一种标准库类型，用于表示特定类型值的数组。定义在同名(initializer_list)头文件中。与vector一样initializer_list也是一种<code> 模板类型</code>，定义initializer_list对象时必须说明列表中所含元素的类型。</p>
<table>
<thead>
<tr>
<th align="center">initializer_list提供的操作</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">initializer_list<T> lst;</td>
<td align="center">默认初始化：T元素类型的空列表</td>
</tr>
<tr>
<td align="center">initializer_list<T> lst{a,b,c,d….}</td>
<td align="center">lst的元素和初始值一样多;</p>lst的元素是对应初始值的副本;列表中的元素是const</td>
</tr>
<tr>
<td align="center">lst2(lst)</p>lst2=lst</td>
<td align="center">拷贝或赋值一个initializer_list对象不会拷贝列表中的元素，拷贝后原始列表和副本共享元素</td>
</tr>
<tr>
<td align="center">lst.size()</td>
<td align="center">列表中的元素数量</td>
</tr>
<tr>
<td align="center">lst.begin()</td>
<td align="center">获取指向lst中首元素的指针</td>
</tr>
<tr>
<td align="center">lst.end()</td>
<td align="center">获取指向lst中尾元素的下一位置的指针</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(<span class="type">const</span> initializer_list&lt;T&gt; initList)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;index:initList)&#123;</span><br><span class="line">  		cout&lt;&lt;index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出123456</span></span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; x&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">error_msg</span>(x);</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>列表值序列&#123;&#125;</code>来传递给initializer_list形参的函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这段代码在template &lt;class T&gt;下会产生错误,直接使用initializer_list&lt;string&gt;则会成功</span></span><br><span class="line"><span class="comment">//error: no matching function for call to &#x27;error_msg&#x27;</span></span><br><span class="line"><span class="comment">//note: candidate template ignored: deduced conflicting types for parameter &#x27;T&#x27; (&#x27;const char *&#x27; vs. &#x27;std::__cxx11::basic_string&lt;char&gt;&#x27;)</span></span><br><span class="line">string name=<span class="string">&quot;Charley&quot;</span>;</span><br><span class="line"><span class="built_in">errror_msg</span>(&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,name&#125;);</span><br></pre></td></tr></table></figure>

<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/05.webp"></p>
<p>也可以用<code>initializer_list</code>存储已有的相同类型的变量，然后传递给函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;T&gt;&amp; initList)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> index:iniList)&#123;</span><br><span class="line">  		cout&lt;&lt;*index&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">	initializer_list&lt;<span class="type">int</span>&gt; test&#123;a,b,c&#125;;</span><br><span class="line">	<span class="built_in">error_msg</span>&lt;<span class="type">int</span>&gt;(test);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对initializer_list对象的引用是const引用，获取initializer_list对象的指针也是const指针。</p>
</blockquote>
<p>下面的内容查自cppreference——<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/utility/initializer_list">initializer_list</a>:</p>
<p>An object of type <code>std::initializer_list</code> is a lightweight proxy object that provides access to an array of objects of type<code>const T</code>.</p>
<p>A <code>std::initializer_list</code> object is automatically constructed when:</p>
<ul>
<li>a <em>braced-init-list</em> is used in <a href="../language/list_initialization.html">list-initialization</a>, including function-call list initialization and assignment expressions</li>
<li>a <em>braced-init-list</em> is bound to <a href="../language/auto.html">auto</a>, including in a <a href="../language/range-for.html">ranged for loop</a></li>
</ul>
<p>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a <code>std::initializer_list</code> does not copy the underlying objects.</p>
<table>
<thead>
<tr>
<th align="center">Member type</th>
<th align="center">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value_type</td>
<td align="center">T</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">const T&amp;</td>
</tr>
<tr>
<td align="center">const_reference</td>
<td align="center">const T&amp;</td>
</tr>
<tr>
<td align="center">size_type</td>
<td align="center">std::size_t</td>
</tr>
<tr>
<td align="center">iterator</td>
<td align="center">const T*</td>
</tr>
<tr>
<td align="center">const_iterator</td>
<td align="center">const T*</td>
</tr>
</tbody></table>
<p>从上面的表可以看出，如果使用&amp;或迭代器传递initializer_list对象，我们是不能够修改其值的。</p>
<p>by Value可以，但是，修改的对象就不是实参了。</p>
<h4 id="容器的非成员函数swap"><a href="#容器的非成员函数swap" class="headerlink" title="容器的非成员函数swap"></a>容器的非成员函数swap</h4><p>在C++11中，容器既提供成员函数版本的swap也提供非成员函数版本的swap</p>
<p>而早期的标准版本只提供成员函数版本的swap。非成员函数版本的swap在泛型编程中非常重要。统一使用非成员函数版本是个好习惯。</p>
<p><code>swap</code>是交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个元素的vector</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">20</span>)</span></span>;	<span class="comment">//20个元素的vector</span></span><br><span class="line"><span class="comment">// 交换之前，svec1和svec2中的元素个数</span></span><br><span class="line">cout&lt;&lt;svec1.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;svec2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">swap</span>(svec1,svec2);</span><br><span class="line"><span class="comment">// 交换之后，svec1和svec2中的元素个数</span></span><br><span class="line">cout&lt;&lt;svec1.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;svec2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/07.webp"></p>
<p>交换两个容器的内容的操作保证很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>
<p>除了array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证在常数时间内完成。</p>
<blockquote>
<p>元素不会移动的事实意味着，除了string外，指向容器的迭代器、引用和指针在swap之后都不会失效。他们仍然指向swap操作之前所指向的那些元素。但是在swap之后，这些元素已经属于不同的容器了。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec1&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;zhalipeng&quot;</span>&#125;;	<span class="comment">//10个元素的vector</span></span><br><span class="line">vector&lt;string&gt; svec2&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;family&quot;</span>&#125;;	<span class="comment">//20个元素的vector</span></span><br><span class="line"><span class="keyword">auto</span> svec1_index=svec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> svec2_index=svec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">swap</span>(svec1,svec2);</span><br><span class="line"><span class="comment">//此时我们对输出svec1_index和svec2_index</span></span><br><span class="line">cout&lt;&lt;*svec1_index&lt;&lt;endl&lt;&lt;*svec2_index&lt;&lt;endl;</span><br><span class="line"><span class="comment">//得到的结果是</span></span><br><span class="line">My</span><br><span class="line">I</span><br><span class="line"><span class="comment">//实际上，我们现在修改svec1_index的值实际上修改的是svec2容器中元素的值，对svec2_index也亦然</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：对一个string容器调用swap操作会导致迭代器、指针和引用失效。</strong></p>
<blockquote>
<p>与其他容器不同，对两个array容器进行swap操作会真正交换他们的元素。因此交换两个array所需的时间与array中元素的数目成正比。<br>因此对于array容器，在swap之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另外一个array中对应的元素的值进行了交换。</p>
</blockquote>
<h4 id="容器的insert返回类型"><a href="#容器的insert返回类型" class="headerlink" title="容器的insert返回类型"></a>容器的insert返回类型</h4><p>我们可以使用容器的成员函数insert来插入一段范围内的元素。</p>
<table>
<thead>
<tr>
<th align="center">insert版本</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c.insert(p,t)</td>
<td align="center">在迭代器p指向的元素之前创建一个值为t的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td align="center">c.insert(p,b,e)</td>
<td align="center">将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前</td>
</tr>
<tr>
<td align="center">c.insert(p,n,t)</td>
<td align="center">在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加元素的第一个元素的迭代器;若n为0则返回p</td>
</tr>
</tbody></table>
<p><strong>在新标准下，接收元素个数或返回的insert版本返回指向第一个新加入元素的迭代器。在旧的标准中，这些操作返回void。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec1&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;zhalipeng&quot;</span>&#125;;	<span class="comment">//10个元素的vector</span></span><br><span class="line">vector&lt;string&gt; svec2&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;family&quot;</span>&#125;;	<span class="comment">//20个元素的vector</span></span><br><span class="line"><span class="keyword">auto</span> x=svec1.<span class="built_in">insert</span>(svec1.<span class="built_in">end</span>(),svec2.<span class="built_in">begin</span>(),svec2.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(x)==<span class="built_in">typeid</span>(vector&lt;string&gt;::iterator))&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用C++11(-std=c++11)编译(如果不是则auto也编译不过)，结果是yes</span></span><br></pre></td></tr></table></figure>

<h4 id="emplace操作"><a href="#emplace操作" class="headerlink" title="emplace操作"></a>emplace操作</h4><p>新标准引入了三个新成员——<code>emplace_front</code>、<code>emplace</code>和<code>emplace_back</code>，这些操作<code>构造</code>而不是拷贝元素。</p>
<p>这些操作分别对应<code>push_front</code>、<code>insert</code>和<code>push_back</code>，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p>
<ul>
<li>forward_list有自己专门的<code>emplace</code>和<code>insert</code></li>
</ul>
<ul>
<li>forward_list不支持<code>push_back</code>和<code>emplace_back</code>操作</li>
</ul>
<ul>
<li>vector和string不支持<code>push_front</code>和<code>emplace_front</code></li>
</ul>
<p>当调用push或者insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器中管理的内存空间中直接构造元素。</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定我们现在有一个类test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> string strinput,<span class="type">int</span> iyear):<span class="built_in">year</span>(iyear),<span class="built_in">name</span>(strinput)&#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; in,test &amp;object);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> year;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载&lt;&lt;操作符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; in,test&amp; object)&#123;</span><br><span class="line">	in&lt;&lt;object.name&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;object.year;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用emplace_back添加test对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;test&gt; x;</span><br><span class="line"><span class="comment">//使用emplace_back在对象x的尾部部构造一个test对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  	<span class="comment">// 使用两个参数的test的构造函数</span></span><br><span class="line">	x.<span class="built_in">emplace_back</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:x)&#123;</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/08.webp"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用push_back来试试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	<span class="comment">//这么做是不对的</span></span><br><span class="line">  	<span class="comment">//error: no matching member function for call to &#x27;push_back&#x27;</span></span><br><span class="line">  	<span class="comment">//note: candidate function not viable: requires single argument &#x27;__x&#x27;, but 2 arguments were provided</span></span><br><span class="line">  	<span class="comment">//note: candidate function not viable: requires single argument &#x27;__x&#x27;, but 2 arguments were provided</span></span><br><span class="line">	x.<span class="built_in">push_back</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的做法是显式地调用test的构造函数</span></span><br><span class="line">x.<span class="built_in">push_back</span>(<span class="built_in">test</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i));</span><br></pre></td></tr></table></figure>

<p>可以看出，上面emplace_back的调用和push_back的调用都会创建一个新的test对象。在调用emplace时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部的临时对象，并将其压入容器中。</p>
<blockquote>
<p>emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;test&gt; x;</span><br><span class="line"><span class="comment">// 调用test的默认构造函数</span></span><br><span class="line">x.<span class="built_in">emplace_back</span>();</span><br><span class="line"><span class="comment">//在x.begin()之前插入一个test对象，调用接收两个形参的构造函数</span></span><br><span class="line">x.<span class="built_in">emplace</span>(x.<span class="built_in">begin</span>(),<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector和string不支持emplace_front(在容器首部构造元素)</span></span><br><span class="line">list&lt;test&gt; y&#123;&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">2001</span>&#125;,&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">2002</span>&#125;&#125;;</span><br><span class="line">y.<span class="built_in">emplace_front</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:y)&#123;</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string数值转换函数"><a href="#string数值转换函数" class="headerlink" title="string数值转换函数"></a>string数值转换函数</h4><p>C++11中引入了多个函数，可以实现数值数据与标准库string之间的转换。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">操作含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">to_string(val)</td>
<td align="left">一组重载函数，返回数值val的string表示。val可以是任何算数类型。对每个浮点类型和int或更大的整型都有相应版本的to_string。<p>与往常一样，小整型会被提升。</td>
</tr>
<tr>
<td align="center">stoi(s,p,b)<p>stol(s,p,b)<p>stoul(s,p,b)<p>stoll(s,p,b)<p>stoull(s,p,b)<p></td>
<td align="left">返回s的起始子串(表示整数内容)的数值，返回值类型分别是int/long/long long/unsigned long/unsigned long long。b表示转换所用的基数，默认值为10。p是一个指针，用来保存s中第一个非数值字符的下标，p默认为0，即函数不保存下标。</td>
</tr>
<tr>
<td align="center">stof(s,p)<p>stod(s,p)<p>stold(s,p)</td>
<td align="left">返回s的起始子串(表示浮点数内容的数值)返回值类型分别是float/double/long double。参数p的作用与整数转换函数中的一样。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to_string</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">string s = <span class="built_in">to_string</span>(i);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object s = &quot;</span>&lt;&lt;s &lt;&lt;endl&lt;&lt;<span class="string">&quot;s.size() = &quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">string pistr = <span class="built_in">to_string</span>(pi);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object pistr = &quot;</span> &lt;&lt; pistr &lt;&lt; endl &lt;&lt; <span class="string">&quot;pistr.size() = &quot;</span> &lt;&lt; pistr.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/09.webp"></p>
<p>将double转换为string会发生浮点舍入——具体内容参照<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE754</a></p>
<p>由string到其他算数类型的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stod</span></span><br><span class="line"><span class="function">string <span class="title">pi</span><span class="params">(<span class="string">&quot;pi=3.14159&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> dpi = <span class="built_in">stod</span>(pi.<span class="built_in">substr</span>(pi.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout &lt;&lt; dpi &lt;&lt; endl;</span><br><span class="line"><span class="comment">// stoi</span></span><br><span class="line"><span class="function">string <span class="title">elevenstr</span><span class="params">(<span class="string">&quot;eleven=11&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> ieleven=<span class="built_in">stoi</span>(elevenstr.<span class="built_in">substr</span>(elevenstr.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout&lt;&lt;ieleven&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/10.webp"></p>
<p>上面用到了两个成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串。</span></span><br><span class="line"><span class="function">basic_string <span class="title">substr</span><span class="params">( size_type index, size_type num = npos )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find_first_of 有四种重载版本</span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> basic_string &amp;str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="comment">//find_first_of()函数: </span></span><br><span class="line"><span class="comment">//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，如果没找到就返回string::npos </span></span><br><span class="line"><span class="comment">//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，最多搜索num个字符。如果没找到就返回string::npos， </span></span><br><span class="line"><span class="comment">//查找在字符串中第一个与ch匹配的字符，返回它的位置。搜索从index开始。 </span></span><br></pre></td></tr></table></figure>

<h4 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h4><table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">操作行为</th>
<th align="center">适用范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c.shrink_to_fit()</td>
<td align="center">请将capacity()减少为size()同样的大小</td>
<td align="center">只适用于vector,string和deque</td>
</tr>
<tr>
<td align="center">c.capacity()</td>
<td align="center">不重新分配内存的话，c可以保存多少元素</td>
<td align="center">只适用于vector和string</td>
</tr>
<tr>
<td align="center">c.reserve(n)</td>
<td align="center">分配至少能容纳n个元素的内存空间</td>
<td align="center">只适用于vector和string</td>
</tr>
</tbody></table>
<blockquote>
<p>reserve操作并不会改变容器中元素的数量，它影响vector预先分配多大的内存空间。</p>
<p>只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间(可能更大)。</p>
<p>如果需求大小小于或等于当前容量，reserve什么也不做。特别是需求大小小于当前容量时，容器不会退回内存空间，因此在调用reserve之后，capacity将会大于或等于传递给reserve的参数。</p>
<p>这样，调用reserve永远不会减少容器占用的内存空间。</p>
<p>类似的resize成员函数只改变容器中元素的数目，而不是容器的容量。同样不能使用resize来减少容器预留的内存空间。</p>
</blockquote>
<p>在C++11标准中，我们可以调用shrink_to_fit来要求<code>vector</code>、<code>deque</code>、<code>string</code>退回不需要的内存空间。</p>
<p>此函数指出我们不再需要任何多余的内存空间。但是具体的实现可以选择忽略此请求，也就是说，调用shrink_to_fit也不保证一定退回内存空间。</p>
<h5 id="capacity和size的区别"><a href="#capacity和size的区别" class="headerlink" title="capacity和size的区别"></a>capacity和size的区别</h5><ul>
<li>size：指容器中已经保存的元素的数目</li>
<li>capacity：指在不重新分配内存的前提下可以保存多少元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"><span class="comment">//size的值为0,capacity的值依赖于具体实现</span></span><br><span class="line">cout&lt;&lt;x.<span class="built_in">capacity</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;x.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>上面的代码在不同平台的编译下结果:</p>
<table>
<thead>
<tr>
<th align="center">编译环境</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Visual Studio2015</td>
<td align="center">0    0</td>
</tr>
<tr>
<td align="center">Clang 3.7.0 x86_64-w64-windows-gnu</td>
<td align="center">0    0</td>
</tr>
<tr>
<td align="center">g++ 5.2.0 x86_64-posix-seh-rev1</td>
<td align="center">0    0</td>
</tr>
</tbody></table>
<h4 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h4><p>C++11中定义了四个<code>无序关联容器(unordered associative container)</code>。</p>
<p>分别为：<code>unordered_map</code>,<code>unordered_set</code>,<code>unordered_multimap</code>,<code>unordered_multiset</code>，在使用相应的无序容器时也需要包含其相应的头文件(容器名)。</p>
<p>这些容器不是使用比较运算符来组织元素，而是使用一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">哈希函数(hash function)</a>和关键字(key)类型<code>==运算符</code>。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序列代价非常高，此时无序容器也很有用。</p>
<blockquote>
<p>如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。</p>
</blockquote>
<h5 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h5><p>除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作(fins、insert等)。这意味着能够用在map和set上的操作也可以用在<code>unordered_map</code>和<code>unordered_set</code>。类似的，无序容器也有允许重复关键字的版本。</p>
<p>通常可以用一个无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的程序的输出通常会与使用有序容器的版本不同。</p>
<p>例如，可以使用<code>unordered_map</code>写一个单词计数程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="comment">// 读取一行字符串</span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">	++word_count[word];</span><br><span class="line">  	<span class="comment">// 判断是否读到行末的\n</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">getchar</span>()==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_count)</span><br><span class="line">  cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs&quot;</span>&lt;&lt;(w.second&lt;&lt;(w.second&gt;<span class="number">1</span>)?<span class="string">&quot; times&quot;</span>:<span class="string">&quot; time&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>注意，因为是<strong>无序容器</strong>，所以残次输出的顺序是不太可能按照读入的顺序输出的。</p>
<h5 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h5><p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个桶中。因此，<code>无序容器的性能</code>依赖于哈希函数的质量和桶的数量大小。</p>
<p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是将不同的关键字映射到相同的桶也是允许的。</p>
<p>当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个匀速的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶中保存了很多的元素，那么查找一个特定元素就需要大量的比较操作。</p>
<p>无序容器提供了一组管理桶的函数。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>
<table>
<thead>
<tr>
<th align="center">管理桶的函数</th>
<th align="left">操作含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>桶接口</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">c.bucket_count()</td>
<td align="left">正在使用的桶的数目</td>
</tr>
<tr>
<td align="center">c.max_bucket_count()</td>
<td align="left">容器能容纳最多的桶的数目</td>
</tr>
<tr>
<td align="center">c.bucket_size(n)</td>
<td align="left">第n个桶中有多少个元素</td>
</tr>
<tr>
<td align="center">c.bucket(k)</td>
<td align="left">关键字为k的元素在哪个桶中</td>
</tr>
<tr>
<td align="center"><strong>桶迭代</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">local_iterator</td>
<td align="left">可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td align="center">const_local_iterator</td>
<td align="left">桶迭代器的const版本</td>
</tr>
<tr>
<td align="center">c.begin(n)/c.end(n)</td>
<td align="left">桶n的首元素迭代器和尾后迭代器</td>
</tr>
<tr>
<td align="center">c.cbegin(n)/c.cend(n)</td>
<td align="left">与前两个函数类似，但返回的是const_local_iterator</td>
</tr>
<tr>
<td align="center"><strong>哈希策略</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">c.loadfactor()</td>
<td align="left">每个桶的平均元素数量，返回float值</td>
</tr>
<tr>
<td align="center">c.max_load_factor()</td>
<td align="left">c试图维护平均桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor&lt;=max_load_factor重组存储，使得bucket_count&gt;=n</td>
</tr>
<tr>
<td align="center">c.rehash(n)</td>
<td align="left">重新存储。使得bucket_count&gt;=n且bucket_cout&gt;size/max_load_factor</td>
</tr>
<tr>
<td align="center">c.reserve(n)</td>
<td align="left">重新存储。使得c可以保存n个元素而不必rehash</td>
</tr>
</tbody></table>
<h5 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h5><p>默认情况下，无序容器使用关键字类型的<code>==运算符</code>来比较元素，它们还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型(包括指针)提供了hash模板。还为一些标准库类型，包括string和只能指针类型定义了hash。因此我们可以直接定义<code>关键字</code>是<code>内置类型(包括指针类型)</code>、<code>string</code>还是<code>智能指针类型</code>的无序容器。</p>
<blockquote>
<p>注意：虽然无序容器支持关键字是内置类型(包括指针类型)、string还是智能指针类型。但是我们不能直接定义<code>关键字类型</code>为自定义类型的无序容器。</p>
<p>与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。会在<code>模板特例化部分讲到如何实现自己的hash版本</code>。</p>
</blockquote>
<p>我们不使用默认的hash，而是使用另一种方法，类似于为有序容器<code>重载</code>关键字类型的<code>默认比较操作</code>。</p>
<p>为了能让我们的自定义类型用作无序容器的关键字，我们需要提供函数来替代<code>==运算符</code>和<code>hash计算函数</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定我们现在有一个自定义类book</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">book</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">book</span>(<span class="type">const</span> <span class="type">int</span> &amp;in=<span class="number">0</span>):<span class="built_in">isbn</span>(in)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getisbn</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> book &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> isbn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> book::<span class="keyword">operator</span>==(<span class="type">const</span> book &amp;rhs)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getisbn</span>()==rhs.<span class="built_in">getisbn</span>())&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从定义这些重载函数开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> book &amp;bk)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(bk.<span class="built_in">getisbn</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类中重载了==操作符的此函数可以忽略</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eqOq</span><span class="params">(<span class="type">const</span> book &amp;lhs,<span class="type">const</span> book &amp;rhs)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> lhs.<span class="built_in">getisbn</span>()==rhs.<span class="built_in">getisbn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们没有重载类的<code>==操作符</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BK_multiset=unordered_multiset&lt;book, <span class="keyword">decltype</span>(hasher)*,<span class="keyword">decltype</span>(eqOq)*&gt;;</span><br><span class="line"><span class="comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">BK_multiset <span class="title">bookstore</span><span class="params">(<span class="number">10</span>,hasher,eqOq)</span></span>;</span><br></pre></td></tr></table></figure>

<p>重载了<code>==操作符</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;book,<span class="title">decltype</span><span class="params">(bkHash)</span>*&gt; <span class="title">bkset</span><span class="params">(<span class="number">10</span>,bkHash)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>我们可以向一个算法传递任何类别的<strong>可调用对象(callable object)**。<br>对于一个对象或者表达式，如果可以对其使用</strong>调用运算符()<strong>，则称它为可调用的。<br>在C++11之前，我们可以使用的可调用对象为</strong>函数<strong>和</strong>函数指针<strong>，还有</strong>重载了调用运算符的类<strong>。<br>C++11引入了一种新的可调用对象——</strong>lambda**<br>一个lambda表达式表示一个可调用的代码单元。我们可以理解为一个未命名的内联函数。<br>lambda表达式又叫做<strong>匿名函数</strong>。<br>与任何函数类似，<strong>一个lambda具有一个返回类型(必须使用尾置返回类型)、一个参数列表和一个函数体。</strong><br>但函数不同，lambda可能定义在函数内部。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt; <span class="keyword">return</span> type&#123;function body&#125;</span><br><span class="line">[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</span><br></pre></td></tr></table></figure>

<p><code>capaure list(捕获列表)</code>，是一个lambda所在函数中定义的局部变量的列表。<code>parameter list、return 和function body</code>与普通函数一样，分别表示形参表，返回类型和函数体。<br>也可以忽略lambda的参数列表和返回类型，在lambda中忽略括号和参数列表等价于指定一个空参数列表。但必须永远包含捕获列表和函数体。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来。否则返回类型为void。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[]&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="comment">//输出42</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果lambda的函数体包含任何单一return语句(c++14可以多个但必须同类型)之外的内容且未指定返回类型，则返回void。</p>
</blockquote>
<p><strong>注意</strong>：lambda除了能作为参数外，还能用于初始化一个声明为auto或者<code>std::function&lt;R(AL)&gt;</code>的变量。其中R是它的返回类型，AL是它的类型参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error,无法在推断一个auto变量的类型之前使用它(递归)</span></span><br><span class="line"><span class="keyword">auto</span> rev=[&amp;rev](<span class="type">char</span> *b,<span class="type">char</span>* e)&#123;<span class="keyword">if</span>(<span class="number">1</span>&lt;e-b)&#123;<span class="built_in">swap</span>(*b,*--e);<span class="built_in">rev</span>(++b,e);&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok，可以确保在使用dev之前就知道它的类型</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">char</span>* b,<span class="type">char</span> *e)&gt; rev=[&amp;rev](<span class="type">char</span> *b,<span class="type">char</span>* e)&#123;<span class="keyword">if</span>(<span class="number">1</span>&lt;e-b)&#123;<span class="built_in">swap</span>(*b,*--e);<span class="built_in">rev</span>(++b,e);&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rev</span>(&amp;s1[<span class="number">0</span>],&amp;s1[<span class="number">0</span>]+s1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">rev</span>(&amp;s2[<span class="number">0</span>],&amp;s2[<span class="number">0</span>]+s2.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>如果只是想给lambda起个名字，而不递归使用可以使用auto。<br>如果一个lambda什么也不捕获，则可以将它赋值给一个指向正确类型的函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> (*p1)(<span class="type">double</span>)=[](<span class="type">double</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;;</span><br><span class="line"><span class="built_in">double</span> (*p2)(<span class="type">double</span>)=[&amp;](<span class="type">double</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;;  <span class="comment">// 错误，lambda捕获了内容</span></span><br><span class="line"><span class="built_in">double</span> (*p3)(<span class="type">int</span>)=[](<span class="type">int</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;; <span class="comment">// 错误，参数类型不匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="向lambda传递参数"><a href="#向lambda传递参数" class="headerlink" title="向lambda传递参数"></a>向lambda传递参数</h4><p>与一个普通函数类似，调用一个lambda时给定的实参被用来初始化lambda的形参。<br>通常，实参和形参的类型必须匹配。但与普通函数不同，<code>lambda不能有默认形参</code>，因此，一个lambda调用实参的数目必须与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// 调用stable_sort对容器word进行排序，根据元素长度进行升序排序</span></span><br><span class="line">  <span class="built_in">stable_sort</span>(word.<span class="built_in">begin</span>(),word.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp; a,<span class="type">const</span> string&amp; b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> index:word)&#123;</span><br><span class="line">  	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/11.webp"></p>
<p>stable_sort的原型：更多详细的内容看以参照这里——<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/algorithm/stable_sort">stable_sort - cppreference</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数frist和last表示范围内的元素，comp是一个谓词参数，是比较函数，如果第一个参数小于第二个参数，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cmp的声明形式应如下</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type1</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type1</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以用lambda来替代函数cmp(lambda本来也就是函数的形式，不过它是匿名函数)</p>
<h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><h5 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h5><p>在介绍lambda的捕获列表之前，我们先来熟悉一下<code>谓词</code>的概念。</p>
<p><code>谓词</code>是一个可调用的表达式，其返回结果是一个能用做条件的值(bool)。</p>
<p>标准库算法用到的谓词分为两类:<code>一元谓词(unary predicate,意味着它们只能接收单一参数)</code>和<code>二元谓词(binary predicate,意味着他们有两个参数)</code>。接受谓词参数的算法对输入序列中的元素调用谓词。因此元素类型必须能够转换为谓词的参数类型。</p>
<p>虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需要的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">5</span>;</span><br><span class="line">vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//如果捕获列表为空，则在lambda函数体中使用num是错误的</span></span><br><span class="line"><span class="comment">//error: 无法隐式捕获“num”，因为尚未指定默认捕获模式</span></span><br><span class="line"><span class="keyword">auto</span> oneIndex=<span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(),word.<span class="built_in">end</span>(),[num](<span class="type">const</span> string&amp; a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=num;&#125;);</span><br><span class="line"><span class="comment">//得到的是word中第一个长度超过5的元素</span></span><br><span class="line">cout&lt;&lt;*oneIndex&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，lambda会捕获num用作lambda函数体中。</p>
<p>改写上面的代码，使其能够输出一个容器中所有长度大于X的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [num](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= num; &#125;); index != word.<span class="built_in">end</span>();) &#123;</span><br><span class="line">	cout &lt;&lt; *index &lt;&lt; endl;</span><br><span class="line">	index= <span class="built_in">find_if</span>(index + <span class="number">1</span>, word.<span class="built_in">end</span>(), [num](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= num; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/12.webp"></p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。</p>
<p>当向一个函数传递一个lambda时，同时定义一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。</p>
<p>当我们用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>
<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获变量的数据成员。类似于任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>
<p>选择是值捕获还是引用捕获的依据与函数参数完全一致。<br>如果我们希望向捕获的对象写入内容，或者捕获的对象很大，则应该使用引用。对于<code>lambda</code>来说，还应该注意它的有效期可能会超过它的调用者。</p>
<p>当把<code>lambda</code>传递给其他线程时，一般来说通过**值捕获([=])**更优：通过引用或者指针访问其他线程的栈内容是一种危险的操作(对于正确性和性能都是如此)，更严重的是，视图访问一个已终止的线程的栈内容会印发极难发现的程序错误。</p>
<p>如果你想要捕获<code>可变参数模板</code>，可以使用<code>...</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typaname ...Var&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo</span><span class="params">(<span class="type">int</span> s,Var ...v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> helper=[&amp;s,&amp;v...]&#123;<span class="keyword">return</span> s*(<span class="built_in">h1</span>(v...)+<span class="built_in">h2</span>(v...));&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><p>类似参数传递，变量的捕获方式也可以是值或者引用。</p>
<p>与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值在lambda创建时拷贝，而不是调用时拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printX=[x]()&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">//运行会输出x的值11</span></span><br></pre></td></tr></table></figure>

<p>注意：使用值捕获是不能够直接在lambda中修改捕获的变量值的。</p>
<p>如果我们意图修改值捕获方式的对象值将会编译错误，但引用捕获不会：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值捕获</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 错误：“x”: 无法在非可变 lambda 中修改通过复制捕获</span></span><br><span class="line"><span class="comment">// error: cannot assign to a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="keyword">auto</span> printX = [x]() &#123;cout &lt;&lt; x &lt;&lt; endl; <span class="keyword">return</span> ++x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用捕获</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printY = [&amp;y]() &#123;cout &lt;&lt; y &lt;&lt; endl; <span class="keyword">return</span> ++y; &#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>想要在lambda的函数体中修改捕获的值，可以使用<code>引用捕获</code>，也可以使用<code>mutable</code>修饰值捕获的lambda，后面介绍，在此先按下不表。</p>
<p>cppreference中这么写道：</p>
<blockquote>
<p>Unless the keyword mutable was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this operator().<br>链接：<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions (since C++11)</a></p>
</blockquote>
<h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><p>我们定义lambda时使用<code>引用捕获</code>的方式捕获变量。使用方法和在捕获对象前添加一个&amp;号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printX=[&amp;x]()&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">//运行会输出x的值11</span></span><br></pre></td></tr></table></figure>

<p><code>引用捕获</code>和<code>返回引用</code>有着相同的问题和限制：如果我们采用引用方式捕获一个变量，就必须确保被引用对象在lambda执行的时候是存在的。</p>
<p>lambda捕获的都是<code>局部变量(local)</code>，这些变量在函数结束之后就不复存在了。如果lambda可能在函数结束之后执行，捕获的引用指向的局部变量已经消失。</p>
<p><code>引用捕获</code>有时候是必要的，比如，我们需要用lambda捕获一个<code>ostream</code>，因为IO对象不可复制，所以只能使用引用捕获。</p>
<p>也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。</p>
<h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>除了显式列出我们希望使用的来自所在函数的变量之外，还可以<strong>让编译器很据lambda体中的代码来推断我们要使用那些变量</strong>(意味着，编译器只会捕获在函数体中用到的变量)。为了指示编译器推断捕获列表，应在捕获列表中写一个<code>&amp;</code>或者<code>=</code>。<code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval=<span class="number">11.11</span>;</span><br><span class="line"><span class="comment">// 采用隐式值捕获方式</span></span><br><span class="line"><span class="keyword">auto</span> printByValue=[=]()&#123;cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="comment">// 采用隐式引用捕获方式</span></span><br><span class="line"><span class="keyword">auto</span> printByReference=[&amp;]()&#123;cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;endl;&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以采用<code>混合捕获方式</code>，对某个变量采用某种捕获方式，其他的均为另一种捕获方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval=<span class="number">11.11</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;HelloWorld!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 采用隐式值捕获方式</span></span><br><span class="line"><span class="comment">// ival和dval均为值捕获方式，str为引用捕获方式</span></span><br><span class="line"><span class="keyword">auto</span> printByValue=[=,&amp;str]()&#123;cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;str&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="comment">// 采用隐式引用捕获方式</span></span><br><span class="line"><span class="comment">// ival和dval均为引用捕获方式，str为值捕获方式</span></span><br><span class="line"><span class="keyword">auto</span> printByReference=[&amp;,str]()&#123;cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;str&lt;&lt;endl;&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们<code>混合使用隐式捕获和显式捕获</code>时，捕获列表中的第一个元素必须是一个<code>&amp;</code>或者<code>=</code>。此符号指定了默认捕获方式为引用或值。</p>
<blockquote>
<p>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获方式是值捕获，那么显式捕获的变量必须为引用捕获方式，反之亦然。</p>
</blockquote>
<h4 id="lambda的几种捕获方式"><a href="#lambda的几种捕获方式" class="headerlink" title="lambda的几种捕获方式"></a>lambda的几种捕获方式</h4><table>
<thead>
<tr>
<th align="center">捕获方式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[]</td>
<td align="left">空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们。</td>
</tr>
<tr>
<td align="center">[names]</td>
<td align="left">names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都是被拷贝。名字前如果使用了&amp;，则采用引用的捕获方式。</td>
</tr>
<tr>
<td align="center">[&amp;]</td>
<td align="left">隐式捕获列表。采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用。</td>
</tr>
<tr>
<td align="center">[=]</td>
<td align="left">隐式捕获列表。采用值捕获方式。lambda体将拷贝所使用的来自所在函数的实体的值。</td>
</tr>
<tr>
<td align="center">[&amp;,identifier_list]</td>
<td align="left">identifier_list是一个以逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。捕获列表中可以出现this。identifier_list中的名字前面不能使用&amp;。</td>
</tr>
<tr>
<td align="center">[=,identifier_list]</td>
<td align="left">identifier_list红的变量采用引用方式捕获，而任何隐式捕获的变量都采用值捕获方式。identifier_list中的名字不能包括this,且这些名字之前必须使用&amp;。</td>
</tr>
</tbody></table>
<h4 id="lambda位于成员函数中捕获this"><a href="#lambda位于成员函数中捕获this" class="headerlink" title="lambda位于成员函数中捕获this"></a>lambda位于成员函数中捕获this</h4><p>当lambda被用在成员函数中时，我们该如何访问类的成员呢？<br>可以吧this添加到捕获列表中，这样类的成员就位于可被捕获的名字集合中了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span>&#123;</span><br><span class="line">  function&lt;map&lt;string,string&gt;(<span class="type">const</span> map&lt;string,string&gt;&amp;)&gt; oper;   <span class="comment">// 操作</span></span><br><span class="line">  map&lt;string,string&gt; values;  <span class="comment">// 参数</span></span><br><span class="line">  map&lt;string,string&gt; results; <span class="comment">//目标</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Request</span>(<span class="type">const</span> string&amp; s); <span class="comment">//解析并保存请求</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    [<span class="keyword">this</span>]()&#123;results=<span class="built_in">oper</span>(values);&#125; <span class="comment">// 根据结果执行相应的操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员通过引用的方式捕获，也就是说<code>[this]</code>意味着成员是通过this访问的，而非拷贝到lambda中。</p>
<p><strong>[this]与[=]互不兼容，因此稍有不慎就可能在多线程程序中产生竞争条件。</strong></p>
<h4 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h4><p>默认情况下，对一个值被拷贝的变量，lambda不会改变其值。</p>
<p>如果我们希望能改变一个被捕获的变量的值，就必须在<code>参数列表后</code>加上<code>mutable</code>。因此，可变lambda能省略参数列表。</p>
<p>对于引用捕获，不需要显式在参数列表后加<code>mutable</code>关键字，但是对于值捕获方式一定需要。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval=<span class="number">11.11</span>;</span><br><span class="line"><span class="comment">// 采用引用捕获方式，不需要显式添加mutable关键字，在函数中修改的是被引用对象实际的值，这点与普通函数的引用形参类似</span></span><br><span class="line"><span class="keyword">auto</span> print=[&amp;]()&#123;cout&lt;&lt;--ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;--dval&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br></pre></td></tr></table></figure>

<p>但是对于采用值捕获方式的lambda就一定要使用<code>mutable</code>了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval=<span class="number">11.11</span>;</span><br><span class="line"><span class="comment">//不使用mutable会产生编译错误</span></span><br><span class="line"><span class="comment">// 错误：“x”: 无法在非可变 lambda 中修改通过复制捕获</span></span><br><span class="line"><span class="comment">// error: cannot assign to a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="comment">// auto print=[=]()&#123;cout&lt;&lt;--ival&lt;&lt;&quot;\t&quot;&lt;&lt;--dval&lt;&lt;endl;&#125;;</span></span><br><span class="line"><span class="comment">//正确的做法：使用mutable</span></span><br><span class="line"><span class="keyword">auto</span> print=[=]()<span class="keyword">mutable</span>&#123;cout&lt;&lt;--ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;--dval&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">cout&lt;&lt;ival&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;dval&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br><span class="line"><span class="comment">// 11 11.11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个lambda引用捕获的变量能否被修改依赖于此引用指向的是一个const类型还是一个非const类型。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival=<span class="number">11</span>;</span><br><span class="line"><span class="comment">// 错误: “ival”: 无法在非可变 lambda 中修改通过复制捕获</span></span><br><span class="line"><span class="comment">// error: cannot assign to variable &#x27;ival&#x27; with const-qualified type &#x27;const int&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> print=[&amp;]()&#123;cout&lt;&lt;--ival&lt;&lt;endl;&#125;;</span><br></pre></td></tr></table></figure>

<p>而采用值捕获方式同样具有这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> print = [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    <span class="comment">//通过值捕获的对象类型与外部函数局部变量的类型完全一致(如这里的const int)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">int</span>) == <span class="built_in">typeid</span>(ival)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="comment">//执行结果：yes</span></span><br></pre></td></tr></table></figure>

<p>所以，采用值捕获的对象的类型与函数局部变量的类型是完全一样的。</p>
<h4 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h4><p>默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他的void函数类似，被推断返回void的lambda不能返回值。</p>
<blockquote>
<p>lambda表达式的返回类型能由lambda表达式本身推断得到而普通函数无法做到这一点。<br>如果lambda的主体部分<strong>只包含一条return语句</strong>，则该lambda的返回类型是该return表达式的类型。(C++14中可以在未显式指定类型的情况下具有多个返回语句，但必须保证每个return返回的为同一类型，详细看后面)。</p>
</blockquote>
<p>首先要熟悉以下lambda的几种定义形式：</p>
<table>
<thead>
<tr>
<th align="left">Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[ capture-list ] ( params ) mutable(optional) exception attribute -&gt; ret { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] ( params ) -&gt; ret { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] ( params ) { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] { body }</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Explanation</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mutable</td>
<td>allows body to modify the parameters captured by copy, and to call their non-const member functions</td>
</tr>
<tr>
<td align="center">exception</td>
<td>provides the <a href="except_spec.html">exception specification</a> or the <a href="noexcept_spec.html">noexcept clause</a> for operator() of the closure type</td>
</tr>
<tr>
<td align="center">attribute</td>
<td>provides the <a href="attributes.html">attribute specification</a> for operator() of the closure type</td>
</tr>
<tr>
<td align="center">capture-list</td>
<td>a comma-separated list of zero or more <a href="lambda.html#Lambda_capture">captures</a>, optionally beginning with a capture-default.Capture list can be passed as follows (see below for the detailed description):<code>**[a,&amp;b]**</code> where <em>a</em> is captured by value and <em>b</em> is captured by reference.<code>**[this]**</code> captures the <a href="this.html"><code>**this**</code> pointer</a> by value<code>**[&amp;]**</code> captures all <a href="storage_duration.html">automatic</a> variables <a href="definition.html#ODR-use">odr-used</a> in the body of the lambda by reference<code>**[=]**</code> captures all <a href="storage_duration.html">automatic</a> variables <a href="definition.html#ODR-use">odr-used</a> in the body of the lambda by value<code>**[]**</code> captures nothing</td>
</tr>
<tr>
<td align="center">params</td>
<td>The list of parameters, as in <a href="function.html">named functions</a>, except that <a href="default_arguments.html">default arguments</a> are not allowed (until C++14). if<code>auto</code> is used as a type of a parameter, the lambda is a <em>generic lambda</em> (since C++14)</td>
</tr>
<tr>
<td align="center">ret</td>
<td>Return type. If not present it’s implied by the function return statements ( or void if it doesn’t return any value)</td>
</tr>
<tr>
<td align="center">body</td>
<td>Function body</td>
</tr>
</tbody></table>
<p>考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个序列中的所有值转换为其绝对值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:v)</span><br><span class="line">  cout&lt;&lt;index&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v.<span class="built_in">begin</span>(),[](<span class="type">int</span> i)&#123;<span class="keyword">return</span> i&lt;<span class="number">0</span>?-i:i;&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:v)</span><br><span class="line">  cout&lt;&lt;index&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/13.webp"></p>
<p><code>transform</code>算法是定义在<code>algorithm</code>头文件中的，函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">( InputIt first1, InputIt last1, OutputIt d_first,UnaryOperation unary_op )</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们传递给transform一个lambda，它返回其参数的绝对值。lambda体是单一的return语句，返回一个表达式的结果，我们无需指定返回类型，因为可以根据条件运算符的类型推断出来。</p>
<p>但是，如果我们使用<strong>看似</strong>等价的if语句，就会产生错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11中错误的做法，不支持隐式推导多个返回表达式</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v.<span class="built_in">begin</span>(),[](<span class="type">int</span> i)&#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;<span class="keyword">return</span> -i:&#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> i;&#125;&#125;);</span><br><span class="line"><span class="comment">// 正确的做法，显式使用尾置返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v.<span class="built_in">begin</span>(),[](<span class="type">int</span> i)-&gt;<span class="type">int</span>&#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;<span class="keyword">return</span> -i:&#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> i;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>但是我使用clang++和g++编译并不会报错（WTF）。</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/14.webp"></p>
<p>通过查资料发现：<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions (since C++11) - cppreference</a>和<a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/cpp14-language">C++14 Language Extensions</a></p>
<p>C++11 permitted automatically deducing the return type of a lambda function whose body consisted of only a single <code>return</code> statement:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line">[=]() -&gt; some_type &#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line">[=]                &#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br></pre></td></tr></table></figure>

<p>This has been expanded in two ways. First, it now works even with more complex function bodies containing more than one <code>return</code> statement, as long as all return statements return the same type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14</span></span><br><span class="line">[=] &#123;                                     <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">something</span>() ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( expr ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>;            <span class="comment">// with arbitrary control flow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar.<span class="built_in">baz</span>(<span class="number">84</span>);                   <span class="comment">// &amp; multiple returns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Second, it now works with all functions, not just lambdas:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11, explicitly named return type</span></span><br><span class="line"><span class="function">some_type <span class="title">f</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; some_type </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span>              </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123;                                <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">something</span>() ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( expr ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>;            <span class="comment">// with arbitrary control flow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar.<span class="built_in">baz</span>(<span class="number">84</span>);                   <span class="comment">// &amp; multiple returns</span></span><br><span class="line">&#125;                                         <span class="comment">//   (types must be the same)</span></span><br></pre></td></tr></table></figure>

<p>Of course, this requires the function body to be visible.</p>
<p>Finally, someone will ask: “Hmm, does this work for recursive functions?” The answer is yes, as long as a <code>return</code> precedes the recursive call.</p>
<p>See also:</p>
<ul>
<li>[N3638] Jason Merrill: <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html">Return type deduction for normal functions</a>.</li>
</ul>
<p>总得来说就是：</p>
<p>C++14可以在不使用<code>尾置返回</code>(multiple return)的情况下，具有多个返回表达式，但是这些返回值的类型必须相同。</p>
<p>但是C++11并没有这个性质，所以我推测，可能是编译器的bug…</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作可以使用lambda表达式，但是如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是通过多次编写相同的lambda表达式。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来代替它。</p>
<p>如介绍lambda时使用的样例代码那样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">5</span>;</span><br><span class="line">vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//如果捕获列表为空，则在lambda函数体中使用num是错误的</span></span><br><span class="line"><span class="comment">//error: 无法隐式捕获“num”，因为尚未指定默认捕获模式</span></span><br><span class="line"><span class="keyword">auto</span> oneIndex=<span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(),word.<span class="built_in">end</span>(),[num](<span class="type">const</span> string&amp; a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=num;&#125;);</span><br><span class="line"><span class="comment">//得到的是word中第一个长度超过5的元素</span></span><br><span class="line">cout&lt;&lt;*oneIndex&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>我们既可以使用lambda(代码如上)也可以定义一个函数来实现:：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s,string::size_type sz)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们不能将这个函数用作<code>find_if</code>的一个参数。如前文介绍lambda所述，find_if需要接收一个<code>一元谓词</code>参数，因此传递给find_if的参数必须为接收单一参数。为了使用check_size来代替lambda，必须解决如何向sz形参传递一个参数的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check_size的调用形式</span></span><br><span class="line"><span class="built_in">check_size</span>(strObj,sizeNum);</span><br><span class="line"><span class="comment">//find_if只能接收的谓词,当前需要解决的问题是如何在find_if只能接收一个一元谓词的情况下调用check_size并将sizeNum传递给它</span></span><br><span class="line"><span class="built_in">check_size</span>(strObj);</span><br></pre></td></tr></table></figure>

<h4 id="标准bind函数"><a href="#标准bind函数" class="headerlink" title="标准bind函数"></a>标准bind函数</h4><p>通过bind函数我们可以解决向check_size传递一个长度参数的问题。</p>
<p><code>bind</code>标准库函数，它定义在头文件functional中。可以将bind函数看做一个通用的函数适配器，它是一个可调用对象，生成一个新的可调用对象来”适应“原对象的参数列表。</p>
<p>调用bind的一般形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable=<span class="built_in">bind</span>(callable,arg_list);</span><br></pre></td></tr></table></figure>

<p>其中<code>newCallable</code>本身一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arf_list中的参数。</p>
<p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中n是一个整数这些参数是“占位符”，表示newCallable的参数，他们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：<code>_1</code>为newCallable的第一个参数，<code>_2</code>为第二个参数，以此类推。</p>
<h4 id="使用placeholders名字"><a href="#使用placeholders名字" class="headerlink" title="使用placeholders名字"></a>使用placeholders名字</h4><p>注意：名字<code>_n</code>都定义在一个名为<code>placeholders</code>的命名空间中，而这个命名空间本身定义在<code>std</code>命名空间。</p>
<p>所以，当我们在bind中使用<code>_1、_2</code>这样的参数时一定要使用std::placeholders命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该命名空间中的所有名字都可以在程序中使用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="comment">// 或者使用std::placeholders指定单个的名字</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// 或者直接在使用处指定命名空间</span></span><br><span class="line"><span class="keyword">auto</span> check6=<span class="built_in">bind</span>(check_size,std::placeholders::_1,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>否则，编译时会报错:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/15.webp"></p>
<h4 id="通过bind来绑定参数"><a href="#通过bind来绑定参数" class="headerlink" title="通过bind来绑定参数"></a>通过bind来绑定参数</h4><p><strong>通过bind来绑定check_size的sz参数</strong>从而生成一个接受一个参数的谓词(一元谓词)。</p>
<p>前面已经讲到，我们需要将接收两个参数的check_size传递给必须接收一元谓词的函数find_if，所以我们需要使用bind生成一个对check_size的进行调用操作的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check6是一个可调用对象，接受一个steing类型的参数</span></span><br><span class="line"><span class="comment">// 并用此string和6来调用check_size</span></span><br><span class="line"><span class="keyword">auto</span> check6=<span class="built_in">bind</span>(check_size,_1,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在<code>arg_list</code>的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const_string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl=<span class="built_in">check6</span>(s);</span><br></pre></td></tr></table></figure>

<p>通过使用<code>gprof</code>可以看到，check_size被调用了一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> %   cumulative   self              self     total</span><br><span class="line">time   seconds   seconds    calls  Ts/call  Ts/call  name</span><br><span class="line"> <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">0.00</span>        <span class="number">1</span>     <span class="number">0.00</span>     <span class="number">0.00</span>  <span class="built_in">check_size</span>(<span class="comment">/*节约篇幅忽略参数*/</span>)</span><br></pre></td></tr></table></figure>

<p>使用bind，我们可以将原来基于lambda的find_if调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),worda.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string &amp;a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure>

<p>替换为使用check_size的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(check_size,_1,sz));</span><br></pre></td></tr></table></figure>

<p>此bind调用生成一个可调用对象，将check_size的第二个参数绑定到sz的值。当find_if对words中的string调用这个对象时，这些对象会调用check_size，将给定的string和sz传递给它。因此，find_if可以有效地对输入序列中每个string调用check_size，实现string的大小与sz的比较。</p>
<h4 id="bind的参数"><a href="#bind的参数" class="headerlink" title="bind的参数"></a>bind的参数</h4><p>前面提到，我们可以用bind来修正参数的值。更一般的情况是，可以使用bind绑定给可调用对象中的参数或重新安排其参数顺序。</p>
<p>例如，f是一个可调用对象，他有5个参数，则下面对bind的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g=<span class="built_in">bind</span>(f,a,b,_2,c,_1);</span><br></pre></td></tr></table></figure>

<p>上面的代码会生成一个可调用对象，它有两个参数，分别用占位符_1和_2和表示。这个新的可调用对象将他自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别绑定到给定的值a、b和c上。</p>
<p>传递给g的参数<code>按位置绑定到占位符</code>。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。</p>
<p>实际上这个调用会将<code>g(_1,_2)</code>映射为<code>f(a,b,_2,c,_1)</code>。即，对g的调用会调用f，用g的参数代替占位符，再加上绑定的参数a、b和c。例如，调用g(X,Y)会调用f(a,b,Y,c,X);</p>
<h5 id="用bind重排参数顺序"><a href="#用bind重排参数顺序" class="headerlink" title="用bind重排参数顺序"></a>用bind重排参数顺序</h5><p>注意：<code>sort</code>定义在<code>algorithm</code>头文件中，使用前需包含。</p>
<p>我们可以使用sort对容器排序，首先定义一个二元谓词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用sort来排序一个vector<string>容器中存放的数据(升序)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; words&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:words)</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>执行后的结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I to my need heart follow</span><br></pre></td></tr></table></figure>

<p>排序结果是由升序排列的，但是如果我们想要降序排列呢？只能修改isShorter函数实现吗？</p>
<p>其实不然，可以使用bind来重排参数的顺序来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将sort谓词的第一个参数作为isShorter的第二个参数</span></span><br><span class="line"><span class="comment">// 将sort谓词的第二个参数作为isShorter的第一个参数</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(isShorter,_2,_1));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:words)</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>执行后的结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">follow heart need to my I</span><br></pre></td></tr></table></figure>

<h4 id="绑定引用参数-ref-n"><a href="#绑定引用参数-ref-n" class="headerlink" title="绑定引用参数(ref(_n))"></a>绑定引用参数(ref(_n))</h4><p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda相似，优势对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝(IO对象不能被拷贝或赋值)。</p>
<p>例如，为了替换一个捕获<code>ostream</code>(不能被拷贝)的lambda:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os是一个局部变量，引用一个输出流</span></span><br><span class="line"><span class="comment">// c是一个局部变量，类型为char</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(,[&amp;s](<span class="type">const</span> string &amp;s)&#123;os&lt;&lt;s&lt;&lt;c;&#125;));</span><br></pre></td></tr></table></figure>

<p>我们可以很容易的编写一个函数来完成相同的工作:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">osteram &amp;<span class="title">print</span><span class="params">(osteram &amp;os,<span class="type">const</span> string &amp;s,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> os&lt;&lt;s&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不能直接用bind来代替对os的捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，不能拷贝os</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(print,os,_1,<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用<code>标准库ref函数</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(print,<span class="built_in">ref</span>(os),_1,<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>函数<code>ref</code>返回一个对象，包含给定的引用，此对象时可以拷贝的。标准库中还有一个<code>cref</code>函数，生成一个保存const引用的类。与bind一样，函数<code>ref</code>和<code>cref</code>也均是定义在<code>functional</code>头文件中。</p>
<h4 id="向后兼容：参数绑定"><a href="#向后兼容：参数绑定" class="headerlink" title="向后兼容：参数绑定"></a>向后兼容：参数绑定</h4><p>旧版本的标准库(C++11之前)定义了两个分别名为<code>bind1sd</code>和<code>bind2nd</code>的函数。类似bind，这两个函数接受一个函数作为参数，生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给他。但是，这些函数分别只能绑定第一个或第二个参数。由于这些函数局限性太强，新标准中已经弃用(deprecated)。所谓被弃用的特性就是在新版本中不再支持的特性。在新的C++程序中应该使用bind。</p>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                全文完，若有不足之处请评论指正。
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>微信扫描二维码，关注我的公众号。</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>本文标题:</span><a href="/posts/2441/" target="_blank">C++11的语法糖</a><br/>
             <span>文章作者:</span><a href="/about" target="_blank" title="查看 查利鹏 的资料">查利鹏</a><br/>
             <span>发布时间:</span>2016年05月12日 22时30分<br/>
             
             <span>本文字数:</span><span class="page-count">本文一共有23k字</span><br/>
             
             <span>原始链接:</span><a href="/posts/2441/" target="_blank" title="C++11的语法糖">https://imzlp.com/posts/2441/</a>
             <span class="copy-path" data-clipboard-text="原文链接: https://imzlp.com/posts/2441/ 作者: 查利鹏" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>文章禁止全文转载，摘要转发请保留原文链接及作者信息，谢谢！</span>
          </div>
        
    
        
  <div class="reward-container">
    <div>您的捐赠将鼓励我继续创作！</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      打赏
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="查利鹏 微信支付">
          <p>微信支付</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/C-11/" rel="tag"># C++11</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/58483/" rel="prev" title="进程间通信">
      <i class="fa fa-chevron-left"></i> 进程间通信
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/50773/" rel="next" title="STL释放指针元素时造成的内存泄露">
      STL释放指针元素时造成的内存泄露 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%80%BC%E5%BA%8F%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">列表值序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">列表初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">初始值列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.3.</span> <span class="nav-text">列表初始化返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">关联容器的列表初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96pair%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">列表初始化pair的返回类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr%E5%B8%B8%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">nullptr常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr"><span class="nav-number">3.</span> <span class="nav-text">constexpr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.</span> <span class="nav-text">constexpr变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr%E6%8C%87%E9%92%88"><span class="nav-number">3.2.</span> <span class="nav-text">constexpr指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">constexpr函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">constexpr构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">地址常量表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.</span> <span class="nav-text">类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-number">4.1.</span> <span class="nav-text">auto类型说明符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">decltype类型指示符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#decltype%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">decltype和引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8auto%E5%92%8Cdecltype%E6%9D%A5%E7%AE%80%E5%8C%96%E5%A3%B0%E6%98%8E"><span class="nav-number">4.3.</span> <span class="nav-text">使用auto和decltype来简化声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">5.</span> <span class="nav-text">using类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.</span> <span class="nav-text">范围for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E7%9A%84%E8%88%8D%E5%85%A5%E8%A7%84%E5%88%99"><span class="nav-number">7.</span> <span class="nav-text">除法的舍入规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof"><span class="nav-number">8.</span> <span class="nav-text">sizeof</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-number">8.1.</span> <span class="nav-text">用于类对象成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">8.2.</span> <span class="nav-text">用于不同对象得到的结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">尾置返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">10.</span> <span class="nav-text">类的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">10.1.</span> <span class="nav-text">类内初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E9%83%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">10.2.</span> <span class="nav-text">类对象成员的类内部初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-default%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.3.</span> <span class="nav-text">使用&#x3D;default生成默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.4.</span> <span class="nav-text">委托构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8string%E5%AF%B9%E8%B1%A1%E5%BD%93%E5%81%9A%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">11.</span> <span class="nav-text">使用string对象当做文件流对象的文件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7"><span class="nav-number">12.</span> <span class="nav-text">STL容器相关特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#array%E5%92%8Cforward-list%E5%AE%B9%E5%99%A8"><span class="nav-number">12.1.</span> <span class="nav-text">array和forward_list容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initializer-list%E5%BD%A2%E5%8F%82"><span class="nav-number">12.2.</span> <span class="nav-text">initializer_list形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0swap"><span class="nav-number">12.3.</span> <span class="nav-text">容器的非成员函数swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84insert%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.4.</span> <span class="nav-text">容器的insert返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#emplace%E6%93%8D%E4%BD%9C"><span class="nav-number">12.5.</span> <span class="nav-text">emplace操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">12.6.</span> <span class="nav-text">string数值转换函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%AE%B9%E9%87%8F%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">12.7.</span> <span class="nav-text">管理容量的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#capacity%E5%92%8Csize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.7.1.</span> <span class="nav-text">capacity和size的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">12.8.</span> <span class="nav-text">无序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">12.8.1.</span> <span class="nav-text">使用无序容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E6%A1%B6"><span class="nav-number">12.8.2.</span> <span class="nav-text">管理桶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">12.8.3.</span> <span class="nav-text">无序容器对关键字类型的要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91lambda%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">13.1.</span> <span class="nav-text">向lambda传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="nav-number">13.2.</span> <span class="nav-text">使用捕获列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D"><span class="nav-number">13.2.1.</span> <span class="nav-text">谓词</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-number">14.</span> <span class="nav-text">lambda捕获和返回</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E6%8D%95%E8%8E%B7"><span class="nav-number">14.1.</span> <span class="nav-text">值捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7"><span class="nav-number">14.2.</span> <span class="nav-text">引用捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">14.3.</span> <span class="nav-text">隐式捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">14.4.</span> <span class="nav-text">lambda的几种捕获方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E4%BD%8D%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8D%95%E8%8E%B7this"><span class="nav-number">14.5.</span> <span class="nav-text">lambda位于成员函数中捕获this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98lambda"><span class="nav-number">14.6.</span> <span class="nav-text">可变lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9Alambda%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.7.</span> <span class="nav-text">指定lambda返回类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">15.</span> <span class="nav-text">参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86bind%E5%87%BD%E6%95%B0"><span class="nav-number">15.1.</span> <span class="nav-text">标准bind函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8placeholders%E5%90%8D%E5%AD%97"><span class="nav-number">15.2.</span> <span class="nav-text">使用placeholders名字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87bind%E6%9D%A5%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="nav-number">15.3.</span> <span class="nav-text">通过bind来绑定参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">15.4.</span> <span class="nav-text">bind的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8bind%E9%87%8D%E6%8E%92%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="nav-number">15.4.1.</span> <span class="nav-text">用bind重排参数顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0-ref-n"><span class="nav-number">15.5.</span> <span class="nav-text">绑定引用参数(ref(_n))</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%EF%BC%9A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">15.6.</span> <span class="nav-text">向后兼容：参数绑定</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="查利鹏"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">查利鹏</p>
  <div class="site-description" itemprop="description">唯有热爱可抵岁月漫长。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021027036号 </a>
      <img src="/images/beian_logo.webp" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502007298" rel="noopener" target="_blank">粤公网安备44030502007298号 </a>
  </div>

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">查利鹏</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">747k</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imzlp.com/posts/2441/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "留下点什么吧~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
